This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: pkg
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
pkg/
  api/
    applications.go
    client.go
  autocomplete/
    autocomplete_test.go
    autocomplete.go
  config/
    cli_config.go
  context/
    timeouts.go
  errors/
    analytics.go
    handler.go
    types.go
  logging/
    logger.go
  model/
    messages.go
    state.go
    types.go
  neat/
    neat_test.go
    neat.go
  retry/
    retry.go
  services/
    argo.go
    degradation.go
    enhanced.go
    navigation.go
    recovery.go
    status.go
  tui/
    treeview/
      treeview.go
    errors.go
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="pkg/autocomplete/autocomplete_test.go">
package autocomplete

import (
	"reflect"
	"testing"

	"github.com/darksworm/argonaut/pkg/model"
)

func createTestState() *model.AppState {
	prodCluster := "prod"
	stagingCluster := "staging"
	analyticsCluster := "analytics"
	webNamespace := "web"
	apiNamespace := "api"
	dataNamespace := "data"
	metricsNamespace := "metrics"
	ecommerceProject := "ecommerce"
	platformProject := "platform"

	state := &model.AppState{
		Apps: []model.App{
			{Name: "frontend", ClusterLabel: &prodCluster, Namespace: &webNamespace, Project: &ecommerceProject},
			{Name: "backend", ClusterLabel: &prodCluster, Namespace: &apiNamespace, Project: &ecommerceProject},
			{Name: "database", ClusterLabel: &stagingCluster, Namespace: &dataNamespace, Project: &ecommerceProject},
			{Name: "cache", ClusterLabel: &prodCluster, Namespace: &webNamespace, Project: &platformProject},
			{Name: "analytics", ClusterLabel: &analyticsCluster, Namespace: &metricsNamespace, Project: &platformProject},
		},
		Selections: *model.NewSelectionState(),
	}
	return state
}

func TestResolveAlias(t *testing.T) {
	engine := NewAutocompleteEngine()

	tests := []struct {
		input    string
		expected string
	}{
		{"cluster", "cluster"},
		{"clusters", "cluster"},
		{"cls", "cluster"},
		{"namespace", "namespace"},
		{"namespaces", "namespace"},
		{"ns", "namespace"},
		{"app", "app"},
		{"apps", "app"},
		{"applications", "app"},
		{"sync", "sync"},
		{"s", "sync"},
		{"diff", "diff"},
		{"d", "diff"},
		{"logs", "logs"},
		{"log", "logs"},
		{"l", "logs"},
		{"unknown", "unknown"}, // Should return input if not found
	}

	for _, test := range tests {
		result := engine.ResolveAlias(test.input)
		if result != test.expected {
			t.Errorf("ResolveAlias(%s) = %s, expected %s", test.input, result, test.expected)
		}
	}
}

func TestGetCommandInfo(t *testing.T) {
	engine := NewAutocompleteEngine()

	// Test valid command
	info := engine.GetCommandInfo("cluster")
	if info == nil {
		t.Fatal("GetCommandInfo(cluster) should not return nil")
	}
	if info.Command != "cluster" {
		t.Errorf("Expected command 'cluster', got %s", info.Command)
	}
	if !info.TakesArg {
		t.Error("cluster command should take an argument")
	}

	// Test alias resolution
	info = engine.GetCommandInfo("cls")
	if info == nil || info.Command != "cluster" {
		t.Error("GetCommandInfo should resolve alias 'cls' to 'cluster'")
	}

	// Test invalid command
	info = engine.GetCommandInfo("invalid")
	if info != nil {
		t.Error("GetCommandInfo(invalid) should return nil")
	}
}

func TestGetCommandAutocomplete_EmptyInput(t *testing.T) {
	engine := NewAutocompleteEngine()
	state := createTestState()

	// Test just ":"
	suggestions := engine.GetCommandAutocomplete(":", state)
	if len(suggestions) == 0 {
		t.Error("Should return command suggestions for ':'")
	}

	// Should contain all primary commands
	expected := []string{":all", ":app", ":cluster", ":diff", ":license", ":logs", ":namespace", ":project", ":resources", ":rollback", ":sync", ":up"}

	// Check that all expected commands are present (subset check since we have aliases)
	for _, exp := range expected {
		found := false
		for _, sug := range suggestions {
			if sug == exp {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("Expected suggestion '%s' not found in %v", exp, suggestions)
		}
	}
}

func TestGetCommandAutocomplete_CommandCompletion(t *testing.T) {
	engine := NewAutocompleteEngine()
	state := createTestState()

	// Test partial command
	suggestions := engine.GetCommandAutocomplete(":cl", state)
	expected := []string{":clear", ":cluster", ":clusters", ":cls"}

	for _, exp := range expected {
		found := false
		for _, sug := range suggestions {
			if sug == exp {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("Expected suggestion '%s' not found in %v", exp, suggestions)
		}
	}
}

func TestGetCommandAutocomplete_ArgumentCompletion(t *testing.T) {
	engine := NewAutocompleteEngine()
	state := createTestState()

	// Test GetArgumentSuggestions directly first
	directSuggestions := engine.GetArgumentSuggestions("cluster", "", state)
	t.Logf("Direct argument suggestions for 'cluster': %v", directSuggestions)

	// Test cluster argument completion
	suggestions := engine.GetCommandAutocomplete(":cluster ", state)
	t.Logf("GetCommandAutocomplete result for ':cluster ': %v", suggestions)

	// Should suggest all clusters
	expectedClusters := []string{":cluster analytics", ":cluster prod", ":cluster staging"}
	if !reflect.DeepEqual(suggestions, expectedClusters) {
		t.Errorf("Expected %v, got %v", expectedClusters, suggestions)
	}

	// Test partial cluster completion
	suggestions = engine.GetCommandAutocomplete(":cluster p", state)
	expected := []string{":cluster prod"}
	if !reflect.DeepEqual(suggestions, expected) {
		t.Errorf("Expected %v, got %v", expected, suggestions)
	}
}

func TestGetCommandAutocomplete_FilteredSuggestions(t *testing.T) {
	engine := NewAutocompleteEngine()
	state := createTestState()

	// Set cluster scope to "prod"
	state.Selections.ScopeClusters = model.StringSetFromSlice([]string{"prod"})

	// Test namespace completion with cluster filter
	suggestions := engine.GetCommandAutocomplete(":namespace ", state)

	// Should only suggest namespaces from "prod" cluster
	expected := []string{":namespace api", ":namespace web"}
	if !reflect.DeepEqual(suggestions, expected) {
		t.Errorf("Expected %v, got %v", expected, suggestions)
	}

	// Add namespace scope
	state.Selections.ScopeNamespaces = model.StringSetFromSlice([]string{"web"})

	// Test project completion with cluster and namespace filters
	suggestions = engine.GetCommandAutocomplete(":project ", state)
	expected = []string{":project ecommerce", ":project platform"}
	if !reflect.DeepEqual(suggestions, expected) {
		t.Errorf("Expected %v, got %v", expected, suggestions)
	}

	// Test app completion with all filters
	state.Selections.ScopeProjects = model.StringSetFromSlice([]string{"ecommerce"})
	suggestions = engine.GetCommandAutocomplete(":app ", state)
	expected = []string{":app frontend"}
	if !reflect.DeepEqual(suggestions, expected) {
		t.Errorf("Expected %v, got %v", expected, suggestions)
	}
}

func TestGetCommandAutocomplete_NoArgumentCommands(t *testing.T) {
	engine := NewAutocompleteEngine()
	state := createTestState()

	// Test commands that don't take arguments
	suggestions := engine.GetCommandAutocomplete(":logs ", state)
	if suggestions != nil {
		t.Error("logs command should not provide argument suggestions")
	}

	suggestions = engine.GetCommandAutocomplete(":all ", state)
	if suggestions != nil {
		t.Error("all command should not provide argument suggestions")
	}
}

func TestGetCommandAutocomplete_InvalidInput(t *testing.T) {
	engine := NewAutocompleteEngine()
	state := createTestState()

	// Test input not starting with ":"
	suggestions := engine.GetCommandAutocomplete("cluster", state)
	if suggestions != nil {
		t.Error("Should return nil for input not starting with ':'")
	}

	// Test empty input
	suggestions = engine.GetCommandAutocomplete("", state)
	if suggestions != nil {
		t.Error("Should return nil for empty input")
	}
}

func TestGetCommandAutocomplete_CaseInsensitive(t *testing.T) {
	engine := NewAutocompleteEngine()
	state := createTestState()

	// Test case insensitive command matching
	suggestions1 := engine.GetCommandAutocomplete(":CL", state)
	suggestions2 := engine.GetCommandAutocomplete(":cl", state)

	if !reflect.DeepEqual(suggestions1, suggestions2) {
		t.Error("Command matching should be case insensitive")
	}

	// Test case insensitive argument matching
	suggestions1 = engine.GetCommandAutocomplete(":cluster P", state)
	suggestions2 = engine.GetCommandAutocomplete(":cluster p", state)

	if !reflect.DeepEqual(suggestions1, suggestions2) {
		t.Error("Argument matching should be case insensitive")
	}
}
</file>

<file path="pkg/autocomplete/autocomplete.go">
package autocomplete

import (
	"fmt"
	"sort"
	"strings"

	"github.com/darksworm/argonaut/pkg/model"
)

// CommandAlias represents a command with its aliases and metadata
type CommandAlias struct {
	Command     string   // Primary command name
	Aliases     []string // All possible aliases for this command
	Description string   // Help text for the command
	TakesArg    bool     // Whether command accepts an argument
	ArgType     string   // Type of argument (e.g., "app", "cluster")
}

// AliasMap maps all command variants to their canonical command
type AliasMap map[string]string

// AutocompleteEngine handles command completion and aliases
type AutocompleteEngine struct {
	commands []CommandAlias
	aliasMap AliasMap
}

// NewAutocompleteEngine creates a new autocomplete engine with command definitions
func NewAutocompleteEngine() *AutocompleteEngine {
	commands := []CommandAlias{
		{
			Command:     "cluster",
			Aliases:     []string{"cluster", "clusters", "cls"},
			Description: "Navigate to clusters view",
			TakesArg:    true,
			ArgType:     "cluster",
		},
		{
			Command:     "namespace",
			Aliases:     []string{"namespace", "namespaces", "ns"},
			Description: "Navigate to namespaces view",
			TakesArg:    true,
			ArgType:     "namespace",
		},
		{
			Command:     "project",
			Aliases:     []string{"project", "projects", "proj"},
			Description: "Navigate to projects view",
			TakesArg:    true,
			ArgType:     "project",
		},
		{
			Command:     "app",
			Aliases:     []string{"app", "apps", "application", "applications"},
			Description: "Navigate to applications view",
			TakesArg:    true,
			ArgType:     "app",
		},
		{
			Command:     "sync",
			Aliases:     []string{"sync", "s"},
			Description: "Sync selected applications",
			TakesArg:    true,
			ArgType:     "app",
		},
		{
			Command:     "diff",
			Aliases:     []string{"diff", "d"},
			Description: "Show diff for application",
			TakesArg:    true,
			ArgType:     "app",
		},
		{
			Command:     "rollback",
			Aliases:     []string{"rollback", "rb", "revert"},
			Description: "Rollback application to previous revision",
			TakesArg:    true,
			ArgType:     "app",
		},
		{
			Command:     "resources",
			Aliases:     []string{"resources", "res", "r"},
			Description: "Show resources for application",
			TakesArg:    true,
			ArgType:     "app",
		},
		{
			Command:     "logs",
			Aliases:     []string{"logs", "log", "l"},
			Description: "Show application logs",
			TakesArg:    false,
			ArgType:     "",
		},
		{
			Command:     "all",
			Aliases:     []string{"all", "clear", "reset"},
			Description: "Clear all filters and selections",
			TakesArg:    false,
			ArgType:     "",
		},
		{
			Command:     "up",
			Aliases:     []string{"up", "back", ".."},
			Description: "Go up one level in navigation",
			TakesArg:    false,
			ArgType:     "",
		},
		{
			Command:     "license",
			Aliases:     []string{"license", "licenses", "about"},
			Description: "Show license information",
			TakesArg:    false,
			ArgType:     "",
		},
		{
			Command:     "quit",
			Aliases:     []string{"quit", "q", "q!", "exit"},
			Description: "Exit the application",
			TakesArg:    false,
			ArgType:     "",
		},
	}

	// Build alias map
	aliasMap := make(AliasMap)
	for _, cmd := range commands {
		for _, alias := range cmd.Aliases {
			aliasMap[alias] = cmd.Command
		}
	}

	return &AutocompleteEngine{
		commands: commands,
		aliasMap: aliasMap,
	}
}

// ResolveAlias converts any command alias to its canonical form
func (e *AutocompleteEngine) ResolveAlias(input string) string {
	if canonical, exists := e.aliasMap[strings.ToLower(input)]; exists {
		return canonical
	}
	return input
}

// GetCommandInfo returns command information for a given command or alias
func (e *AutocompleteEngine) GetCommandInfo(input string) *CommandAlias {
	canonical := e.ResolveAlias(input)
	for _, cmd := range e.commands {
		if cmd.Command == canonical {
			return &cmd
		}
	}
	return nil
}

// GetCommandAutocomplete returns autocomplete suggestions for command input
func (e *AutocompleteEngine) GetCommandAutocomplete(input string, state *model.AppState) []string {
	// Check for trailing space BEFORE trimming
	hasTrailingSpace := strings.HasSuffix(input, " ")

	// Trim only leading space, keep trailing space info
	input = strings.TrimSpace(input)

	// Must start with ":"
	if !strings.HasPrefix(input, ":") {
		return nil
	}

	// Remove the ":"
	command := input[1:]

	// Split into command and argument parts
	parts := strings.Fields(command)


	if len(parts) == 0 {
		// Just ":" - return all command suggestions
		return e.getAllCommandSuggestions("")
	}

	if len(parts) == 1 {
		if hasTrailingSpace {
			// Command is complete, suggest arguments (e.g., ":cluster ")
			return e.getArgumentSuggestions(parts[0], "", state)
		} else {
			// Command completion (no space yet, e.g., ":cl")
			return e.getAllCommandSuggestions(parts[0])
		}
	}

	if len(parts) == 2 {
		// Argument completion (e.g., ":cluster pr")
		return e.getArgumentSuggestions(parts[0], parts[1], state)
	}

	return nil
}

// getAllCommandSuggestions returns command name suggestions
func (e *AutocompleteEngine) getAllCommandSuggestions(prefix string) []string {
	var suggestions []string
	prefix = strings.ToLower(prefix)

	// Collect unique command names that match prefix
	seen := make(map[string]bool)

	for _, cmd := range e.commands {
		for _, alias := range cmd.Aliases {
			if strings.HasPrefix(strings.ToLower(alias), prefix) {
				if !seen[alias] {
					suggestions = append(suggestions, ":"+alias)
					seen[alias] = true
				}
			}
		}
	}

	sort.Strings(suggestions)
	return suggestions
}

// GetArgumentSuggestions returns argument suggestions for a command (public for debugging)
func (e *AutocompleteEngine) GetArgumentSuggestions(command, argPrefix string, state *model.AppState) []string {
	return e.getArgumentSuggestions(command, argPrefix, state)
}

// getArgumentSuggestions returns argument suggestions for a command
func (e *AutocompleteEngine) getArgumentSuggestions(command, argPrefix string, state *model.AppState) []string {
	cmdInfo := e.GetCommandInfo(command)
	if cmdInfo == nil || !cmdInfo.TakesArg {
		return nil
	}

	argPrefix = strings.ToLower(argPrefix)
	var suggestions []string

	switch cmdInfo.ArgType {
	case "cluster":
		suggestions = e.getClusterSuggestions(argPrefix, state)
	case "namespace":
		suggestions = e.getNamespaceSuggestions(argPrefix, state)
	case "project":
		suggestions = e.getProjectSuggestions(argPrefix, state)
	case "app":
		suggestions = e.getAppSuggestions(argPrefix, state)
	}

	// Add command prefix to suggestions
	prefixedSuggestions := make([]string, len(suggestions))
	for i, suggestion := range suggestions {
		prefixedSuggestions[i] = ":" + command + " " + suggestion
	}

	return prefixedSuggestions
}

// getClusterSuggestions returns cluster name suggestions
func (e *AutocompleteEngine) getClusterSuggestions(prefix string, state *model.AppState) []string {
	var suggestions []string
	seen := make(map[string]bool)

	for _, app := range state.Apps {
		if app.ClusterLabel == nil {
			continue
		}
		cluster := strings.ToLower(*app.ClusterLabel)
		if strings.HasPrefix(cluster, prefix) && !seen[cluster] {
			suggestions = append(suggestions, *app.ClusterLabel)
			seen[cluster] = true
		}
	}

	sort.Strings(suggestions)
	return suggestions
}

// getNamespaceSuggestions returns namespace suggestions (filtered by selected clusters)
func (e *AutocompleteEngine) getNamespaceSuggestions(prefix string, state *model.AppState) []string {
	var suggestions []string
	seen := make(map[string]bool)

	for _, app := range state.Apps {
		if app.ClusterLabel == nil || app.Namespace == nil {
			continue
		}

		// Apply cluster filtering if clusters are selected
		if len(state.Selections.ScopeClusters) > 0 {
			if !model.HasInStringSet(state.Selections.ScopeClusters, *app.ClusterLabel) {
				continue
			}
		}

		namespace := strings.ToLower(*app.Namespace)
		if strings.HasPrefix(namespace, prefix) && !seen[namespace] {
			suggestions = append(suggestions, *app.Namespace)
			seen[namespace] = true
		}
	}

	sort.Strings(suggestions)
	return suggestions
}

// getProjectSuggestions returns project suggestions (filtered by selected clusters/namespaces)
func (e *AutocompleteEngine) getProjectSuggestions(prefix string, state *model.AppState) []string {
	var suggestions []string
	seen := make(map[string]bool)

	for _, app := range state.Apps {
		if app.ClusterLabel == nil || app.Namespace == nil || app.Project == nil {
			continue
		}

		// Apply cluster filtering
		if len(state.Selections.ScopeClusters) > 0 {
			if !model.HasInStringSet(state.Selections.ScopeClusters, *app.ClusterLabel) {
				continue
			}
		}

		// Apply namespace filtering
		if len(state.Selections.ScopeNamespaces) > 0 {
			if !model.HasInStringSet(state.Selections.ScopeNamespaces, *app.Namespace) {
				continue
			}
		}

		project := strings.ToLower(*app.Project)
		if strings.HasPrefix(project, prefix) && !seen[project] {
			suggestions = append(suggestions, *app.Project)
			seen[project] = true
		}
	}

	sort.Strings(suggestions)
	return suggestions
}

// getAppSuggestions returns app name suggestions (filtered by current selections)
func (e *AutocompleteEngine) getAppSuggestions(prefix string, state *model.AppState) []string {
	var suggestions []string

	for _, app := range state.Apps {
		// Apply all current filters
		if len(state.Selections.ScopeClusters) > 0 {
			if app.ClusterLabel == nil || !model.HasInStringSet(state.Selections.ScopeClusters, *app.ClusterLabel) {
				continue
			}
		}

		if len(state.Selections.ScopeNamespaces) > 0 {
			if app.Namespace == nil || !model.HasInStringSet(state.Selections.ScopeNamespaces, *app.Namespace) {
				continue
			}
		}

		if len(state.Selections.ScopeProjects) > 0 {
			if app.Project == nil || !model.HasInStringSet(state.Selections.ScopeProjects, *app.Project) {
				continue
			}
		}

		if strings.HasPrefix(strings.ToLower(app.Name), prefix) {
			suggestions = append(suggestions, app.Name)
		}
	}

	sort.Strings(suggestions)
	return suggestions
}

// GetAllCommands returns all available commands for help/reference
func (e *AutocompleteEngine) GetAllCommands() []CommandAlias {
	return e.commands
}
</file>

<file path="pkg/config/cli_config.go">
package config

import (
	"fmt"
	"os"
	"path/filepath"

	"gopkg.in/yaml.v3"
	"github.com/darksworm/argonaut/pkg/model"
)

// ArgoContext represents an ArgoCD context configuration
type ArgoContext struct {
	Name   string `yaml:"name"`
	Server string `yaml:"server"`
	User   string `yaml:"user"`
}

// ArgoServer represents an ArgoCD server configuration
type ArgoServer struct {
	Server           string `yaml:"server"`
	GrpcWeb          bool   `yaml:"grpc-web,omitempty"`
	GrpcWebRootPath  string `yaml:"grpc-web-root-path,omitempty"`
	Insecure         bool   `yaml:"insecure,omitempty"`
	PlainText        bool   `yaml:"plain-text,omitempty"`
}

// ArgoUser represents an ArgoCD user configuration
type ArgoUser struct {
	Name      string `yaml:"name"`
	AuthToken string `yaml:"auth-token,omitempty"`
}

// ArgoCLIConfig represents the complete ArgoCD CLI configuration
type ArgoCLIConfig struct {
	Contexts       []ArgoContext `yaml:"contexts,omitempty"`
	Servers        []ArgoServer  `yaml:"servers,omitempty"`
	Users          []ArgoUser    `yaml:"users,omitempty"`
	CurrentContext string        `yaml:"current-context,omitempty"`
	PromptsEnabled bool          `yaml:"prompts-enabled,omitempty"`
}

// GetConfigPath returns the path to the ArgoCD CLI configuration file
func GetConfigPath() string {
	if configPath := os.Getenv("ARGOCD_CONFIG"); configPath != "" {
		return configPath
	}
	
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return ""
	}
	
	// Check XDG_CONFIG_HOME first
	if xdgConfig := os.Getenv("XDG_CONFIG_HOME"); xdgConfig != "" {
		return filepath.Join(xdgConfig, "argocd", "config")
	}
	
	// Default to ~/.config/argocd/config
	return filepath.Join(homeDir, ".config", "argocd", "config")
}

// ReadCLIConfig reads and parses the ArgoCD CLI configuration
func ReadCLIConfig() (*ArgoCLIConfig, error) {
	configPath := GetConfigPath()
	
	data, err := os.ReadFile(configPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read ArgoCD config from %s: %w", configPath, err)
	}
	
	var config ArgoCLIConfig
	if err := yaml.Unmarshal(data, &config); err != nil {
		return nil, fmt.Errorf("failed to parse ArgoCD config: %w", err)
	}
	
	return &config, nil
}

// GetCurrentServer returns the server URL for the current context
func (c *ArgoCLIConfig) GetCurrentServer() (string, error) {
	if c.CurrentContext == "" {
		return "", fmt.Errorf("no current context set in ArgoCD config")
	}
	
	for _, ctx := range c.Contexts {
		if ctx.Name == c.CurrentContext {
			if ctx.Server == "" {
				return "", fmt.Errorf("no server specified for context %s", c.CurrentContext)
			}
			return ctx.Server, nil
		}
	}
	
	return "", fmt.Errorf("context %s not found in ArgoCD config", c.CurrentContext)
}

// GetCurrentServerConfig returns the server configuration for the current context
func (c *ArgoCLIConfig) GetCurrentServerConfig() (*ArgoServer, error) {
	serverURL, err := c.GetCurrentServer()
	if err != nil {
		return nil, err
	}
	
	for _, server := range c.Servers {
		if server.Server == serverURL {
			return &server, nil
		}
	}
	
	return nil, fmt.Errorf("server configuration not found for %s", serverURL)
}

// GetCurrentToken returns the auth token for the current context
func (c *ArgoCLIConfig) GetCurrentToken() (string, error) {
	if c.CurrentContext == "" {
		return "", fmt.Errorf("no current context set in ArgoCD config")
	}
	
	// Find the current context
	var currentUser string
	for _, ctx := range c.Contexts {
		if ctx.Name == c.CurrentContext {
			currentUser = ctx.User
			break
		}
	}
	
	if currentUser == "" {
		return "", fmt.Errorf("no user specified for context %s", c.CurrentContext)
	}
	
	// Find the user and their token
	for _, user := range c.Users {
		if user.Name == currentUser {
			if user.AuthToken == "" {
				return "", fmt.Errorf("no auth token found for user %s. Please run 'argocd login' to authenticate", currentUser)
			}
			return user.AuthToken, nil
		}
	}
	
	return "", fmt.Errorf("user %s not found in ArgoCD config", currentUser)
}

// ToServerConfig converts the ArgoCD CLI config to our internal Server model
func (c *ArgoCLIConfig) ToServerConfig() (*model.Server, error) {
	serverConfig, err := c.GetCurrentServerConfig()
	if err != nil {
		return nil, err
	}
	
	token, err := c.GetCurrentToken()
	if err != nil {
		return nil, err
	}
	
	baseURL := ensureHTTPS(serverConfig.Server, serverConfig.PlainText)
	
	return &model.Server{
		BaseURL:  baseURL,
		Token:    token,
		Insecure: serverConfig.Insecure,
	}, nil
}

// ensureHTTPS ensures the URL has the correct protocol
func ensureHTTPS(baseURL string, plainText bool) string {
	if len(baseURL) == 0 {
		return baseURL
	}
	
	// If already has protocol, return as-is
	if len(baseURL) >= 7 && (baseURL[:7] == "http://" || baseURL[:8] == "https://") {
		return baseURL
	}
	
	// Add appropriate protocol
	if plainText {
		return "http://" + baseURL
	}
	return "https://" + baseURL
}
</file>

<file path="pkg/errors/analytics.go">
package errors

import (
	"context"
	"encoding/json"
	"log"
	"sort"
	"sync"
	"time"
)

// ErrorAnalytics provides error monitoring and analysis capabilities
type ErrorAnalytics struct {
	mu           sync.RWMutex
	errorHistory []ErrorRecord
	patterns     map[string]*ErrorPattern
	metrics      ErrorMetrics
	maxHistory   int
}

// ErrorRecord represents a single error occurrence
type ErrorRecord struct {
	Timestamp   time.Time              `json:"timestamp"`
	Category    ErrorCategory          `json:"category"`
	Code        string                 `json:"code"`
	Message     string                 `json:"message"`
	Severity    ErrorSeverity          `json:"severity"`
	Recoverable bool                   `json:"recoverable"`
	Context     map[string]interface{} `json:"context,omitempty"`
	UserAction  string                 `json:"userAction,omitempty"`
	Resolved    bool                   `json:"resolved"`
	ResolvedAt  *time.Time             `json:"resolvedAt,omitempty"`
	Duration    *time.Duration         `json:"duration,omitempty"`
}

// ErrorPattern tracks recurring error patterns
type ErrorPattern struct {
	Category     ErrorCategory `json:"category"`
	Code         string        `json:"code"`
	Count        int           `json:"count"`
	FirstSeen    time.Time     `json:"firstSeen"`
	LastSeen     time.Time     `json:"lastSeen"`
	Frequency    float64       `json:"frequency"` // errors per hour
	AvgDuration  time.Duration `json:"avgDuration,omitempty"`
	Trend        string        `json:"trend"` // "increasing", "stable", "decreasing"
	Severity     ErrorSeverity `json:"severity"`
	RecoveryRate float64       `json:"recoveryRate"` // percentage of errors that resolved
}

// ErrorMetrics provides aggregate error statistics
type ErrorMetrics struct {
	TotalErrors      int                         `json:"totalErrors"`
	ErrorsByCategory map[ErrorCategory]int       `json:"errorsByCategory"`
	ErrorsBySeverity map[ErrorSeverity]int       `json:"errorsBySeverity"`
	RecoveryRate     float64                     `json:"recoveryRate"`
	AvgResolution    time.Duration               `json:"avgResolution"`
	TopPatterns      []*ErrorPattern             `json:"topPatterns"`
	TrendAnalysis    *ErrorTrend                 `json:"trendAnalysis"`
	LastUpdated      time.Time                   `json:"lastUpdated"`
	TimeWindow       time.Duration               `json:"timeWindow"`
}

// ErrorTrend analyzes error trends over time
type ErrorTrend struct {
	Direction        string        `json:"direction"` // "improving", "stable", "degrading"
	ChangeRate       float64       `json:"changeRate"` // percentage change
	PredictedErrors  int           `json:"predictedErrors"` // predicted errors in next hour
	Confidence       float64       `json:"confidence"` // prediction confidence (0-1)
	RecommendedActions []string    `json:"recommendedActions"`
}

// PredictiveAlert represents a predictive error alert
type PredictiveAlert struct {
	Pattern      string        `json:"pattern"`
	Probability  float64       `json:"probability"`
	ExpectedTime time.Time     `json:"expectedTime"`
	Severity     ErrorSeverity `json:"severity"`
	PreventionActions []string `json:"preventionActions"`
}

// NewErrorAnalytics creates a new error analytics system
func NewErrorAnalytics(maxHistory int) *ErrorAnalytics {
	if maxHistory <= 0 {
		maxHistory = 1000 // Default to 1000 records
	}

	return &ErrorAnalytics{
		errorHistory: make([]ErrorRecord, 0, maxHistory),
		patterns:     make(map[string]*ErrorPattern),
		metrics:      ErrorMetrics{
			ErrorsByCategory: make(map[ErrorCategory]int),
			ErrorsBySeverity: make(map[ErrorSeverity]int),
			TimeWindow:       24 * time.Hour,
		},
		// Logger removed to avoid import cycle
		maxHistory: maxHistory,
	}
}

// RecordError records an error for analysis
func (ea *ErrorAnalytics) RecordError(err *ArgonautError) {
	ea.mu.Lock()
	defer ea.mu.Unlock()

	record := ErrorRecord{
		Timestamp:   time.Now(),
		Category:    err.Category,
		Code:        err.Code,
		Message:     err.Message,
		Severity:    err.Severity,
		Recoverable: err.Recoverable,
		Context:     err.Context,
		UserAction:  err.UserAction,
		Resolved:    false,
	}

	// Add to history
	ea.errorHistory = append(ea.errorHistory, record)

	// Limit history size
	if len(ea.errorHistory) > ea.maxHistory {
		ea.errorHistory = ea.errorHistory[1:]
	}

	// Update patterns
	ea.updatePattern(&record)

	// Update metrics
	ea.updateMetrics()

	log.Printf("DEBUG: Recorded error for analytics: %s/%s", err.Category, err.Code)
}

// RecordResolution records when an error is resolved
func (ea *ErrorAnalytics) RecordResolution(category ErrorCategory, code string, duration time.Duration) {
	ea.mu.Lock()
	defer ea.mu.Unlock()

	// Find the most recent unresolved error matching this pattern
	for i := len(ea.errorHistory) - 1; i >= 0; i-- {
		record := &ea.errorHistory[i]
		if record.Category == category && record.Code == code && !record.Resolved {
			resolvedAt := time.Now()
			record.Resolved = true
			record.ResolvedAt = &resolvedAt
			record.Duration = &duration

			log.Printf("DEBUG: Recorded resolution for error: %s/%s (duration: %v)",
				category, code, duration)
			break
		}
	}

	// Update metrics
	ea.updateMetrics()
}

// updatePattern updates error patterns with new data
func (ea *ErrorAnalytics) updatePattern(record *ErrorRecord) {
	patternKey := string(record.Category) + "/" + record.Code

	pattern, exists := ea.patterns[patternKey]
	if !exists {
		pattern = &ErrorPattern{
			Category:  record.Category,
			Code:      record.Code,
			FirstSeen: record.Timestamp,
			Severity:  record.Severity,
		}
		ea.patterns[patternKey] = pattern
	}

	pattern.Count++
	pattern.LastSeen = record.Timestamp

	// Calculate frequency (errors per hour)
	duration := pattern.LastSeen.Sub(pattern.FirstSeen)
	if duration > 0 {
		pattern.Frequency = float64(pattern.Count) / duration.Hours()
	}

	// Update recovery rate
	resolved := 0
	total := 0
	var totalDuration time.Duration
	resolvedCount := 0

	for _, h := range ea.errorHistory {
		if h.Category == record.Category && h.Code == record.Code {
			total++
			if h.Resolved {
				resolved++
				if h.Duration != nil {
					totalDuration += *h.Duration
					resolvedCount++
				}
			}
		}
	}

	if total > 0 {
		pattern.RecoveryRate = float64(resolved) / float64(total)
	}

	if resolvedCount > 0 {
		pattern.AvgDuration = totalDuration / time.Duration(resolvedCount)
	}

	// Calculate trend
	pattern.Trend = ea.calculateTrend(patternKey)
}

// calculateTrend calculates the trend for an error pattern
func (ea *ErrorAnalytics) calculateTrend(patternKey string) string {
	// Simple trend calculation based on recent vs older occurrences
	now := time.Now()
	recent := 0
	older := 0

	for _, record := range ea.errorHistory {
		if string(record.Category)+"/"+record.Code == patternKey {
			age := now.Sub(record.Timestamp)
			if age <= time.Hour {
				recent++
			} else if age <= 6*time.Hour {
				older++
			}
		}
	}

	if recent > older*2 {
		return "increasing"
	} else if older > recent*2 {
		return "decreasing"
	}
	return "stable"
}

// updateMetrics updates aggregate error metrics
func (ea *ErrorAnalytics) updateMetrics() {
	now := time.Now()
	windowStart := now.Add(-ea.metrics.TimeWindow)

	// Reset counters
	ea.metrics.TotalErrors = 0
	ea.metrics.ErrorsByCategory = make(map[ErrorCategory]int)
	ea.metrics.ErrorsBySeverity = make(map[ErrorSeverity]int)

	totalResolved := 0
	var totalResolutionTime time.Duration
	resolvedWithTime := 0

	// Count errors within time window
	for _, record := range ea.errorHistory {
		if record.Timestamp.After(windowStart) {
			ea.metrics.TotalErrors++
			ea.metrics.ErrorsByCategory[record.Category]++
			ea.metrics.ErrorsBySeverity[record.Severity]++

			if record.Resolved {
				totalResolved++
				if record.Duration != nil {
					totalResolutionTime += *record.Duration
					resolvedWithTime++
				}
			}
		}
	}

	// Calculate recovery rate
	if ea.metrics.TotalErrors > 0 {
		ea.metrics.RecoveryRate = float64(totalResolved) / float64(ea.metrics.TotalErrors)
	}

	// Calculate average resolution time
	if resolvedWithTime > 0 {
		ea.metrics.AvgResolution = totalResolutionTime / time.Duration(resolvedWithTime)
	}

	// Update top patterns
	ea.updateTopPatterns()

	// Update trend analysis
	ea.updateTrendAnalysis()

	ea.metrics.LastUpdated = now
}

// updateTopPatterns updates the list of top error patterns
func (ea *ErrorAnalytics) updateTopPatterns() {
	patterns := make([]*ErrorPattern, 0, len(ea.patterns))
	for _, pattern := range ea.patterns {
		patterns = append(patterns, pattern)
	}

	// Sort by frequency (descending)
	sort.Slice(patterns, func(i, j int) bool {
		return patterns[i].Frequency > patterns[j].Frequency
	})

	// Take top 10
	if len(patterns) > 10 {
		patterns = patterns[:10]
	}

	ea.metrics.TopPatterns = patterns
}

// updateTrendAnalysis updates the trend analysis
func (ea *ErrorAnalytics) updateTrendAnalysis() {
	now := time.Now()
	hour1 := now.Add(-time.Hour)
	hour2 := now.Add(-2 * time.Hour)

	recentCount := 0
	previousCount := 0

	for _, record := range ea.errorHistory {
		if record.Timestamp.After(hour1) {
			recentCount++
		} else if record.Timestamp.After(hour2) {
			previousCount++
		}
	}

	trend := &ErrorTrend{
		Direction: "stable",
		ChangeRate: 0,
		PredictedErrors: recentCount,
		Confidence: 0.5,
		RecommendedActions: []string{},
	}

	if previousCount > 0 {
		trend.ChangeRate = float64(recentCount-previousCount) / float64(previousCount) * 100

		if trend.ChangeRate > 20 {
			trend.Direction = "degrading"
			trend.Confidence = 0.7
			trend.RecommendedActions = append(trend.RecommendedActions,
				"Investigate recent changes", "Review error patterns", "Consider increasing monitoring")
		} else if trend.ChangeRate < -20 {
			trend.Direction = "improving"
			trend.Confidence = 0.7
			trend.RecommendedActions = append(trend.RecommendedActions,
				"Continue current practices", "Document improvements")
		}
	}

	ea.metrics.TrendAnalysis = trend
}

// GetMetrics returns current error metrics
func (ea *ErrorAnalytics) GetMetrics() ErrorMetrics {
	ea.mu.RLock()
	defer ea.mu.RUnlock()
	return ea.metrics
}

// GetTopPatterns returns the most frequent error patterns
func (ea *ErrorAnalytics) GetTopPatterns(limit int) []*ErrorPattern {
	ea.mu.RLock()
	defer ea.mu.RUnlock()

	patterns := ea.metrics.TopPatterns
	if limit > 0 && len(patterns) > limit {
		patterns = patterns[:limit]
	}

	return patterns
}

// GeneratePredictiveAlerts generates alerts for likely future errors
func (ea *ErrorAnalytics) GeneratePredictiveAlerts() []PredictiveAlert {
	ea.mu.RLock()
	defer ea.mu.RUnlock()

	alerts := []PredictiveAlert{}

	for _, pattern := range ea.patterns {
		if pattern.Trend == "increasing" && pattern.Frequency > 1.0 { // More than 1 error per hour
			probability := pattern.Frequency / 10.0 // Simple probability calculation
			if probability > 1.0 {
				probability = 1.0
			}

			if probability > 0.3 { // 30% threshold
				alert := PredictiveAlert{
					Pattern:     string(pattern.Category) + "/" + pattern.Code,
					Probability: probability,
					ExpectedTime: time.Now().Add(time.Duration(60/pattern.Frequency) * time.Minute),
					Severity:    pattern.Severity,
					PreventionActions: ea.generatePreventionActions(pattern),
				}
				alerts = append(alerts, alert)
			}
		}
	}

	return alerts
}

// generatePreventionActions generates prevention actions for an error pattern
func (ea *ErrorAnalytics) generatePreventionActions(pattern *ErrorPattern) []string {
	actions := []string{}

	switch pattern.Category {
	case ErrorNetwork:
		actions = append(actions, "Check network connectivity", "Verify server endpoints")
	case ErrorAuth:
		actions = append(actions, "Refresh authentication tokens", "Verify credentials")
	case ErrorAPI:
		actions = append(actions, "Check API server health", "Verify API endpoints")
	case ErrorTimeout:
		actions = append(actions, "Increase timeout values", "Optimize queries")
	default:
		actions = append(actions, "Review recent changes", "Check system resources")
	}

	if pattern.RecoveryRate < 0.5 {
		actions = append(actions, "Improve error handling", "Add more recovery mechanisms")
	}

	return actions
}

// GenerateReport generates a comprehensive error analysis report
func (ea *ErrorAnalytics) GenerateReport() map[string]interface{} {
	ea.mu.RLock()
	defer ea.mu.RUnlock()

	return map[string]interface{}{
		"summary": map[string]interface{}{
			"totalErrors":    ea.metrics.TotalErrors,
			"recoveryRate":   ea.metrics.RecoveryRate,
			"avgResolution":  ea.metrics.AvgResolution.String(),
			"timeWindow":     ea.metrics.TimeWindow.String(),
			"lastUpdated":    ea.metrics.LastUpdated,
		},
		"categoryBreakdown": ea.metrics.ErrorsByCategory,
		"severityBreakdown": ea.metrics.ErrorsBySeverity,
		"topPatterns":       ea.metrics.TopPatterns,
		"trendAnalysis":     ea.metrics.TrendAnalysis,
		"predictiveAlerts":  ea.GeneratePredictiveAlerts(),
		"recommendations":   ea.generateRecommendations(),
	}
}

// generateRecommendations generates system-wide recommendations
func (ea *ErrorAnalytics) generateRecommendations() []string {
	recommendations := []string{}

	if ea.metrics.RecoveryRate < 0.5 {
		recommendations = append(recommendations,
			"Low recovery rate detected - improve error handling and retry mechanisms")
	}

	if ea.metrics.TrendAnalysis != nil && ea.metrics.TrendAnalysis.Direction == "degrading" {
		recommendations = append(recommendations,
			"Error rate is increasing - investigate recent changes and system health")
	}

	networkErrors := ea.metrics.ErrorsByCategory[ErrorNetwork]
	if networkErrors > ea.metrics.TotalErrors/3 {
		recommendations = append(recommendations,
			"High network error rate - check connectivity and server health")
	}

	authErrors := ea.metrics.ErrorsByCategory[ErrorAuth]
	if authErrors > 0 {
		recommendations = append(recommendations,
			"Authentication errors detected - verify credentials and token refresh")
	}

	return recommendations
}

// ExportMetrics exports metrics in JSON format
func (ea *ErrorAnalytics) ExportMetrics() ([]byte, error) {
	report := ea.GenerateReport()
	return json.MarshalIndent(report, "", "  ")
}

// Cleanup removes old error records beyond the time window
func (ea *ErrorAnalytics) Cleanup(ctx context.Context) {
	ea.mu.Lock()
	defer ea.mu.Unlock()

	cutoff := time.Now().Add(-ea.metrics.TimeWindow * 2) // Keep 2x the time window
	newHistory := make([]ErrorRecord, 0, len(ea.errorHistory))

	for _, record := range ea.errorHistory {
		if record.Timestamp.After(cutoff) {
			newHistory = append(newHistory, record)
		}
	}

	removed := len(ea.errorHistory) - len(newHistory)
	ea.errorHistory = newHistory

	if removed > 0 {
		log.Printf("DEBUG: Cleaned up %d old error records", removed)
	}
}
</file>

<file path="pkg/errors/handler.go">
package errors

import (
	"context"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sync"
	"time"
)

// ErrorHandler interface defines methods for handling errors consistently
type ErrorHandler interface {
	Handle(err *ArgonautError) *ErrorResponse
	Log(err *ArgonautError)
	Notify(err *ArgonautError) // Send to UI/notification system
	ShouldRetry(err *ArgonautError) bool
	GetRetryDelay(err *ArgonautError) time.Duration
}

// ErrorResponse represents how the application should respond to an error
type ErrorResponse struct {
	ShouldExit     bool           `json:"shouldExit"`
	DisplayMessage string         `json:"displayMessage"`
	Mode          string         `json:"mode"` // error, connection-error, auth-required
	RetryAfter    *time.Duration `json:"retryAfter,omitempty"`
	UserActions   []UserAction   `json:"userActions,omitempty"`
}

// UserAction represents an action the user can take to resolve an error
type UserAction struct {
	Label       string `json:"label"`
	Description string `json:"description"`
	Command     string `json:"command,omitempty"`
}

// ErrorHandlerImpl provides a concrete implementation of ErrorHandler
type ErrorHandlerImpl struct {
	logger        *log.Logger
	logFile       *os.File
	errorHistory  []ArgonautError
	historyMu     sync.RWMutex
	maxHistory    int
	notifyFunc    func(*ArgonautError) // Callback for UI notifications
}

// ErrorHandlerConfig configures the error handler
type ErrorHandlerConfig struct {
	LogFilePath    string
	MaxHistory     int
	NotifyCallback func(*ArgonautError)
}

// NewErrorHandler creates a new error handler with the given configuration
func NewErrorHandler(config ErrorHandlerConfig) (*ErrorHandlerImpl, error) {
	handler := &ErrorHandlerImpl{
		maxHistory: config.MaxHistory,
		notifyFunc: config.NotifyCallback,
	}

	if handler.maxHistory <= 0 {
		handler.maxHistory = 100 // Default history size
	}

	// Set up logging
	if config.LogFilePath != "" {
		// Ensure log directory exists
		logDir := filepath.Dir(config.LogFilePath)
		if err := os.MkdirAll(logDir, 0755); err != nil {
			return nil, fmt.Errorf("failed to create log directory: %w", err)
		}

		// Open log file
		logFile, err := os.OpenFile(config.LogFilePath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
		if err != nil {
			return nil, fmt.Errorf("failed to open log file: %w", err)
		}

		handler.logFile = logFile
		handler.logger = log.New(logFile, "", log.LstdFlags|log.Lshortfile)
	} else {
		handler.logger = log.Default()
	}

	return handler, nil
}

// Close closes the error handler and any associated resources
func (h *ErrorHandlerImpl) Close() error {
	if h.logFile != nil {
		return h.logFile.Close()
	}
	return nil
}

// Handle processes an error and returns the appropriate response
func (h *ErrorHandlerImpl) Handle(err *ArgonautError) *ErrorResponse {
	if err == nil {
		return nil
	}

	// Log the error
	h.Log(err)

	// Add to history
	h.addToHistory(*err)

	// Notify UI if callback is set
	h.Notify(err)

	// Determine response based on error category and severity
	response := h.determineResponse(err)

	return response
}

// Log logs the error with structured information
func (h *ErrorHandlerImpl) Log(err *ArgonautError) {
	if err == nil {
		return
	}

	// Create structured log entry
	logEntry := fmt.Sprintf("[%s] [%s:%s] %s",
		err.Severity, err.Category, err.Code, err.Message)

	if err.Details != "" {
		logEntry += fmt.Sprintf(" | Details: %s", err.Details)
	}

	if err.Cause != nil {
		logEntry += fmt.Sprintf(" | Cause: %v", err.Cause)
	}

	if len(err.Context) > 0 {
		logEntry += fmt.Sprintf(" | Context: %+v", err.Context)
	}

	// Log based on severity
	switch err.Severity {
	case SeverityCritical:
		h.logger.Printf("CRITICAL: %s", logEntry)
	case SeverityHigh:
		h.logger.Printf("ERROR: %s", logEntry)
	case SeverityMedium:
		h.logger.Printf("WARN: %s", logEntry)
	case SeverityLow:
		h.logger.Printf("INFO: %s", logEntry)
	default:
		h.logger.Printf("UNKNOWN: %s", logEntry)
	}
}

// Notify sends the error to the UI notification system
func (h *ErrorHandlerImpl) Notify(err *ArgonautError) {
	if err == nil || h.notifyFunc == nil {
		return
	}

	h.notifyFunc(err)
}

// ShouldRetry determines if an error should be retried
func (h *ErrorHandlerImpl) ShouldRetry(err *ArgonautError) bool {
	if err == nil || !err.Recoverable {
		return false
	}

	// Retry logic based on error category
	switch err.Category {
	case ErrorNetwork, ErrorTimeout:
		return true
	case ErrorAPI:
		// Only retry on specific API error codes
		return err.Code == "CONNECTION_REFUSED" || err.Code == "TIMEOUT" || err.Code == "SERVICE_UNAVAILABLE"
	case ErrorAuth:
		return false // Don't auto-retry auth errors
	case ErrorValidation:
		return false // Don't retry validation errors
	default:
		return false
	}
}

// GetRetryDelay returns the appropriate delay before retrying an operation
func (h *ErrorHandlerImpl) GetRetryDelay(err *ArgonautError) time.Duration {
	if err == nil {
		return 0
	}

	// Base delay based on error category
	baseDelay := 1 * time.Second

	switch err.Category {
	case ErrorNetwork:
		baseDelay = 2 * time.Second
	case ErrorTimeout:
		baseDelay = 3 * time.Second
	case ErrorAPI:
		baseDelay = 1 * time.Second
	}

	// TODO: Implement exponential backoff based on retry count
	// This would require tracking retry attempts per error

	return baseDelay
}

// GetErrorHistory returns a copy of the recent error history
func (h *ErrorHandlerImpl) GetErrorHistory() []ArgonautError {
	h.historyMu.RLock()
	defer h.historyMu.RUnlock()

	history := make([]ArgonautError, len(h.errorHistory))
	copy(history, h.errorHistory)
	return history
}

// ClearErrorHistory clears the error history
func (h *ErrorHandlerImpl) ClearErrorHistory() {
	h.historyMu.Lock()
	defer h.historyMu.Unlock()

	h.errorHistory = nil
}

// addToHistory adds an error to the internal history, maintaining the max size
func (h *ErrorHandlerImpl) addToHistory(err ArgonautError) {
	h.historyMu.Lock()
	defer h.historyMu.Unlock()

	h.errorHistory = append(h.errorHistory, err)

	// Maintain max history size
	if len(h.errorHistory) > h.maxHistory {
		h.errorHistory = h.errorHistory[1:]
	}
}

// determineResponse determines the appropriate response for an error
func (h *ErrorHandlerImpl) determineResponse(err *ArgonautError) *ErrorResponse {
	response := &ErrorResponse{
		DisplayMessage: err.Message,
		ShouldExit:     false,
	}

	// Set mode based on error category
	switch err.Category {
	case ErrorAuth:
		response.Mode = "auth-required"
		response.UserActions = []UserAction{
			{
				Label:       "Login",
				Description: "Authenticate with ArgoCD server",
				Command:     "argocd login",
			},
		}
	case ErrorNetwork:
		response.Mode = "connection-error"
		if h.ShouldRetry(err) {
			retryDelay := h.GetRetryDelay(err)
			response.RetryAfter = &retryDelay
		}
		response.UserActions = []UserAction{
			{
				Label:       "Retry",
				Description: "Try the operation again",
			},
			{
				Label:       "Check Connection",
				Description: "Verify network connectivity to ArgoCD server",
			},
		}
	case ErrorConfig:
		response.Mode = "error"
		response.UserActions = []UserAction{
			{
				Label:       "Check Config",
				Description: "Verify ArgoCD configuration",
				Command:     "argocd config",
			},
		}
	default:
		response.Mode = "error"
		if err.UserAction != "" {
			response.UserActions = []UserAction{
				{
					Label:       "Suggested Action",
					Description: err.UserAction,
				},
			}
		}
	}

	// Set exit condition for critical errors
	if err.Severity == SeverityCritical {
		response.ShouldExit = true
	}

	return response
}

// Default error handler instance
var defaultHandler *ErrorHandlerImpl
var defaultHandlerOnce sync.Once

// GetDefaultHandler returns the default error handler instance
func GetDefaultHandler() *ErrorHandlerImpl {
	defaultHandlerOnce.Do(func() {
		config := ErrorHandlerConfig{
			LogFilePath: "logs/errors.log",
			MaxHistory:  100,
		}

		handler, err := NewErrorHandler(config)
		if err != nil {
			// Fallback to basic handler
			handler = &ErrorHandlerImpl{
				logger:     log.Default(),
				maxHistory: 100,
			}
		}

		defaultHandler = handler
	})

	return defaultHandler
}

// Convenience functions for common error handling patterns

// HandleWithContext handles an error with additional context
func HandleWithContext(ctx context.Context, err *ArgonautError, contextData map[string]interface{}) *ErrorResponse {
	if err != nil && contextData != nil {
		for k, v := range contextData {
			err.WithContext(k, v)
		}
	}

	return GetDefaultHandler().Handle(err)
}

// LogAndHandle logs an error and returns the response
func LogAndHandle(err *ArgonautError) *ErrorResponse {
	return GetDefaultHandler().Handle(err)
}

// ConvertError converts a standard error to an ArgonautError
func ConvertError(err error, category ErrorCategory, code string) *ArgonautError {
	if err == nil {
		return nil
	}

	// Check if it's already an ArgonautError
	if argErr, ok := err.(*ArgonautError); ok {
		return argErr
	}

	return Wrap(err, category, code, err.Error())
}
</file>

<file path="pkg/logging/logger.go">
package logging

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	apperrors "github.com/darksworm/argonaut/pkg/errors"
)

// LogLevel represents different log levels
type LogLevel string

const (
	LevelDebug LogLevel = "DEBUG"
	LevelInfo  LogLevel = "INFO"
	LevelWarn  LogLevel = "WARN"
	LevelError LogLevel = "ERROR"
	LevelFatal LogLevel = "FATAL"
)

// LogEntry represents a structured log entry
type LogEntry struct {
	Timestamp   time.Time              `json:"timestamp"`
	Level       LogLevel               `json:"level"`
	Message     string                 `json:"message"`
	Component   string                 `json:"component,omitempty"`
	Operation   string                 `json:"operation,omitempty"`
	Context     map[string]interface{} `json:"context,omitempty"`
	Error       string                 `json:"error,omitempty"`
	ErrorCode   string                 `json:"errorCode,omitempty"`
	ErrorCategory string               `json:"errorCategory,omitempty"`
	Duration    *time.Duration         `json:"duration,omitempty"`
	RequestID   string                 `json:"requestId,omitempty"`
}

// Logger interface defines logging operations
type Logger interface {
	Debug(msg string, args ...interface{})
	Info(msg string, args ...interface{})
	Warn(msg string, args ...interface{})
	Error(msg string, args ...interface{})
	Fatal(msg string, args ...interface{})

	// Structured logging methods
	LogError(err *apperrors.ArgonautError)
	LogOperation(operation string, duration time.Duration, err error)
	LogRequest(method, path string, statusCode int, duration time.Duration)

	// Context-aware logging
	WithContext(ctx context.Context) Logger
	WithComponent(component string) Logger
	WithOperation(operation string) Logger

	// Configuration
	SetLevel(level LogLevel)
	Close() error
}

// StructuredLogger provides a concrete implementation of Logger
type StructuredLogger struct {
	level        LogLevel
	component    string
	operation    string
	context      map[string]interface{}
	output       *os.File
	encoder      *json.Encoder
	stdLogger    *log.Logger
	mu           sync.RWMutex
	useJSON      bool
}

// LoggerConfig configures the structured logger
type LoggerConfig struct {
	Level      LogLevel
	OutputPath string
	UseJSON    bool
	Component  string
}

// NewStructuredLogger creates a new structured logger
func NewStructuredLogger(config LoggerConfig) (*StructuredLogger, error) {
	logger := &StructuredLogger{
		level:     config.Level,
		component: config.Component,
		context:   make(map[string]interface{}),
		useJSON:   config.UseJSON,
	}

	// Set up output
	if config.OutputPath != "" {
		// Ensure log directory exists
		logDir := filepath.Dir(config.OutputPath)
		if err := os.MkdirAll(logDir, 0755); err != nil {
			return nil, fmt.Errorf("failed to create log directory: %w", err)
		}

		// Open log file
		file, err := os.OpenFile(config.OutputPath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
		if err != nil {
			return nil, fmt.Errorf("failed to open log file: %w", err)
		}

		logger.output = file
		if config.UseJSON {
			logger.encoder = json.NewEncoder(file)
		} else {
			logger.stdLogger = log.New(file, "", 0) // No default formatting
		}
	} else {
		logger.output = os.Stderr
		if config.UseJSON {
			logger.encoder = json.NewEncoder(os.Stderr)
		} else {
			logger.stdLogger = log.New(os.Stderr, "", 0)
		}
	}

	return logger, nil
}

// Close closes the logger and any associated resources
func (l *StructuredLogger) Close() error {
	l.mu.Lock()
	defer l.mu.Unlock()

	if l.output != nil && l.output != os.Stderr && l.output != os.Stdout {
		return l.output.Close()
	}
	return nil
}

// SetLevel sets the logging level
func (l *StructuredLogger) SetLevel(level LogLevel) {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.level = level
}

// shouldLog checks if a message should be logged based on level
func (l *StructuredLogger) shouldLog(level LogLevel) bool {
	l.mu.RLock()
	defer l.mu.RUnlock()

	levelPriority := map[LogLevel]int{
		LevelDebug: 0,
		LevelInfo:  1,
		LevelWarn:  2,
		LevelError: 3,
		LevelFatal: 4,
	}

	currentPriority := levelPriority[l.level]
	msgPriority := levelPriority[level]

	return msgPriority >= currentPriority
}

// createEntry creates a new log entry
func (l *StructuredLogger) createEntry(level LogLevel, msg string) *LogEntry {
	l.mu.RLock()
	defer l.mu.RUnlock()

	entry := &LogEntry{
		Timestamp: time.Now(),
		Level:     level,
		Message:   msg,
		Component: l.component,
		Operation: l.operation,
	}

	// Copy context to avoid race conditions
	if len(l.context) > 0 {
		entry.Context = make(map[string]interface{})
		for k, v := range l.context {
			entry.Context[k] = v
		}
	}

	return entry
}

// writeEntry writes a log entry to the output
func (l *StructuredLogger) writeEntry(entry *LogEntry) {
	l.mu.Lock()
	defer l.mu.Unlock()

	if l.useJSON {
		l.encoder.Encode(entry)
	} else {
		// Human-readable format
		timestamp := entry.Timestamp.Format("2006-01-02 15:04:05")

		// Build context string
		var contextStr string
		if entry.Context != nil {
			var parts []string
			for k, v := range entry.Context {
				parts = append(parts, fmt.Sprintf("%s=%v", k, v))
			}
			if len(parts) > 0 {
				contextStr = fmt.Sprintf(" [%s]", strings.Join(parts, " "))
			}
		}

		// Build component/operation prefix
		var prefix string
		if entry.Component != "" {
			prefix = fmt.Sprintf("[%s", entry.Component)
			if entry.Operation != "" {
				prefix += fmt.Sprintf(":%s", entry.Operation)
			}
			prefix += "] "
		}

		logMsg := fmt.Sprintf("%s %s %s%s%s",
			timestamp, entry.Level, prefix, entry.Message, contextStr)

		if entry.Error != "" {
			logMsg += fmt.Sprintf(" | Error: %s", entry.Error)
		}

		l.stdLogger.Println(logMsg)
	}
}

// Debug logs a debug message
func (l *StructuredLogger) Debug(msg string, args ...interface{}) {
	if !l.shouldLog(LevelDebug) {
		return
	}

	entry := l.createEntry(LevelDebug, fmt.Sprintf(msg, args...))
	l.writeEntry(entry)
}

// Info logs an info message
func (l *StructuredLogger) Info(msg string, args ...interface{}) {
	if !l.shouldLog(LevelInfo) {
		return
	}

	entry := l.createEntry(LevelInfo, fmt.Sprintf(msg, args...))
	l.writeEntry(entry)
}

// Warn logs a warning message
func (l *StructuredLogger) Warn(msg string, args ...interface{}) {
	if !l.shouldLog(LevelWarn) {
		return
	}

	entry := l.createEntry(LevelWarn, fmt.Sprintf(msg, args...))
	l.writeEntry(entry)
}

// Error logs an error message
func (l *StructuredLogger) Error(msg string, args ...interface{}) {
	if !l.shouldLog(LevelError) {
		return
	}

	entry := l.createEntry(LevelError, fmt.Sprintf(msg, args...))
	l.writeEntry(entry)
}

// Fatal logs a fatal message and exits
func (l *StructuredLogger) Fatal(msg string, args ...interface{}) {
	entry := l.createEntry(LevelFatal, fmt.Sprintf(msg, args...))
	l.writeEntry(entry)
	os.Exit(1)
}

// LogError logs a structured error
func (l *StructuredLogger) LogError(err *apperrors.ArgonautError) {
	if !l.shouldLog(LevelError) || err == nil {
		return
	}

	entry := l.createEntry(LevelError, err.Message)
	entry.Error = err.Error()
	entry.ErrorCode = err.Code
	entry.ErrorCategory = string(err.Category)

	// Add error context
	if entry.Context == nil {
		entry.Context = make(map[string]interface{})
	}
	for k, v := range err.Context {
		entry.Context[k] = v
	}

	l.writeEntry(entry)
}

// LogOperation logs an operation with duration and optional error
func (l *StructuredLogger) LogOperation(operation string, duration time.Duration, err error) {
	level := LevelInfo
	if err != nil {
		level = LevelError
	}

	if !l.shouldLog(level) {
		return
	}

	msg := fmt.Sprintf("Operation %s completed", operation)
	if err != nil {
		msg = fmt.Sprintf("Operation %s failed", operation)
	}

	entry := l.createEntry(level, msg)
	entry.Operation = operation
	entry.Duration = &duration

	if err != nil {
		entry.Error = err.Error()

		// Add structured error information if available
		if argErr, ok := err.(*apperrors.ArgonautError); ok {
			entry.ErrorCode = argErr.Code
			entry.ErrorCategory = string(argErr.Category)
		}
	}

	l.writeEntry(entry)
}

// LogRequest logs HTTP request information
func (l *StructuredLogger) LogRequest(method, path string, statusCode int, duration time.Duration) {
	level := LevelInfo
	if statusCode >= 400 {
		level = LevelWarn
	}
	if statusCode >= 500 {
		level = LevelError
	}

	if !l.shouldLog(level) {
		return
	}

	msg := fmt.Sprintf("%s %s - %d", method, path, statusCode)

	entry := l.createEntry(level, msg)
	entry.Duration = &duration

	if entry.Context == nil {
		entry.Context = make(map[string]interface{})
	}
	entry.Context["httpMethod"] = method
	entry.Context["httpPath"] = path
	entry.Context["httpStatus"] = statusCode

	l.writeEntry(entry)
}

// WithContext returns a logger with additional context
func (l *StructuredLogger) WithContext(ctx context.Context) Logger {
	newLogger := l.clone()

	// Extract context values if available
	if requestID, ok := ctx.Value("requestId").(string); ok {
		if newLogger.context == nil {
			newLogger.context = make(map[string]interface{})
		}
		newLogger.context["requestId"] = requestID
	}

	return newLogger
}

// WithComponent returns a logger with a component name
func (l *StructuredLogger) WithComponent(component string) Logger {
	newLogger := l.clone()
	newLogger.component = component
	return newLogger
}

// WithOperation returns a logger with an operation name
func (l *StructuredLogger) WithOperation(operation string) Logger {
	newLogger := l.clone()
	newLogger.operation = operation
	return newLogger
}

// clone creates a copy of the logger for context-specific logging
func (l *StructuredLogger) clone() *StructuredLogger {
	l.mu.RLock()
	defer l.mu.RUnlock()

	newLogger := &StructuredLogger{
		level:     l.level,
		component: l.component,
		operation: l.operation,
		output:    l.output,
		encoder:   l.encoder,
		stdLogger: l.stdLogger,
		useJSON:   l.useJSON,
		context:   make(map[string]interface{}),
	}

	// Copy context
	for k, v := range l.context {
		newLogger.context[k] = v
	}

	return newLogger
}

// Default logger instance
var defaultLogger *StructuredLogger
var defaultLoggerOnce sync.Once

// GetDefaultLogger returns the default logger instance
func GetDefaultLogger() Logger {
	defaultLoggerOnce.Do(func() {
		config := LoggerConfig{
			Level:      LevelInfo,
			OutputPath: "logs/app.log",
			UseJSON:    false, // Human-readable by default
			Component:  "argonaut",
		}

		logger, err := NewStructuredLogger(config)
		if err != nil {
			// Fallback to stderr logger
			logger = &StructuredLogger{
				level:     LevelInfo,
				component: "argonaut",
				context:   make(map[string]interface{}),
				output:    os.Stderr,
				stdLogger: log.New(os.Stderr, "", 0),
				useJSON:   false,
			}
		}

		defaultLogger = logger
	})

	return defaultLogger
}

// Package-level convenience functions

// Debug logs a debug message using the default logger
func Debug(msg string, args ...interface{}) {
	GetDefaultLogger().Debug(msg, args...)
}

// Info logs an info message using the default logger
func Info(msg string, args ...interface{}) {
	GetDefaultLogger().Info(msg, args...)
}

// Warn logs a warning message using the default logger
func Warn(msg string, args ...interface{}) {
	GetDefaultLogger().Warn(msg, args...)
}

// Error logs an error message using the default logger
func Error(msg string, args ...interface{}) {
	GetDefaultLogger().Error(msg, args...)
}

// Fatal logs a fatal message using the default logger
func Fatal(msg string, args ...interface{}) {
	GetDefaultLogger().Fatal(msg, args...)
}

// LogError logs a structured error using the default logger
func LogError(err *apperrors.ArgonautError) {
	GetDefaultLogger().LogError(err)
}

// LogOperation logs an operation using the default logger
func LogOperation(operation string, duration time.Duration, err error) {
	GetDefaultLogger().LogOperation(operation, duration, err)
}

// LogRequest logs a request using the default logger
func LogRequest(method, path string, statusCode int, duration time.Duration) {
	GetDefaultLogger().LogRequest(method, path, statusCode, duration)
}
</file>

<file path="pkg/neat/neat_test.go">
package neat

import (
	"encoding/json"
	"strings"
	"testing"
)

func TestCleanServiceWithClusterDefaults(t *testing.T) {
	// Test service with the exact garbage fields you mentioned
	serviceYAML := `apiVersion: v1
kind: Service
metadata:
  name: test-service
  namespace: test-namespace
spec:
  clusterIP: 10.43.211.195
  clusterIPs:
  - 10.43.211.195
  internalTrafficPolicy: Cluster
  ipFamilies:
  - IPv4
  ipFamilyPolicy: SingleStack
  ports:
  - port: 80
    protocol: TCP
    targetPort: 8080
  selector:
    app: test-app
  sessionAffinity: None
  type: ClusterIP`

	cleaned, err := Clean(serviceYAML)
	if err != nil {
		t.Fatalf("Clean failed: %v", err)
	}

	// Verify that all the garbage fields are removed
	garbageFields := []string{
		"clusterIP: 10.43.211.195",
		"clusterIPs:",
		"- 10.43.211.195",
		"internalTrafficPolicy: Cluster",
		"ipFamilies:",
		"- IPv4",
		"ipFamilyPolicy: SingleStack",
		"protocol: TCP",
		"sessionAffinity: None",
		"type: ClusterIP",
	}

	for _, garbage := range garbageFields {
		if strings.Contains(cleaned, garbage) {
			t.Errorf("Garbage field should be removed: %s", garbage)
		}
	}

	// Verify that important data is kept
	importantFields := []string{
		"name: test-service",
		"namespace: test-namespace",
		"port: 80",
		"targetPort: 8080",
		"app: test-app",
	}

	for _, important := range importantFields {
		if !strings.Contains(cleaned, important) {
			t.Errorf("Important field should be kept: %s", important)
		}
	}

	t.Logf("Cleaned service:\n%s", cleaned)
}

func TestCleanDeployment(t *testing.T) {
	// Sample deployment with lots of noise that kubectl-neat should remove
	deploymentYAML := `apiVersion: apps/v1
kind: Deployment
metadata:
  name: test-deployment
  namespace: test-namespace
  creationTimestamp: "2023-01-01T00:00:00Z"
  resourceVersion: "12345"
  uid: "abcd-1234-efgh-5678"
  generation: 1
  managedFields:
  - manager: kubectl
    operation: Apply
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"apps/v1","kind":"Deployment","metadata":{"name":"test-deployment"}}
    deployment.kubernetes.io/revision: "1"
    my-custom-annotation: "keep-this"
spec:
  replicas: 3
  progressDeadlineSeconds: 600
  revisionHistoryLimit: 10
  strategy:
    type: RollingUpdate
  selector:
    matchLabels:
      app: test-app
  template:
    metadata:
      labels:
        app: test-app
        pod-template-hash: "12345"
    spec:
      restartPolicy: Always
      dnsPolicy: ClusterFirst
      terminationGracePeriodSeconds: 30
      containers:
      - name: test-container
        image: nginx:latest
        imagePullPolicy: IfNotPresent
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: File
        ports:
        - containerPort: 80
status:
  replicas: 3
  readyReplicas: 3`

	cleaned, err := Clean(deploymentYAML)
	if err != nil {
		t.Fatalf("Clean failed: %v", err)
	}

	// Verify that noise was removed (metadata is handled differently by neatMetadata)
	if strings.Contains(cleaned, "status:") {
		t.Error("status should be removed")
	}
	if strings.Contains(cleaned, "progressDeadlineSeconds: 600") {
		t.Error("default progressDeadlineSeconds should be removed")
	}
	if strings.Contains(cleaned, "revisionHistoryLimit: 10") {
		t.Error("default revisionHistoryLimit should be removed")
	}
	if strings.Contains(cleaned, "type: RollingUpdate") {
		t.Error("default strategy type should be removed")
	}
	if strings.Contains(cleaned, "restartPolicy: Always") {
		t.Error("default restartPolicy should be removed")
	}
	if strings.Contains(cleaned, "dnsPolicy: ClusterFirst") {
		t.Error("default dnsPolicy should be removed")
	}
	if strings.Contains(cleaned, "terminationGracePeriodSeconds: 30") {
		t.Error("default terminationGracePeriodSeconds should be removed")
	}
	if strings.Contains(cleaned, "imagePullPolicy: IfNotPresent") {
		t.Error("default imagePullPolicy should be removed")
	}
	if strings.Contains(cleaned, "terminationMessagePath") {
		t.Error("default terminationMessagePath should be removed")
	}
	if strings.Contains(cleaned, "terminationMessagePolicy") {
		t.Error("default terminationMessagePolicy should be removed")
	}

	// Note: kubectl-neat's neatMetadata function handles metadata differently than our original test expected
	// It only keeps name, namespace, labels, and annotations, removing all the clutter fields

	// Verify that important data is kept
	if !strings.Contains(cleaned, "name: test-deployment") {
		t.Error("deployment name should be kept")
	}
	if !strings.Contains(cleaned, "namespace: test-namespace") {
		t.Error("namespace should be kept")
	}
	if !strings.Contains(cleaned, "replicas: 3") {
		t.Error("replicas should be kept")
	}
	if !strings.Contains(cleaned, "my-custom-annotation: keep-this") {
		t.Error("custom annotations should be kept")
	}
	if !strings.Contains(cleaned, "image: nginx:latest") {
		t.Error("container image should be kept")
	}
}

func TestCleanJSON(t *testing.T) {
	serviceJSON := `{
  "apiVersion": "v1",
  "kind": "Service",
  "metadata": {
    "name": "test-service",
    "creationTimestamp": "2023-01-01T00:00:00Z",
    "resourceVersion": "12345"
  },
  "spec": {
    "type": "ClusterIP",
    "clusterIP": "10.43.211.195",
    "internalTrafficPolicy": "Cluster",
    "ports": [{
      "port": 80,
      "protocol": "TCP"
    }]
  },
  "status": {
    "loadBalancer": {}
  }
}`

	cleaned, err := Neat(serviceJSON)
	if err != nil {
		t.Fatalf("Neat failed: %v", err)
	}

	var result map[string]interface{}
	if err := json.Unmarshal([]byte(cleaned), &result); err != nil {
		t.Fatalf("cleaned JSON is not valid: %v", err)
	}

	// Verify noise was removed
	if _, exists := result["status"]; exists {
		t.Error("status should be removed")
	}

	if spec, ok := result["spec"].(map[string]interface{}); ok {
		if _, exists := spec["type"]; exists {
			t.Error("default service type should be removed")
		}
		if _, exists := spec["clusterIP"]; exists {
			t.Error("clusterIP should be removed")
		}
		if _, exists := spec["internalTrafficPolicy"]; exists {
			t.Error("internalTrafficPolicy should be removed")
		}

		// Check ports
		if ports, ok := spec["ports"].([]interface{}); ok {
			if len(ports) > 0 {
				port := ports[0].(map[string]interface{})
				if _, exists := port["protocol"]; exists {
					t.Error("default protocol TCP should be removed")
				}
			}
		}
	}

	// Verify important data is kept
	if result["apiVersion"] != "v1" {
		t.Error("apiVersion should be kept")
	}
	if result["kind"] != "Service" {
		t.Error("kind should be kept")
	}

	// kubectl-neat's metadata handling only keeps name, namespace, labels, annotations
	if metadata, ok := result["metadata"].(map[string]interface{}); ok {
		if metadata["name"] != "test-service" {
			t.Error("service name should be kept")
		}
		// creationTimestamp and resourceVersion should be removed by neatMetadata
	}
}
</file>

<file path="pkg/neat/neat.go">
/*
Copyright © 2019 Itay Shakury @itaysk

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package neat

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
	"gopkg.in/yaml.v3"
)

// Clean gets a YAML or JSON string and de-clutters it to make it more readable.
func Clean(in string) (string, error) {
	// Try to detect if input is JSON or YAML
	trimmed := strings.TrimSpace(in)
	if trimmed == "" {
		return "", nil
	}

	// If it starts with { or [, assume it's JSON
	if strings.HasPrefix(trimmed, "{") || strings.HasPrefix(trimmed, "[") {
		cleaned, err := Neat(in)
		if err != nil {
			return in, err
		}
		return cleaned, nil
	}

	// Otherwise, assume it's YAML - convert to JSON, clean, convert back
	return cleanYAML(in)
}

// CleanYAMLToJSON converts YAML to cleaned JSON
func CleanYAMLToJSON(yamlStr string) (string, error) {
	if strings.TrimSpace(yamlStr) == "" {
		return "", nil
	}

	// Parse YAML to interface{}
	var obj interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &obj); err != nil {
		return "", fmt.Errorf("failed to parse YAML: %w", err)
	}

	// Convert to JSON for processing
	jsonBytes, err := json.Marshal(obj)
	if err != nil {
		return "", fmt.Errorf("failed to convert to JSON: %w", err)
	}

	// Clean the JSON using kubectl-neat logic
	return Neat(string(jsonBytes))
}

func cleanYAML(yamlStr string) (string, error) {
	// Convert YAML to JSON, clean it, then convert back
	cleaned, err := CleanYAMLToJSON(yamlStr)
	if err != nil {
		return yamlStr, err
	}

	// Convert cleaned JSON back to YAML
	var obj interface{}
	if err := json.Unmarshal([]byte(cleaned), &obj); err != nil {
		return yamlStr, err
	}

	yamlBytes, err := yaml.Marshal(obj)
	if err != nil {
		return yamlStr, err
	}

	return string(yamlBytes), nil
}

// Neat gets a Kubernetes resource json as string and de-clutters it to make it more readable.
// This is the main kubectl-neat implementation
func Neat(in string) (string, error) {
	var err error
	draft := in

	if in == "" {
		return draft, fmt.Errorf("error in neat, input json is empty")
	}
	if !gjson.Valid(in) {
		return draft, fmt.Errorf("error in neat, input is not a valid json: %s", in[:20])
	}

	kind := gjson.Get(in, "kind").String()

	// handle list
	if kind == "List" {
		items := gjson.Get(draft, "items").Array()
		for i, item := range items {
			itemNeat, err := Neat(item.String())
			if err != nil {
				continue
			}
			draft, err = sjson.SetRaw(draft, fmt.Sprintf("items.%d", i), itemNeat)
			if err != nil {
				continue
			}
		}
		// general neating
		draft, err = neatMetadata(draft)
		if err != nil {
			return draft, fmt.Errorf("error in neatMetadata : %v", err)
		}
		return draft, nil
	}

	// defaults neating - this is the key part that removes things like clusterIP, internalTrafficPolicy, etc.
	draft, err = neatDefaults(draft)
	if err != nil {
		return draft, fmt.Errorf("error in neatDefaults : %v", err)
	}

	// controllers neating
	draft, err = neatScheduler(draft)
	if err != nil {
		return draft, fmt.Errorf("error in neatScheduler : %v", err)
	}
	if kind == "Pod" {
		draft, err = neatServiceAccount(draft)
		if err != nil {
			return draft, fmt.Errorf("error in neatServiceAccount : %v", err)
		}
	}

	// general neating
	draft, err = neatMetadata(draft)
	if err != nil {
		return draft, fmt.Errorf("error in neatMetadata : %v", err)
	}
	draft, err = neatStatus(draft)
	if err != nil {
		return draft, fmt.Errorf("error in neatStatus : %v", err)
	}
	draft, err = neatEmpty(draft)
	if err != nil {
		return draft, fmt.Errorf("error in neatEmpty : %v", err)
	}

	return draft, nil
}

func neatMetadata(in string) (string, error) {
	var err error
	in, err = sjson.Delete(in, `metadata.annotations.kubectl\.kubernetes\.io/last-applied-configuration`)
	if err != nil {
		return in, fmt.Errorf("error deleting last-applied-configuration : %v", err)
	}
	// TODO: prettify this. gjson's @pretty is ok but setRaw the pretty code gives unwanted result
	newMeta := gjson.Get(in, "{metadata.name,metadata.namespace,metadata.labels,metadata.annotations}")
	in, err = sjson.Set(in, "metadata", newMeta.Value())
	if err != nil {
		return in, fmt.Errorf("error setting new metadata : %v", err)
	}
	return in, nil
}

func neatStatus(in string) (string, error) {
	return sjson.Delete(in, "status")
}

func neatScheduler(in string) (string, error) {
	return sjson.Delete(in, "spec.nodeName")
}

func neatServiceAccount(in string) (string, error) {
	var err error
	// keep an eye open on https://github.com/tidwall/sjson/issues/11
	// when it's implemented, we can do:
	// sjson.delete(in, "spec.volumes.#(name%default-token-*)")
	// sjson.delete(in, "spec.containers.#.volumeMounts.#(name%default-token-*)")

	for vi, v := range gjson.Get(in, "spec.volumes").Array() {
		vname := v.Get("name").String()
		if strings.HasPrefix(vname, "default-token-") {
			in, err = sjson.Delete(in, fmt.Sprintf("spec.volumes.%d", vi))
			if err != nil {
				continue
			}
		}
	}
	for ci, c := range gjson.Get(in, "spec.containers").Array() {
		for vmi, vm := range c.Get("volumeMounts").Array() {
			vmname := vm.Get("name").String()
			if strings.HasPrefix(vmname, "default-token-") {
				in, err = sjson.Delete(in, fmt.Sprintf("spec.containers.%d.volumeMounts.%d", ci, vmi))
				if err != nil {
					continue
				}
			}
		}
	}
	in, _ = sjson.Delete(in, "spec.serviceAccount") //Deprecated: Use serviceAccountName instead

	return in, nil
}

// neatEmpty removes all zero length elements in the json
func neatEmpty(in string) (string, error) {
	var err error
	jsonResult := gjson.Parse(in)
	var empties []string
	findEmptyPathsRecursive(jsonResult, "", &empties)
	for _, emptyPath := range empties {
		// if we just delete emptyPath, it may create empty parents
		// so we walk the path and re-check for emptiness at every level
		emptyPathParts := strings.Split(emptyPath, ".")
		for i := len(emptyPathParts); i > 0; i-- {
			curPath := strings.Join(emptyPathParts[:i], ".")
			cur := gjson.Get(in, curPath)
			if isResultEmpty(cur) {
				in, err = sjson.Delete(in, curPath)
				if err != nil {
					continue
				}
			}
		}
	}
	return in, nil
}

// findEmptyPathsRecursive builds a list of paths that point to zero length elements
// cur is the current element to look at
// path is the path to cur
// res is a pointer to a list of empty paths to populate
func findEmptyPathsRecursive(cur gjson.Result, path string, res *[]string) {
	if isResultEmpty(cur) {
		*res = append(*res, path[1:]) //remove '.' from start
		return
	}
	if !(cur.IsArray() || cur.IsObject()) {
		return
	}
	// sjson's ForEach doesn't put track index when iterating arrays, hence the index variable
	index := -1
	cur.ForEach(func(k gjson.Result, v gjson.Result) bool {
		var newPath string
		if cur.IsArray() {
			index++
			newPath = fmt.Sprintf("%s.%d", path, index)
		} else {
			newPath = fmt.Sprintf("%s.%s", path, k.Str)
		}
		findEmptyPathsRecursive(v, newPath, res)
		return true
	})
}

func isResultEmpty(j gjson.Result) bool {
	v := j.Value()
	switch vt := v.(type) {
	// empty string != lack of string. keep empty strings as it's meaningful data
	// case string:
	// 	return vt == ""
	case []interface{}:
		return len(vt) == 0
	case map[string]interface{}:
		return len(vt) == 0
	}
	return false
}

// neatDefaults - simplified version without Kubernetes scheme dependency
// This handles the most common service defaults that cause clutter
func neatDefaults(in string) (string, error) {
	kind := gjson.Get(in, "kind").String()

	switch kind {
	case "Service":
		return neatServiceDefaults(in)
	case "Deployment":
		return neatDeploymentDefaults(in)
	default:
		return neatCommonDefaults(in)
	}
}

func neatServiceDefaults(in string) (string, error) {
	var err error
	result := in

	// Remove service-specific defaults that cause clutter
	serviceDefaults := map[string]interface{}{
		"spec.type": "ClusterIP",
		"spec.sessionAffinity": "None",
		"spec.internalTrafficPolicy": "Cluster",
		"spec.ipFamilyPolicy": "SingleStack",
	}

	for path, defaultValue := range serviceDefaults {
		if gjson.Get(result, path).Value() == defaultValue {
			result, err = sjson.Delete(result, path)
			if err != nil {
				continue
			}
		}
	}

	// Remove default ipFamilies if it's just ["IPv4"]
	ipFamilies := gjson.Get(result, "spec.ipFamilies")
	if ipFamilies.IsArray() {
		families := ipFamilies.Array()
		if len(families) == 1 && families[0].String() == "IPv4" {
			result, _ = sjson.Delete(result, "spec.ipFamilies")
		}
	}

	// Remove clusterIP and clusterIPs as they're assigned by cluster
	result, _ = sjson.Delete(result, "spec.clusterIP")
	result, _ = sjson.Delete(result, "spec.clusterIPs")

	// Clean ports - remove default protocol TCP
	ports := gjson.Get(result, "spec.ports")
	if ports.IsArray() {
		var cleanedPorts []interface{}
		for _, port := range ports.Array() {
			portMap := port.Map()
			cleanedPort := make(map[string]interface{})

			for key, value := range portMap {
				// Skip default protocol
				if key == "protocol" && value.String() == "TCP" {
					continue
				}
				cleanedPort[key] = value.Value()
			}
			cleanedPorts = append(cleanedPorts, cleanedPort)
		}

		if len(cleanedPorts) > 0 {
			result, _ = sjson.Set(result, "spec.ports", cleanedPorts)
		}
	}

	return result, nil
}

func neatDeploymentDefaults(in string) (string, error) {
	var err error
	result := in

	// Remove deployment-specific defaults
	deploymentDefaults := map[string]interface{}{
		"spec.progressDeadlineSeconds": float64(600),
		"spec.revisionHistoryLimit": float64(10),
	}

	for path, defaultValue := range deploymentDefaults {
		if gjson.Get(result, path).Value() == defaultValue {
			result, err = sjson.Delete(result, path)
			if err != nil {
				continue
			}
		}
	}

	// Handle strategy type
	if gjson.Get(result, "spec.strategy.type").String() == "RollingUpdate" {
		result, _ = sjson.Delete(result, "spec.strategy.type")
	}

	return neatPodDefaults(result)
}

func neatPodDefaults(in string) (string, error) {
	var err error
	result := in

	// Clean pod spec defaults (works for pods, deployments, etc.)
	podSpecPath := "spec"
	if gjson.Get(result, "spec.template.spec").Exists() {
		podSpecPath = "spec.template.spec"
	}

	podDefaults := map[string]interface{}{
		podSpecPath + ".restartPolicy": "Always",
		podSpecPath + ".dnsPolicy": "ClusterFirst",
		podSpecPath + ".terminationGracePeriodSeconds": float64(30),
	}

	for path, defaultValue := range podDefaults {
		if gjson.Get(result, path).Value() == defaultValue {
			result, err = sjson.Delete(result, path)
			if err != nil {
				continue
			}
		}
	}

	// Clean containers
	containers := gjson.Get(result, podSpecPath+".containers")
	if containers.IsArray() {
		var cleanedContainers []interface{}
		for _, container := range containers.Array() {
			cleanedContainer := cleanContainer(container.Raw)
			var containerObj interface{}
			if err := json.Unmarshal([]byte(cleanedContainer), &containerObj); err == nil {
				cleanedContainers = append(cleanedContainers, containerObj)
			}
		}

		if len(cleanedContainers) > 0 {
			result, _ = sjson.Set(result, podSpecPath+".containers", cleanedContainers)
		}
	}

	return result, nil
}

func cleanContainer(containerJSON string) string {
	result := containerJSON

	containerDefaults := map[string]interface{}{
		"imagePullPolicy": "Always",
		"terminationMessagePath": "/dev/termination-log",
		"terminationMessagePolicy": "File",
	}

	// Also handle IfNotPresent as default for imagePullPolicy
	if gjson.Get(result, "imagePullPolicy").String() == "IfNotPresent" {
		result, _ = sjson.Delete(result, "imagePullPolicy")
	}

	for path, defaultValue := range containerDefaults {
		if gjson.Get(result, path).Value() == defaultValue {
			result, _ = sjson.Delete(result, path)
		}
	}

	return result
}

func neatCommonDefaults(in string) (string, error) {
	// Handle common defaults for other resource types
	return neatPodDefaults(in)
}
</file>

<file path="pkg/services/degradation.go">
package services

import (
	"sync"
	"time"

	apperrors "github.com/darksworm/argonaut/pkg/errors"
	"github.com/darksworm/argonaut/pkg/logging"
	"github.com/darksworm/argonaut/pkg/model"
)

// DegradationMode represents different levels of service degradation
type DegradationMode string

const (
	DegradationNone     DegradationMode = "none"     // Full functionality
	DegradationPartial  DegradationMode = "partial"  // Some features disabled
	DegradationOffline  DegradationMode = "offline"  // Offline/cached mode
	DegradationReadOnly DegradationMode = "readonly" // Read-only operations
)

// ServiceHealth represents the health status of various services
type ServiceHealth struct {
	ArgoAPI      HealthStatus `json:"argoAPI"`
	Authentication HealthStatus `json:"authentication"`
	Connectivity HealthStatus `json:"connectivity"`
	LastCheck    time.Time    `json:"lastCheck"`
	Mode         DegradationMode `json:"mode"`
}

// HealthStatus represents the status of a service component
type HealthStatus struct {
	Status    string    `json:"status"`    // healthy, degraded, unavailable
	LastSeen  time.Time `json:"lastSeen"`
	Failures  int       `json:"failures"`
	Message   string    `json:"message,omitempty"`
}

// GracefulDegradationManager handles service degradation scenarios
type GracefulDegradationManager struct {
	health          ServiceHealth
	mu              sync.RWMutex
	logger          logging.Logger
	cache           *ServiceCache
	healthCheckTicker *time.Ticker
	shutdown        chan struct{}
	callbacks       []DegradationCallback
}

// DegradationCallback is called when degradation mode changes
type DegradationCallback func(oldMode, newMode DegradationMode)

// ServiceCache provides cached data for offline mode
type ServiceCache struct {
	Apps         []model.App   `json:"apps"`
	LastUpdated  time.Time     `json:"lastUpdated"`
	Server       *model.Server `json:"server"`
	APIVersion   string        `json:"apiVersion"`
}

// NewGracefulDegradationManager creates a new degradation manager
func NewGracefulDegradationManager() *GracefulDegradationManager {
	manager := &GracefulDegradationManager{
		health: ServiceHealth{
			ArgoAPI:      HealthStatus{Status: "unknown", LastSeen: time.Now()},
			Authentication: HealthStatus{Status: "unknown", LastSeen: time.Now()},
			Connectivity: HealthStatus{Status: "unknown", LastSeen: time.Now()},
			LastCheck:    time.Now(),
			Mode:         DegradationNone,
		},
		logger:   logging.GetDefaultLogger().WithComponent("degradation"),
		cache:    &ServiceCache{},
		shutdown: make(chan struct{}),
	}

	// Start health monitoring
	manager.startHealthMonitoring()

	return manager
}

// RegisterCallback registers a callback for degradation mode changes
func (m *GracefulDegradationManager) RegisterCallback(callback DegradationCallback) {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.callbacks = append(m.callbacks, callback)
}

// ReportAPIHealth reports the health status of the ArgoCD API
func (m *GracefulDegradationManager) ReportAPIHealth(healthy bool, err error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	if healthy {
		m.health.ArgoAPI.Status = "healthy"
		m.health.ArgoAPI.LastSeen = time.Now()
		m.health.ArgoAPI.Failures = 0
		m.health.ArgoAPI.Message = ""
	} else {
		m.health.ArgoAPI.Failures++
		m.health.ArgoAPI.Message = ""

		if err != nil {
			if argErr, ok := err.(*apperrors.ArgonautError); ok {
				switch argErr.Category {
				case apperrors.ErrorAuth:
					m.health.Authentication.Status = "unavailable"
					m.health.ArgoAPI.Status = "degraded"
					m.health.ArgoAPI.Message = "Authentication required"
				case apperrors.ErrorNetwork, apperrors.ErrorTimeout:
					m.health.Connectivity.Status = "unavailable"
					m.health.ArgoAPI.Status = "unavailable"
					m.health.ArgoAPI.Message = "Network connectivity issues"
				default:
					m.health.ArgoAPI.Status = "degraded"
					m.health.ArgoAPI.Message = argErr.Message
				}
			} else {
				m.health.ArgoAPI.Status = "unavailable"
				m.health.ArgoAPI.Message = err.Error()
			}
		}
	}

	m.health.LastCheck = time.Now()
	m.updateDegradationMode()
}

// ReportAuthHealth reports authentication health status
func (m *GracefulDegradationManager) ReportAuthHealth(healthy bool, err error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	if healthy {
		m.health.Authentication.Status = "healthy"
		m.health.Authentication.LastSeen = time.Now()
		m.health.Authentication.Failures = 0
		m.health.Authentication.Message = ""
	} else {
		m.health.Authentication.Status = "unavailable"
		m.health.Authentication.Failures++
		if err != nil {
			m.health.Authentication.Message = err.Error()
		}
	}

	m.updateDegradationMode()
}

// ReportConnectivityHealth reports network connectivity health
func (m *GracefulDegradationManager) ReportConnectivityHealth(healthy bool, err error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	if healthy {
		m.health.Connectivity.Status = "healthy"
		m.health.Connectivity.LastSeen = time.Now()
		m.health.Connectivity.Failures = 0
		m.health.Connectivity.Message = ""
	} else {
		m.health.Connectivity.Status = "unavailable"
		m.health.Connectivity.Failures++
		if err != nil {
			m.health.Connectivity.Message = err.Error()
		}
	}

	m.updateDegradationMode()
}

// updateDegradationMode determines the appropriate degradation mode based on health
func (m *GracefulDegradationManager) updateDegradationMode() {
	oldMode := m.health.Mode
	var newMode DegradationMode

	// Determine degradation mode based on service health
	if m.health.Authentication.Status == "unavailable" {
		newMode = DegradationOffline
	} else if m.health.Connectivity.Status == "unavailable" {
		newMode = DegradationOffline
	} else if m.health.ArgoAPI.Status == "unavailable" {
		newMode = DegradationOffline
	} else if m.health.ArgoAPI.Status == "degraded" {
		newMode = DegradationPartial
	} else {
		newMode = DegradationNone
	}

	if newMode != oldMode {
		m.health.Mode = newMode
		m.logger.Info("Degradation mode changed: %s -> %s", oldMode, newMode)

		// Notify callbacks
		for _, callback := range m.callbacks {
			go callback(oldMode, newMode)
		}
	}
}

// GetCurrentMode returns the current degradation mode
func (m *GracefulDegradationManager) GetCurrentMode() DegradationMode {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.health.Mode
}

// GetServiceHealth returns the current service health status
func (m *GracefulDegradationManager) GetServiceHealth() ServiceHealth {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.health
}

// CanPerformOperation checks if an operation is allowed in current degradation mode
func (m *GracefulDegradationManager) CanPerformOperation(operation string) (bool, *apperrors.ArgonautError) {
	mode := m.GetCurrentMode()

	switch mode {
	case DegradationNone:
		return true, nil

	case DegradationPartial:
		// Allow read operations, restrict write operations
		readOps := []string{"ListApplications", "GetApplication", "GetResourceDiffs", "GetAPIVersion"}
		for _, op := range readOps {
			if op == operation {
				return true, nil
			}
		}
		return false, apperrors.New(apperrors.ErrorUnavailable, "OPERATION_RESTRICTED",
			"Operation restricted due to service degradation").
			WithUserAction("Some features are temporarily unavailable due to service issues")

	case DegradationReadOnly:
		// Only allow read operations
		readOps := []string{"ListApplications", "GetApplication", "GetResourceDiffs", "GetAPIVersion"}
		for _, op := range readOps {
			if op == operation {
				return true, nil
			}
		}
		return false, apperrors.New(apperrors.ErrorUnavailable, "READONLY_MODE",
			"System is in read-only mode").
			WithUserAction("Write operations are disabled. Please try again later")

	case DegradationOffline:
		// Only allow cached operations
		cachedOps := []string{"ListApplications"} // We can serve from cache
		for _, op := range cachedOps {
			if op == operation {
				return true, nil
			}
		}
		return false, apperrors.New(apperrors.ErrorUnavailable, "OFFLINE_MODE",
			"System is offline - limited functionality available").
			WithUserAction("Check your connection and try again. Some cached data may be available")

	default:
		return false, apperrors.New(apperrors.ErrorInternal, "UNKNOWN_MODE",
			"Unknown degradation mode")
	}
}

// UpdateCache updates the service cache with fresh data
func (m *GracefulDegradationManager) UpdateCache(apps []model.App, server *model.Server, apiVersion string) {
	m.mu.Lock()
	defer m.mu.Unlock()

	m.cache.Apps = apps
	m.cache.Server = server
	m.cache.APIVersion = apiVersion
	m.cache.LastUpdated = time.Now()

	m.logger.Debug("Updated service cache with %d apps", len(apps))
}

// GetCachedApps returns cached application data
func (m *GracefulDegradationManager) GetCachedApps() ([]model.App, bool) {
	m.mu.RLock()
	defer m.mu.RUnlock()

	// Return cached data if it's less than 5 minutes old
	if time.Since(m.cache.LastUpdated) < 5*time.Minute && len(m.cache.Apps) > 0 {
		return m.cache.Apps, true
	}

	return nil, false
}

// GetCacheAge returns the age of the cached data
func (m *GracefulDegradationManager) GetCacheAge() time.Duration {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return time.Since(m.cache.LastUpdated)
}

// startHealthMonitoring starts periodic health checks
func (m *GracefulDegradationManager) startHealthMonitoring() {
	m.healthCheckTicker = time.NewTicker(30 * time.Second)

	go func() {
		for {
			select {
			case <-m.shutdown:
				return
			case <-m.healthCheckTicker.C:
				m.performHealthCheck()
			}
		}
	}()
}

// performHealthCheck performs periodic health validation
func (m *GracefulDegradationManager) performHealthCheck() {
	m.mu.Lock()
	defer m.mu.Unlock()

	now := time.Now()

	// Check if services haven't been seen for too long
	if now.Sub(m.health.ArgoAPI.LastSeen) > 2*time.Minute && m.health.ArgoAPI.Status == "healthy" {
		m.health.ArgoAPI.Status = "degraded"
		m.health.ArgoAPI.Message = "Service hasn't been seen recently"
		m.logger.Warn("ArgoCD API marked as degraded due to inactivity")
	}

	if now.Sub(m.health.Connectivity.LastSeen) > 2*time.Minute && m.health.Connectivity.Status == "healthy" {
		m.health.Connectivity.Status = "degraded"
		m.health.Connectivity.Message = "Connectivity check overdue"
		m.logger.Warn("Connectivity marked as degraded due to inactivity")
	}

	m.health.LastCheck = now
	m.updateDegradationMode()
}

// Shutdown gracefully shuts down the degradation manager
func (m *GracefulDegradationManager) Shutdown() {
	if m.healthCheckTicker != nil {
		m.healthCheckTicker.Stop()
	}
	close(m.shutdown)
	m.logger.Info("Graceful degradation manager shutdown complete")
}

// GetDegradationSummary returns a human-readable summary of the current degradation status
func (m *GracefulDegradationManager) GetDegradationSummary() string {
	health := m.GetServiceHealth()

	switch health.Mode {
	case DegradationNone:
		return "All systems operational"
	case DegradationPartial:
		return "Some features may be limited due to service issues"
	case DegradationReadOnly:
		return "System in read-only mode - write operations disabled"
	case DegradationOffline:
		cacheAge := m.GetCacheAge()
		if cacheAge < 5*time.Minute {
			return "Offline mode - showing cached data from " + cacheAge.Round(time.Second).String() + " ago"
		}
		return "Offline mode - no cached data available"
	default:
		return "System status unknown"
	}
}
</file>

<file path="pkg/services/navigation.go">
package services

import "github.com/darksworm/argonaut/pkg/model"

// NavigationService interface defines operations for navigation logic
type NavigationService interface {
	// DrillDown handles drill-down navigation from one view to the next
	DrillDown(currentView model.View, selectedItem interface{}, visibleItems []interface{}, selectedIdx int) *NavigationUpdate

	// ToggleSelection handles selection toggling (only works in apps view)
	ToggleSelection(currentView model.View, selectedItem interface{}, visibleItems []interface{}, selectedIdx int, currentSelectedApps map[string]bool) *SelectionUpdate

	// ValidateBounds ensures selectedIdx stays within valid bounds
	ValidateBounds(selectedIdx, itemCount int) int

	// ClearLowerLevelSelections clears selections based on current view
	ClearLowerLevelSelections(view model.View) map[string]interface{}

	// ResetNavigation resets navigation state to defaults
	ResetNavigation(view *model.View) map[string]interface{}

	// ClearAllSelections clears all selections
	ClearAllSelections() map[string]interface{}

	// ClearFilters clears all filters and search
	ClearFilters() map[string]interface{}

	// CanDrillDown determines if drill down is possible from current view
	CanDrillDown(view model.View) bool

	// CanToggleSelection determines if selection toggle is possible from current view
	CanToggleSelection(view model.View) bool

	// GetNextView gets the next view in the drill down hierarchy
	GetNextView(currentView model.View) *model.View

	// GetPreviousView gets the previous view in the drill down hierarchy
	GetPreviousView(currentView model.View) *model.View
}

// NavigationUpdate represents the result of a navigation operation
type NavigationUpdate struct {
	NewView                         *model.View     `json:"newView,omitempty"`
	ScopeClusters                   map[string]bool `json:"scopeClusters,omitempty"`
	ScopeNamespaces                 map[string]bool `json:"scopeNamespaces,omitempty"`
	ScopeProjects                   map[string]bool `json:"scopeProjects,omitempty"`
	SelectedApps                    map[string]bool `json:"selectedApps,omitempty"`
	ShouldResetNavigation           bool            `json:"shouldResetNavigation"`
	ShouldClearLowerLevelSelections bool            `json:"shouldClearLowerLevelSelections"`
}

// SelectionUpdate represents the result of a selection operation
type SelectionUpdate struct {
	SelectedApps map[string]bool `json:"selectedApps"`
}

// NavigationServiceImpl provides a concrete implementation of NavigationService
type NavigationServiceImpl struct{}

// NewNavigationService creates a new NavigationService implementation
func NewNavigationService() NavigationService {
	return &NavigationServiceImpl{}
}

// DrillDown implements NavigationService.DrillDown
func (s *NavigationServiceImpl) DrillDown(currentView model.View, selectedItem interface{}, visibleItems []interface{}, selectedIdx int) *NavigationUpdate {
	if selectedIdx >= len(visibleItems) || selectedIdx < 0 {
		return nil
	}

	item := visibleItems[selectedIdx]
	if item == nil {
		return nil
	}

	val := stringValue(item)
	next := model.AddToStringSet(model.NewStringSet(), val)

	result := &NavigationUpdate{
		ShouldResetNavigation:           true,
		ShouldClearLowerLevelSelections: true,
	}

	switch currentView {
	case model.ViewClusters:
		newView := model.ViewNamespaces
		result.NewView = &newView
		result.ScopeClusters = next
	case model.ViewNamespaces:
		newView := model.ViewProjects
		result.NewView = &newView
		result.ScopeNamespaces = next
	case model.ViewProjects:
		newView := model.ViewApps
		result.NewView = &newView
		result.ScopeProjects = next
	default:
		return nil // Can't drill down from apps view
	}

	return result
}

// ToggleSelection implements NavigationService.ToggleSelection
func (s *NavigationServiceImpl) ToggleSelection(currentView model.View, selectedItem interface{}, visibleItems []interface{}, selectedIdx int, currentSelectedApps map[string]bool) *SelectionUpdate {
	// Only allow toggle selection in apps view
	if currentView != model.ViewApps {
		return nil
	}

	if selectedIdx >= len(visibleItems) || selectedIdx < 0 {
		return nil
	}

	item := visibleItems[selectedIdx]
	if item == nil {
		return nil
	}

	appName := appNameFromItem(item)
	next := make(map[string]bool)
	for k, v := range currentSelectedApps {
		next[k] = v
	}

	if model.HasInStringSet(next, appName) {
		next = model.RemoveFromStringSet(next, appName)
	} else {
		next = model.AddToStringSet(next, appName)
	}

	return &SelectionUpdate{
		SelectedApps: next,
	}
}

// ValidateBounds implements NavigationService.ValidateBounds
func (s *NavigationServiceImpl) ValidateBounds(selectedIdx, itemCount int) int {
	if itemCount == 0 {
		return 0
	}
	if selectedIdx < 0 {
		return 0
	}
	if selectedIdx >= itemCount {
		return itemCount - 1
	}
	return selectedIdx
}

// ClearLowerLevelSelections implements NavigationService.ClearLowerLevelSelections
func (s *NavigationServiceImpl) ClearLowerLevelSelections(view model.View) map[string]interface{} {
	emptySet := model.NewStringSet()
	result := make(map[string]interface{})

	switch view {
	case model.ViewClusters:
		result["scopeNamespaces"] = emptySet
		result["scopeProjects"] = emptySet
		result["selectedApps"] = emptySet
	case model.ViewNamespaces:
		result["scopeProjects"] = emptySet
		result["selectedApps"] = emptySet
	case model.ViewProjects:
		result["selectedApps"] = emptySet
	}

	return result
}

// ResetNavigation implements NavigationService.ResetNavigation
func (s *NavigationServiceImpl) ResetNavigation(view *model.View) map[string]interface{} {
	result := map[string]interface{}{
		"selectedIdx":    0,
		"activeFilter":   "",
		"searchQuery":    "",
	}
	if view != nil {
		result["view"] = *view
	}
	return result
}

// ClearAllSelections implements NavigationService.ClearAllSelections
func (s *NavigationServiceImpl) ClearAllSelections() map[string]interface{} {
	return map[string]interface{}{
		"scopeClusters":   model.NewStringSet(),
		"scopeNamespaces": model.NewStringSet(),
		"scopeProjects":   model.NewStringSet(),
		"selectedApps":    model.NewStringSet(),
	}
}

// ClearFilters implements NavigationService.ClearFilters
func (s *NavigationServiceImpl) ClearFilters() map[string]interface{} {
	return map[string]interface{}{
		"activeFilter": "",
		"searchQuery":  "",
	}
}

// CanDrillDown implements NavigationService.CanDrillDown
func (s *NavigationServiceImpl) CanDrillDown(view model.View) bool {
	return view != model.ViewApps
}

// CanToggleSelection implements NavigationService.CanToggleSelection
func (s *NavigationServiceImpl) CanToggleSelection(view model.View) bool {
	return view == model.ViewApps
}

// GetNextView implements NavigationService.GetNextView
func (s *NavigationServiceImpl) GetNextView(currentView model.View) *model.View {
	switch currentView {
	case model.ViewClusters:
		view := model.ViewNamespaces
		return &view
	case model.ViewNamespaces:
		view := model.ViewProjects
		return &view
	case model.ViewProjects:
		view := model.ViewApps
		return &view
	default:
		return nil
	}
}

// GetPreviousView implements NavigationService.GetPreviousView
func (s *NavigationServiceImpl) GetPreviousView(currentView model.View) *model.View {
	switch currentView {
	case model.ViewApps:
		view := model.ViewProjects
		return &view
	case model.ViewProjects:
		view := model.ViewNamespaces
		return &view
	case model.ViewNamespaces:
		view := model.ViewClusters
		return &view
	default:
		return nil
	}
}

// Helper functions

// stringValue extracts string representation from an interface{}
func stringValue(item interface{}) string {
	if item == nil {
		return ""
	}
	if str, ok := item.(string); ok {
		return str
	}
	// Handle App struct
	if app, ok := item.(model.App); ok {
		return app.Name
	}
	// Handle App pointer
	if app, ok := item.(*model.App); ok && app != nil {
		return app.Name
	}
	return ""
}

// appNameFromItem extracts app name from an item (assuming it's an App)
func appNameFromItem(item interface{}) string {
	if app, ok := item.(model.App); ok {
		return app.Name
	}
	if app, ok := item.(*model.App); ok && app != nil {
		return app.Name
	}
	return ""
}
</file>

<file path="pkg/services/recovery.go">
package services

import (
	"context"
	"sync"
	"time"

	apperrors "github.com/darksworm/argonaut/pkg/errors"
	"github.com/darksworm/argonaut/pkg/logging"
	"github.com/darksworm/argonaut/pkg/model"
	"github.com/darksworm/argonaut/pkg/retry"
)

// StreamRecoveryConfig configures stream recovery behavior
type StreamRecoveryConfig struct {
	MaxReconnectAttempts int           `json:"maxReconnectAttempts"`
	InitialBackoff       time.Duration `json:"initialBackoff"`
	MaxBackoff           time.Duration `json:"maxBackoff"`
	BackoffMultiplier    float64       `json:"backoffMultiplier"`
	HealthCheckInterval  time.Duration `json:"healthCheckInterval"`
}

// DefaultStreamRecoveryConfig provides sensible defaults
var DefaultStreamRecoveryConfig = StreamRecoveryConfig{
	MaxReconnectAttempts: 10,
	InitialBackoff:       1 * time.Second,
	MaxBackoff:           60 * time.Second,
	BackoffMultiplier:    2.0,
	HealthCheckInterval:  30 * time.Second,
}

// StreamRecoveryManager handles stream connection recovery
type StreamRecoveryManager struct {
	config       StreamRecoveryConfig
	logger       logging.Logger
	mu           sync.RWMutex
	activeStreams map[string]*StreamConnection
	shutdown     chan struct{}
	wg           sync.WaitGroup
}

// StreamConnection represents an active stream connection
type StreamConnection struct {
	ID           string
	Server       *model.Server
	LastSeen     time.Time
	Failures     int
	Status       StreamStatus
	RecoveryFunc func(ctx context.Context) error
	Context      context.Context
	Cancel       context.CancelFunc
}

// StreamStatus represents the status of a stream
type StreamStatus string

const (
	StreamStatusHealthy     StreamStatus = "healthy"
	StreamStatusRecovering  StreamStatus = "recovering"
	StreamStatusFailed      StreamStatus = "failed"
	StreamStatusDisconnected StreamStatus = "disconnected"
)

// NewStreamRecoveryManager creates a new stream recovery manager
func NewStreamRecoveryManager(config StreamRecoveryConfig) *StreamRecoveryManager {
	manager := &StreamRecoveryManager{
		config:        config,
		logger:        logging.GetDefaultLogger().WithComponent("stream-recovery"),
		activeStreams: make(map[string]*StreamConnection),
		shutdown:      make(chan struct{}),
	}

	// Start health check goroutine
	manager.wg.Add(1)
	go manager.healthCheckLoop()

	return manager
}

// RegisterStream registers a stream for recovery management
func (m *StreamRecoveryManager) RegisterStream(id string, server *model.Server, recoveryFunc func(ctx context.Context) error) *StreamConnection {
	m.mu.Lock()
	defer m.mu.Unlock()

	ctx, cancel := context.WithCancel(context.Background())

	stream := &StreamConnection{
		ID:           id,
		Server:       server,
		LastSeen:     time.Now(),
		Failures:     0,
		Status:       StreamStatusHealthy,
		RecoveryFunc: recoveryFunc,
		Context:      ctx,
		Cancel:       cancel,
	}

	m.activeStreams[id] = stream
	m.logger.Info("Registered stream for recovery: %s", id)

	return stream
}

// UnregisterStream removes a stream from recovery management
func (m *StreamRecoveryManager) UnregisterStream(id string) {
	m.mu.Lock()
	defer m.mu.Unlock()

	if stream, exists := m.activeStreams[id]; exists {
		stream.Cancel()
		delete(m.activeStreams, id)
		m.logger.Info("Unregistered stream: %s", id)
	}
}

// ReportStreamFailure reports a failure for a specific stream
func (m *StreamRecoveryManager) ReportStreamFailure(id string, err error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	stream, exists := m.activeStreams[id]
	if !exists {
		return
	}

	stream.Failures++
	stream.Status = StreamStatusFailed
	stream.LastSeen = time.Now()

	m.logger.Warn("Stream failure reported for %s (failures: %d): %v", id, stream.Failures, err)

	// Start recovery process
	m.wg.Add(1)
	go m.recoverStream(stream, err)
}

// ReportStreamHealthy marks a stream as healthy
func (m *StreamRecoveryManager) ReportStreamHealthy(id string) {
	m.mu.Lock()
	defer m.mu.Unlock()

	if stream, exists := m.activeStreams[id]; exists {
		stream.Status = StreamStatusHealthy
		stream.LastSeen = time.Now()
		stream.Failures = 0 // Reset failure count on successful recovery
	}
}

// recoverStream attempts to recover a failed stream
func (m *StreamRecoveryManager) recoverStream(stream *StreamConnection, originalErr error) {
	defer m.wg.Done()

	m.logger.Info("Starting recovery for stream %s", stream.ID)

	// Create recovery context with timeout
	recoveryCtx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
	defer cancel()

	// Create retry configuration for stream recovery
	retryConfig := retry.RetryConfig{
		MaxAttempts:  m.config.MaxReconnectAttempts,
		InitialDelay: m.config.InitialBackoff,
		MaxDelay:     m.config.MaxBackoff,
		Multiplier:   m.config.BackoffMultiplier,
		Jitter:       true,
		ShouldRetry: func(err *apperrors.ArgonautError) bool {
			// Retry most errors except authentication and permission issues
			return err.Category != apperrors.ErrorAuth &&
				   err.Category != apperrors.ErrorPermission &&
				   err.Category != apperrors.ErrorConfig
		},
	}

	m.mu.Lock()
	stream.Status = StreamStatusRecovering
	m.mu.Unlock()

	err := retry.RetryWithBackoff(recoveryCtx, retryConfig, func(attempt int) error {
		m.logger.Debug("Recovery attempt %d for stream %s", attempt, stream.ID)

		select {
		case <-m.shutdown:
			return apperrors.New(apperrors.ErrorInternal, "SHUTDOWN", "Recovery cancelled due to shutdown")
		case <-stream.Context.Done():
			return apperrors.New(apperrors.ErrorInternal, "CANCELLED", "Stream context cancelled")
		default:
			return stream.RecoveryFunc(recoveryCtx)
		}
	})

	m.mu.Lock()
	defer m.mu.Unlock()

	if err != nil {
		stream.Status = StreamStatusFailed
		stream.Failures++
		m.logger.Error("Failed to recover stream %s after %d attempts: %v",
			stream.ID, m.config.MaxReconnectAttempts, err)

		// If we've exceeded max attempts, mark as disconnected
		if stream.Failures >= m.config.MaxReconnectAttempts {
			stream.Status = StreamStatusDisconnected
			m.logger.Error("Stream %s marked as disconnected after %d failures",
				stream.ID, stream.Failures)
		}
	} else {
		stream.Status = StreamStatusHealthy
		stream.Failures = 0
		stream.LastSeen = time.Now()
		m.logger.Info("Successfully recovered stream %s", stream.ID)
	}
}

// healthCheckLoop periodically checks stream health
func (m *StreamRecoveryManager) healthCheckLoop() {
	defer m.wg.Done()

	ticker := time.NewTicker(m.config.HealthCheckInterval)
	defer ticker.Stop()

	for {
		select {
		case <-m.shutdown:
			return
		case <-ticker.C:
			m.performHealthCheck()
		}
	}
}

// performHealthCheck checks all registered streams for health
func (m *StreamRecoveryManager) performHealthCheck() {
	m.mu.RLock()
	streams := make([]*StreamConnection, 0, len(m.activeStreams))
	for _, stream := range m.activeStreams {
		streams = append(streams, stream)
	}
	m.mu.RUnlock()

	now := time.Now()
	for _, stream := range streams {
		// Check if stream hasn't been seen for too long
		if now.Sub(stream.LastSeen) > m.config.HealthCheckInterval*2 {
			if stream.Status == StreamStatusHealthy {
				m.logger.Warn("Stream %s appears stale, marking for recovery", stream.ID)
				m.ReportStreamFailure(stream.ID,
					apperrors.TimeoutError("STREAM_STALE", "Stream has been inactive"))
			}
		}
	}
}

// GetStreamStatus returns the current status of all streams
func (m *StreamRecoveryManager) GetStreamStatus() map[string]StreamStatus {
	m.mu.RLock()
	defer m.mu.RUnlock()

	status := make(map[string]StreamStatus)
	for id, stream := range m.activeStreams {
		status[id] = stream.Status
	}
	return status
}

// Shutdown gracefully shuts down the recovery manager
func (m *StreamRecoveryManager) Shutdown() {
	m.logger.Info("Shutting down stream recovery manager")

	// Cancel all active streams
	m.mu.Lock()
	for _, stream := range m.activeStreams {
		stream.Cancel()
	}
	m.mu.Unlock()

	// Signal shutdown
	close(m.shutdown)

	// Wait for all goroutines to finish
	m.wg.Wait()

	m.logger.Info("Stream recovery manager shutdown complete")
}

// StreamRecoveryStats provides statistics about stream recovery
type StreamRecoveryStats struct {
	TotalStreams    int                        `json:"totalStreams"`
	HealthyStreams  int                        `json:"healthyStreams"`
	RecoveringStreams int                      `json:"recoveringStreams"`
	FailedStreams   int                        `json:"failedStreams"`
	DisconnectedStreams int                    `json:"disconnectedStreams"`
	StreamDetails   map[string]StreamDetail    `json:"streamDetails"`
}

// StreamDetail provides detailed information about a stream
type StreamDetail struct {
	ID       string       `json:"id"`
	Status   StreamStatus `json:"status"`
	LastSeen time.Time    `json:"lastSeen"`
	Failures int          `json:"failures"`
	Server   string       `json:"server"`
}

// GetRecoveryStats returns detailed statistics about stream recovery
func (m *StreamRecoveryManager) GetRecoveryStats() StreamRecoveryStats {
	m.mu.RLock()
	defer m.mu.RUnlock()

	stats := StreamRecoveryStats{
		TotalStreams:  len(m.activeStreams),
		StreamDetails: make(map[string]StreamDetail),
	}

	for id, stream := range m.activeStreams {
		detail := StreamDetail{
			ID:       stream.ID,
			Status:   stream.Status,
			LastSeen: stream.LastSeen,
			Failures: stream.Failures,
			Server:   stream.Server.BaseURL,
		}

		stats.StreamDetails[id] = detail

		// Count by status
		switch stream.Status {
		case StreamStatusHealthy:
			stats.HealthyStreams++
		case StreamStatusRecovering:
			stats.RecoveringStreams++
		case StreamStatusFailed:
			stats.FailedStreams++
		case StreamStatusDisconnected:
			stats.DisconnectedStreams++
		}
	}

	return stats
}
</file>

<file path="pkg/services/status.go">
package services

import (
	"fmt"
	"log"
)

// StatusLevel represents the level of a status message
type StatusLevel string

const (
	StatusLevelInfo  StatusLevel = "info"
	StatusLevelWarn  StatusLevel = "warn"
	StatusLevelError StatusLevel = "error"
	StatusLevelDebug StatusLevel = "debug"
)

// StatusMessage represents a status message
type StatusMessage struct {
	Level   StatusLevel `json:"level"`
	Message string      `json:"message"`
}

// StatusChangeHandler is called when status changes
type StatusChangeHandler func(message StatusMessage)

// StatusService interface defines operations for status logging
type StatusService interface {
	// Info logs an info message
	Info(message string)

	// Warn logs a warning message
	Warn(message string)

	// Error logs an error message
	Error(message string)

	// Debug logs a debug message
	Debug(message string)

	// Set sets a status message (typically for current status display)
	Set(message string)

	// Clear clears the current status
	Clear()

	// SetHandler sets the status change handler
	SetHandler(handler StatusChangeHandler)
}

// StatusServiceImpl provides a concrete implementation of StatusService
type StatusServiceImpl struct {
	handler       StatusChangeHandler
	currentStatus string
	debugEnabled  bool
}

// StatusServiceConfig holds configuration for StatusService
type StatusServiceConfig struct {
	Handler      StatusChangeHandler
	DebugEnabled bool
}

// NewStatusService creates a new StatusService implementation
func NewStatusService(config StatusServiceConfig) StatusService {
	return &StatusServiceImpl{
		handler:      config.Handler,
		debugEnabled: config.DebugEnabled,
	}
}

// Info implements StatusService.Info
func (s *StatusServiceImpl) Info(message string) {
	msg := StatusMessage{
		Level:   StatusLevelInfo,
		Message: message,
	}
	s.handleMessage(msg)
}

// Warn implements StatusService.Warn
func (s *StatusServiceImpl) Warn(message string) {
	msg := StatusMessage{
		Level:   StatusLevelWarn,
		Message: message,
	}
	s.handleMessage(msg)
}

// Error implements StatusService.Error
func (s *StatusServiceImpl) Error(message string) {
	msg := StatusMessage{
		Level:   StatusLevelError,
		Message: message,
	}
	s.handleMessage(msg)
}

// Debug implements StatusService.Debug
func (s *StatusServiceImpl) Debug(message string) {
	if !s.debugEnabled {
		return
	}
	
	msg := StatusMessage{
		Level:   StatusLevelDebug,
		Message: message,
	}
	s.handleMessage(msg)
}

// Set implements StatusService.Set
func (s *StatusServiceImpl) Set(message string) {
	s.currentStatus = message
	s.Info(message)
}

// Clear implements StatusService.Clear
func (s *StatusServiceImpl) Clear() {
	s.currentStatus = ""
}

// SetHandler implements StatusService.SetHandler
func (s *StatusServiceImpl) SetHandler(handler StatusChangeHandler) {
	s.handler = handler
}

// GetCurrentStatus returns the current status message
func (s *StatusServiceImpl) GetCurrentStatus() string {
	return s.currentStatus
}

// handleMessage processes a status message
func (s *StatusServiceImpl) handleMessage(msg StatusMessage) {
	// Always log to standard logger
	switch msg.Level {
	case StatusLevelError:
		log.Printf("ERROR: %s", msg.Message)
	case StatusLevelWarn:
		log.Printf("WARN: %s", msg.Message)
	case StatusLevelInfo:
		log.Printf("INFO: %s", msg.Message)
	case StatusLevelDebug:
		log.Printf("DEBUG: %s", msg.Message)
	}

	// Call custom handler if provided
	if s.handler != nil {
		s.handler(msg)
	}
}

// DefaultStatusChangeHandler provides a default handler that just prints to stdout
func DefaultStatusChangeHandler(msg StatusMessage) {
	switch msg.Level {
	case StatusLevelError:
		fmt.Printf("❌ %s\n", msg.Message)
	case StatusLevelWarn:
		fmt.Printf("⚠️  %s\n", msg.Message)
	case StatusLevelInfo:
		fmt.Printf("ℹ️  %s\n", msg.Message)
	case StatusLevelDebug:
		fmt.Printf("🐛 %s\n", msg.Message)
	}
}

// NullStatusChangeHandler provides a handler that does nothing (for testing)
func NullStatusChangeHandler(msg StatusMessage) {
	// Do nothing
}
</file>

<file path="pkg/tui/treeview/treeview.go">
package treeview

import (
    "fmt"
    "sort"
    "strings"

    tea "github.com/charmbracelet/bubbletea/v2"
    "github.com/charmbracelet/lipgloss/v2"
    "github.com/darksworm/argonaut/pkg/api"
)

// TreeView wraps a simple interactive tree for displaying ArgoCD resource trees.
// It intentionally keeps state minimal and integrates with Bubble Tea.
type TreeView struct {
    Model       tea.Model // kept to satisfy requested shape; this instance is itself a tea.Model
    SelectedUID string

    width  int
    height int

    nodesByUID map[string]*treeNode
    roots      []*treeNode
    expanded   map[string]bool
    order      []*treeNode // visible nodes in DFS order based on expanded
    selIdx     int

    appName   string
    appHealth string
    appSync   string
}

type treeNode struct {
    uid       string
    kind      string
    name      string
    namespace string
    status    string
    health    string
    parent    *treeNode
    children  []*treeNode
}

// Color styles consistent with existing TUI
var (
    colorGreen  = lipgloss.Color("10")
    colorYellow = lipgloss.Color("11")
    colorRed    = lipgloss.Color("9")
    colorGray   = lipgloss.Color("8")
    selectBG    = lipgloss.Color("13")
)

func statusStyle(s string) lipgloss.Style {
    switch strings.ToLower(s) {
    case "healthy", "running", "synced":
        return lipgloss.NewStyle().Foreground(colorGreen)
    case "progressing", "pending":
        return lipgloss.NewStyle().Foreground(colorYellow)
    case "degraded", "error", "crashloop":
        return lipgloss.NewStyle().Foreground(colorRed)
    default:
        return lipgloss.NewStyle().Foreground(colorGray)
    }
}

// NewTreeView creates a new tree view instance
func NewTreeView(width, height int) *TreeView {
    tv := &TreeView{
        width:      width,
        height:     height,
        nodesByUID: make(map[string]*treeNode),
        expanded:   make(map[string]bool),
        selIdx:     0,
    }
    tv.Model = tv // self
    return tv
}

// Init implements tea.Model; no async startup required
func (v *TreeView) Init() tea.Cmd { return nil }

// SetData converts api.ResourceTree to internal nodes and builds adjacency
func (v *TreeView) SetData(tree *api.ResourceTree) {
    v.nodesByUID = make(map[string]*treeNode)
    v.roots = nil
    v.expanded = make(map[string]bool)
    v.order = nil
    v.selIdx = 0
    v.SelectedUID = ""

    // First pass: create nodes
    for _, n := range tree.Nodes {
        ns := ""
        if n.Namespace != nil {
            ns = *n.Namespace
        }
        health := ""
        if n.Health != nil && n.Health.Status != nil {
            health = *n.Health.Status
        }
        tn := &treeNode{
            uid:    n.UID,
            kind:   n.Kind,
            name:   n.Name,
            status: n.Status,
            health: health,
            namespace: ns,
        }
        v.nodesByUID[n.UID] = tn
    }

    // Second pass: set parents/children (use first matching ParentRef uid if present)
    // Some resources may have multiple ParentRefs; attach to each parent for visibility.
    for _, n := range tree.Nodes {
        child := v.nodesByUID[n.UID]
        if len(n.ParentRefs) == 0 {
            continue
        }
        for _, pref := range n.ParentRefs {
            if p, ok := v.nodesByUID[pref.UID]; ok {
                child.parent = p // last parent wins for back-navigation
                p.children = append(p.children, child)
            }
        }
    }

    // Roots = nodes with no parent in the set (temporary, will attach under app root)
    tempRoots := make([]*treeNode, 0)
    for _, node := range v.nodesByUID {
        if node.parent == nil {
            tempRoots = append(tempRoots, node)
        }
    }
    // Sort roots and children by kind/name for stable display
    sortNodes := func(list []*treeNode) {
        sort.Slice(list, func(i, j int) bool {
            if list[i].kind == list[j].kind {
                return list[i].name < list[j].name
            }
            return list[i].kind < list[j].kind
        })
    }
    sortNodes(tempRoots)
    for _, n := range v.nodesByUID {
        if len(n.children) > 0 {
            sortNodes(n.children)
        }
    }

    // Create synthetic application root and attach temp roots under it
    root := &treeNode{
        uid:    "__app_root__",
        kind:   "Application",
        name:   v.appName,
        status: v.appHealth,
        health: v.appHealth,
    }
    for _, r := range tempRoots {
        r.parent = root
        root.children = append(root.children, r)
    }
    v.nodesByUID[root.uid] = root
    v.roots = []*treeNode{root}

    // Expand everything by default (root and all descendants)
    for uid := range v.nodesByUID {
        v.expanded[uid] = true
    }
    v.rebuildOrder()
}

func (v *TreeView) rebuildOrder() {
    v.order = v.order[:0]
    var walk func(n *treeNode, depth int)
    walk = func(n *treeNode, depth int) {
        v.order = append(v.order, n)
        if v.expanded[n.uid] {
            for _, c := range n.children {
                walk(c, depth+1)
            }
        }
    }
    for _, r := range v.roots {
        walk(r, 0)
    }
    // Clamp selection
    if v.selIdx >= len(v.order) {
        v.selIdx = max(0, len(v.order)-1)
    }
    if v.selIdx >= 0 && v.selIdx < len(v.order) {
        v.SelectedUID = v.order[v.selIdx].uid
    }
}

func (v *TreeView) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    switch m := msg.(type) {
    case tea.KeyMsg:
        switch m.String() {
        case "up", "k":
            if v.selIdx > 0 { v.selIdx-- }
        case "down", "j":
            if v.selIdx < len(v.order)-1 { v.selIdx++ }
        case "left", "h":
            if v.selIdx >= 0 && v.selIdx < len(v.order) {
                cur := v.order[v.selIdx]
                if v.expanded[cur.uid] && len(cur.children) > 0 {
                    // collapse
                    v.expanded[cur.uid] = false
                    v.rebuildOrder()
                } else if cur.parent != nil {
                    // go to parent
                    // move selection up until we reach parent index
                    pidx := v.indexOf(cur.parent)
                    if pidx >= 0 { v.selIdx = pidx }
                }
            }
        case "right", "l", "enter":
            if v.selIdx >= 0 && v.selIdx < len(v.order) {
                cur := v.order[v.selIdx]
                if len(cur.children) > 0 {
                    v.expanded[cur.uid] = true
                    v.rebuildOrder()
                }
            }
        }
        if v.selIdx >= 0 && v.selIdx < len(v.order) {
            v.SelectedUID = v.order[v.selIdx].uid
        }
    case tea.WindowSizeMsg:
        v.width = m.Width
        v.height = m.Height
    }
    return v, nil
}

func (v *TreeView) indexOf(n *treeNode) int {
    for i, x := range v.order {
        if x == n { return i }
    }
    return -1
}

func (v *TreeView) View() string {
    if len(v.order) == 0 {
        return "(no resources)"
    }
    // Render visible nodes with ASCII tree lines
    var b strings.Builder
    // Precompute depths and last-child flags for drawing
    parentMap := make(map[*treeNode]*treeNode)
    for _, n := range v.nodesByUID { for _, c := range n.children { parentMap[c] = n } }

    for i, n := range v.order {
        // Determine depth by walking parents
        depth := 0
        p := n.parent
        for p != nil { depth++; p = p.parent }
        // Determine prefix
        var prefixParts []string
        // Build ancestry stack to know if ancestor is last child
        stack := make([]*treeNode, 0)
        pp := n.parent
        for pp != nil { stack = append(stack, pp); pp = pp.parent }
        // reverse stack
        for l, r := 0, len(stack)-1; l < r; l, r = l+1, r-1 { stack[l], stack[r] = stack[r], stack[l] }
        for _, anc := range stack {
            // Skip adding a trunk for the synthetic root (no parent)
            if anc.parent == nil { continue }
            // is anc last among its siblings?
            last := false
            siblings := anc.parent.children
            if len(siblings) > 0 && siblings[len(siblings)-1] == anc {
                last = true
            }
            if last {
                prefixParts = append(prefixParts, "    ")
            } else {
                prefixParts = append(prefixParts, "│   ")
            }
        }
        // For this node, determine connector relative to its parent
        conn := ""
        if n.parent != nil {
            siblings := n.parent.children
            if len(siblings) > 0 && siblings[len(siblings)-1] == n {
                conn = "└── "
            } else {
                conn = "├── "
            }
        }
        prefix := strings.Join(prefixParts, "") + conn

        label := v.renderLabel(n)
        line := prefix + label
        if i == v.selIdx {
            line = lipgloss.NewStyle().Background(selectBG).Render(padRight(line, v.innerWidth()))
        }
        b.WriteString(line)
        if i < len(v.order)-1 { b.WriteString("\n") }
    }
    return b.String()
}

func (v *TreeView) renderLabel(n *treeNode) string {
    name := n.name
    if n.namespace != "" {
        name = fmt.Sprintf("%s/%s", n.namespace, n.name)
    }
    status := n.health
    if status == "" { status = n.status }
    st := statusStyle(status).Render(fmt.Sprintf("(%s)", status))
    return fmt.Sprintf("%s [%s] %s", n.kind, name, st)
}

func (v *TreeView) innerWidth() int {
    if v.width <= 2 { return v.width }
    return v.width - 2
}

func (v *TreeView) SetSize(width, height int) {
    v.width, v.height = width, height
}

func max(a, b int) int { if a > b { return a }; return b }

// Expose selected index for integration (optional)
func (v *TreeView) SelectedIndex() int { return v.selIdx }

func padRight(s string, width int) string {
    w := lipgloss.Width(s)
    if w >= width { return s }
    return s + strings.Repeat(" ", width-w)
}

// SetAppMeta sets the application metadata used for the synthetic top-level node
func (v *TreeView) SetAppMeta(name, health, sync string) {
    v.appName = name
    v.appHealth = health
    v.appSync = sync
}
</file>

<file path="pkg/tui/errors.go">
package tui

import (
	"time"

	tea "github.com/charmbracelet/bubbletea/v2"
	apperrors "github.com/darksworm/argonaut/pkg/errors"
	"github.com/darksworm/argonaut/pkg/model"
)

// ErrorHandler manages TUI error state and responses
type ErrorHandler struct {
	handler *apperrors.ErrorHandlerImpl
}

// NewErrorHandler creates a new TUI error handler
func NewErrorHandler() (*ErrorHandler, error) {
	handler, err := apperrors.NewErrorHandler(apperrors.ErrorHandlerConfig{
		LogFilePath: "logs/tui-errors.log",
		MaxHistory:  50,
		NotifyCallback: func(err *apperrors.ArgonautError) {
			// This will be called when errors occur
			// Can be used for additional TUI notifications
		},
	})
	if err != nil {
		return nil, err
	}

	return &ErrorHandler{
		handler: handler,
	}, nil
}

// HandleError processes an error and returns appropriate TUI messages
func (h *ErrorHandler) HandleError(err *apperrors.ArgonautError) []tea.Msg {
	if err == nil {
		return nil
	}

	// Handle the error through the centralized handler
	response := h.handler.Handle(err)
	if response == nil {
		return nil
	}

	var messages []tea.Msg

	// Create structured error message for TUI
	structuredMsg := model.StructuredErrorMsg{
		Error:   err,
		Context: make(map[string]interface{}),
		Retry:   h.handler.ShouldRetry(err),
	}

	// Add auto-hide for low severity errors
	if err.Severity == apperrors.SeverityLow {
		structuredMsg.AutoHide = true
	}

	messages = append(messages, structuredMsg)

	// If the error should trigger a retry, schedule it
	if response.RetryAfter != nil {
		retryMsg := model.RetryOperationMsg{
			Operation: "last_operation", // This could be more specific
			Context:   err.Context,
			Attempt:   1,
		}

		// Schedule the retry after the specified delay
		messages = append(messages, tea.Tick(*response.RetryAfter, func(time.Time) tea.Msg {
			return retryMsg
		}))
	}

	return messages
}

// ConvertLegacyError converts old-style errors to structured errors
func (h *ErrorHandler) ConvertLegacyError(msg interface{}) *apperrors.ArgonautError {
	switch m := msg.(type) {
	case model.AuthErrorMsg:
		return apperrors.AuthError("AUTHENTICATION_REQUIRED", "Authentication required").
			WithCause(m.Error).
			WithUserAction("Please run 'argocd login' to authenticate")

	case model.ApiErrorMsg:
		category := apperrors.ErrorAPI
		code := "API_ERROR"

		// Determine category based on status code
		if m.StatusCode >= 401 && m.StatusCode < 403 {
			category = apperrors.ErrorAuth
			code = "UNAUTHORIZED"
		} else if m.StatusCode == 403 {
			category = apperrors.ErrorPermission
			code = "FORBIDDEN"
		} else if m.StatusCode == 404 {
			code = "NOT_FOUND"
		} else if m.StatusCode >= 500 {
			code = "SERVER_ERROR"
		}

		err := apperrors.New(category, code, m.Message).
			WithContext("statusCode", m.StatusCode).
			WithContext("errorCode", m.ErrorCode)

		if m.Details != "" {
			err = err.WithDetails(m.Details)
		}

		// Mark as recoverable for most API errors
		if m.StatusCode != 401 && m.StatusCode != 403 {
			err = err.AsRecoverable()
		}

		return err

	default:
		return nil
	}
}

// UpdateErrorState updates the error state in the app state
func (h *ErrorHandler) UpdateErrorState(state *model.AppState, err *apperrors.ArgonautError) {
	if state.ErrorState == nil {
		state.ErrorState = &model.ErrorState{
			History: make([]apperrors.ArgonautError, 0),
		}
	}

	// Set current error
	state.ErrorState.Current = err

	// Add to history
	if err != nil {
		state.ErrorState.History = append(state.ErrorState.History, *err)

		// Limit history size
		maxHistory := 20
		if len(state.ErrorState.History) > maxHistory {
			state.ErrorState.History = state.ErrorState.History[1:]
		}

		// Set auto-hide time for low severity errors
		if err.Severity == apperrors.SeverityLow {
			autoHide := time.Now().Add(5 * time.Second)
			state.ErrorState.AutoHideAt = &autoHide
		}
	}
}

// ShouldHideError checks if an error should be automatically hidden
func (h *ErrorHandler) ShouldHideError(state *model.ErrorState) bool {
	if state == nil || state.AutoHideAt == nil {
		return false
	}

	return time.Now().After(*state.AutoHideAt)
}

// ClearError clears the current error from the state
func (h *ErrorHandler) ClearError(state *model.AppState) {
	if state.ErrorState != nil {
		state.ErrorState.Current = nil
		state.ErrorState.AutoHideAt = nil
	}

	// Also clear legacy error for compatibility
	state.CurrentError = nil
}

// IncrementRetryCount increments the retry count for the current error
func (h *ErrorHandler) IncrementRetryCount(state *model.ErrorState) {
	if state != nil {
		state.RetryCount++
		now := time.Now()
		state.LastRetryAt = &now
	}
}

// GetErrorDisplayInfo returns formatted error information for display
func (h *ErrorHandler) GetErrorDisplayInfo(err *apperrors.ArgonautError) ErrorDisplayInfo {
	if err == nil {
		return ErrorDisplayInfo{}
	}

	info := ErrorDisplayInfo{
		Title:       string(err.Category),
		Message:     err.Message,
		Details:     err.Details,
		UserAction:  err.UserAction,
		Recoverable: err.Recoverable,
		Severity:    string(err.Severity),
	}

	// Format title based on category
	switch err.Category {
	case apperrors.ErrorAuth:
		info.Title = "Authentication Required"
		info.Icon = "🔐"
	case apperrors.ErrorNetwork:
		info.Title = "Network Error"
		info.Icon = "🌐"
	case apperrors.ErrorAPI:
		info.Title = "API Error"
		info.Icon = "⚠️"
	case apperrors.ErrorTimeout:
		info.Title = "Timeout"
		info.Icon = "⏱️"
	case apperrors.ErrorValidation:
		info.Title = "Validation Error"
		info.Icon = "❌"
	case apperrors.ErrorConfig:
		info.Title = "Configuration Error"
		info.Icon = "⚙️"
	default:
		info.Title = "Error"
		info.Icon = "❌"
	}

	return info
}

// ErrorDisplayInfo holds formatted error information for display
type ErrorDisplayInfo struct {
	Title       string `json:"title"`
	Message     string `json:"message"`
	Details     string `json:"details,omitempty"`
	UserAction  string `json:"userAction,omitempty"`
	Recoverable bool   `json:"recoverable"`
	Severity    string `json:"severity"`
	Icon        string `json:"icon"`
}

// CreateRetryCommand creates a tea.Cmd for retrying an operation
func (h *ErrorHandler) CreateRetryCommand(operation string, context map[string]interface{}, attempt int) tea.Cmd {
	return func() tea.Msg {
		return model.RetryOperationMsg{
			Operation: operation,
			Context:   context,
			Attempt:   attempt,
		}
	}
}

// CreateAutoHideCommand creates a tea.Cmd for auto-hiding errors
func (h *ErrorHandler) CreateAutoHideCommand(delay time.Duration) tea.Cmd {
	return tea.Tick(delay, func(time.Time) tea.Msg {
		return AutoHideErrorMsg{}
	})
}

// AutoHideErrorMsg triggers automatic hiding of errors
type AutoHideErrorMsg struct{}

// Default TUI error handler instance
var defaultTUIHandler *ErrorHandler

// GetDefaultTUIHandler returns the default TUI error handler
func GetDefaultTUIHandler() *ErrorHandler {
	if defaultTUIHandler == nil {
		handler, err := NewErrorHandler()
		if err != nil {
			// Fallback to basic handler
			handler = &ErrorHandler{
				handler: apperrors.GetDefaultHandler(),
			}
		}
		defaultTUIHandler = handler
	}
	return defaultTUIHandler
}

// Package-level convenience functions

// HandleTUIError handles an error and returns TUI messages
func HandleTUIError(err *apperrors.ArgonautError) []tea.Msg {
	return GetDefaultTUIHandler().HandleError(err)
}

// ConvertError converts legacy error messages to structured errors
func ConvertError(msg interface{}) *apperrors.ArgonautError {
	return GetDefaultTUIHandler().ConvertLegacyError(msg)
}

// UpdateAppErrorState updates error state in app state
func UpdateAppErrorState(state *model.AppState, err *apperrors.ArgonautError) {
	GetDefaultTUIHandler().UpdateErrorState(state, err)
}
</file>

<file path="pkg/api/applications.go">
package api

import (
	"bufio"
	"context"
	"encoding/json"
	"fmt"
	"net/url"
	"strings"
	"time"

	"github.com/darksworm/argonaut/pkg/model"
)

// ArgoApplication represents an ArgoCD application from the API
type ArgoApplication struct {
	Metadata struct {
		Name      string `json:"name"`
		Namespace string `json:"namespace,omitempty"`
	} `json:"metadata"`
	Spec struct {
		Project string `json:"project,omitempty"`
		// Single source (legacy/traditional)
		Source  *struct {
			RepoURL        string `json:"repoURL,omitempty"`
			Path           string `json:"path,omitempty"`
			TargetRevision string `json:"targetRevision,omitempty"`
		} `json:"source,omitempty"`
		// Multiple sources (newer multi-source support)
		Sources []struct {
			RepoURL        string `json:"repoURL,omitempty"`
			Path           string `json:"path,omitempty"`
			TargetRevision string `json:"targetRevision,omitempty"`
		} `json:"sources,omitempty"`
		Destination struct {
			Name      string `json:"name,omitempty"`
			Server    string `json:"server,omitempty"`
			Namespace string `json:"namespace,omitempty"`
		} `json:"destination"`
	} `json:"spec"`
	Status struct {
		Sync struct {
			Status     string    `json:"status,omitempty"`
			ComparedTo struct {
				Source *struct {
					RepoURL        string `json:"repoURL,omitempty"`
					Path           string `json:"path,omitempty"`
					TargetRevision string `json:"targetRevision,omitempty"`
				} `json:"source,omitempty"`
				Sources []struct {
					RepoURL        string `json:"repoURL,omitempty"`
					Path           string `json:"path,omitempty"`
					TargetRevision string `json:"targetRevision,omitempty"`
				} `json:"sources,omitempty"`
			} `json:"comparedTo"`
			Revision  string   `json:"revision,omitempty"`
			Revisions []string `json:"revisions,omitempty"`
		} `json:"sync"`
		Health struct {
			Status  string `json:"status,omitempty"`
			Message string `json:"message,omitempty"`
		} `json:"health"`
		OperationState struct {
			Phase     string    `json:"phase,omitempty"`
			StartedAt time.Time `json:"startedAt,omitempty"`
			FinishedAt time.Time `json:"finishedAt,omitempty"`
		} `json:"operationState,omitempty"`
		History []DeploymentHistory `json:"history,omitempty"`
	} `json:"status"`
}

// ApplicationWatchEvent represents an event from the watch stream
type ApplicationWatchEvent struct {
	Type        string          `json:"type"`
	Application ArgoApplication `json:"application"`
}

// WatchEventResult wraps the watch event in the expected format
type WatchEventResult struct {
	Result ApplicationWatchEvent `json:"result"`
}

// ListApplicationsResponse represents the response from listing applications
type ListApplicationsResponse struct {
    Items []ArgoApplication `json:"items"`
}

// DeploymentHistory represents a deployment history entry from ArgoCD API
type DeploymentHistory struct {
	ID         int        `json:"id"`
	Revision   string     `json:"revision"`
	DeployedAt time.Time  `json:"deployedAt"`
	Source     *struct {
		RepoURL        string `json:"repoURL,omitempty"`
		Path           string `json:"path,omitempty"`
		TargetRevision string `json:"targetRevision,omitempty"`
	} `json:"source,omitempty"`
}

// RevisionMetadataResponse represents git metadata response from ArgoCD API
type RevisionMetadataResponse struct {
	Author  string    `json:"author"`
	Date    time.Time `json:"date"`
	Message string    `json:"message"`
	Tags    []string  `json:"tags,omitempty"`
}

// ManagedResourceDiff represents ArgoCD managed resource diff item
type ManagedResourceDiff struct {
    Kind        string `json:"kind"`
    Namespace   string `json:"namespace"`
    Name        string `json:"name"`
    TargetState string `json:"targetState,omitempty"`
    LiveState   string `json:"liveState,omitempty"`
}

// ManagedResourcesResponse represents response for managed resources
type ManagedResourcesResponse struct {
    Items []ManagedResourceDiff `json:"items"`
}

// ApplicationService provides ArgoCD application operations
type ApplicationService struct {
    client *Client
}

// NewApplicationService creates a new application service
func NewApplicationService(server *model.Server) *ApplicationService {
	return &ApplicationService{
		client: NewClient(server),
	}
}

// ListApplications retrieves all applications from ArgoCD
func (s *ApplicationService) ListApplications(ctx context.Context) ([]model.App, error) {
    data, err := s.client.Get(ctx, "/api/v1/applications")
    if err != nil {
        return nil, fmt.Errorf("failed to list applications: %w", err)
    }

    // First, try to parse as { items: [...] }
    var withItems struct{
        Items []json.RawMessage `json:"items"`
    }
    if err := json.Unmarshal(data, &withItems); err != nil {
        return nil, fmt.Errorf("failed to parse applications response: %w", err)
    }

    var rawItems []json.RawMessage
    if len(withItems.Items) > 0 {
        rawItems = withItems.Items
    } else {
        // Some servers may return a bare array instead of an object with items
        if err := json.Unmarshal(data, &rawItems); err != nil {
            return nil, fmt.Errorf("failed to parse applications array: %w", err)
        }
    }

    apps := make([]model.App, 0, len(rawItems))
    for _, raw := range rawItems {
        // Unmarshal into our typed struct first
        var argoApp ArgoApplication
        if err := json.Unmarshal(raw, &argoApp); err != nil {
            // Skip malformed entry
            continue
        }

        app := s.ConvertToApp(argoApp)

        // Fallback: if sync/health are empty, extract directly from raw JSON
        if app.Sync == "" || app.Health == "" || app.Sync == "Unknown" || app.Health == "Unknown" {
            var root map[string]interface{}
            if err := json.Unmarshal(raw, &root); err == nil {
                if sMap, ok := root["status"].(map[string]interface{}); ok {
                    if app.Sync == "" || app.Sync == "Unknown" {
                        if syncMap, ok := sMap["sync"].(map[string]interface{}); ok {
                            if v, ok := syncMap["status"].(string); ok && v != "" {
                                app.Sync = v
                            }
                        }
                    }
                    if app.Health == "" || app.Health == "Unknown" {
                        if healthMap, ok := sMap["health"].(map[string]interface{}); ok {
                            if v, ok := healthMap["status"].(string); ok && v != "" {
                                app.Health = v
                            }
                        }
                    }
                }
            }
            if app.Sync == "" { app.Sync = "Unknown" }
            if app.Health == "" { app.Health = "Unknown" }
        }

        apps = append(apps, app)
    }

    return apps, nil
}

// GetManagedResourceDiffs fetches managed resource diffs for an application
func (s *ApplicationService) GetManagedResourceDiffs(ctx context.Context, appName string) ([]ManagedResourceDiff, error) {
    if appName == "" {
        return nil, fmt.Errorf("application name is required")
    }
    path := fmt.Sprintf("/api/v1/applications/%s/managed-resources", url.PathEscape(appName))
    data, err := s.client.Get(ctx, path)
    if err != nil {
        return nil, fmt.Errorf("failed to get managed resources: %w", err)
    }

    // Accept both {items:[...]} and bare array
    var withItems ManagedResourcesResponse
    if err := json.Unmarshal(data, &withItems); err == nil && len(withItems.Items) > 0 {
        return withItems.Items, nil
    }
    var arr []ManagedResourceDiff
    if err := json.Unmarshal(data, &arr); err == nil {
        return arr, nil
    }
    return []ManagedResourceDiff{}, nil
}

// SyncApplication triggers a sync for the specified application
func (s *ApplicationService) SyncApplication(ctx context.Context, appName string, opts *SyncOptions) error {
	if opts == nil {
		opts = &SyncOptions{}
	}

	reqBody := map[string]interface{}{
		"prune":        opts.Prune,
		"dryRun":       opts.DryRun,
		"appNamespace": opts.AppNamespace,
	}

	path := fmt.Sprintf("/api/v1/applications/%s/sync", url.PathEscape(appName))
	if opts.AppNamespace != "" {
		path += "?appNamespace=" + url.QueryEscape(opts.AppNamespace)
	}

	_, err := s.client.Post(ctx, path, reqBody)
	if err != nil {
		return fmt.Errorf("failed to sync application %s: %w", appName, err)
	}

	return nil
}

// WatchApplications starts watching for application changes
func (s *ApplicationService) WatchApplications(ctx context.Context, eventChan chan<- ApplicationWatchEvent) error {
	stream, err := s.client.Stream(ctx, "/api/v1/stream/applications")
	if err != nil {
		return fmt.Errorf("failed to start watch stream: %w", err)
	}
	defer stream.Close()

	scanner := bufio.NewScanner(stream)
	for scanner.Scan() {
		if ctx.Err() != nil {
			return ctx.Err()
		}

		line := strings.TrimSpace(scanner.Text())
		if line == "" {
			continue
		}

		var eventResult WatchEventResult
		if err := json.Unmarshal([]byte(line), &eventResult); err != nil {
			// Skip malformed lines
			continue
		}

		select {
		case eventChan <- eventResult.Result:
		case <-ctx.Done():
			return ctx.Err()
		}
	}

	if err := scanner.Err(); err != nil {
		return fmt.Errorf("stream scanning error: %w", err)
	}

	return nil
}

// SyncOptions represents options for syncing an application
type SyncOptions struct {
	Prune        bool   `json:"prune,omitempty"`
	DryRun       bool   `json:"dryRun,omitempty"`
	AppNamespace string `json:"appNamespace,omitempty"`
}

// ConvertToApp converts an ArgoApplication to our model.App
func (s *ApplicationService) ConvertToApp(argoApp ArgoApplication) model.App {
	app := model.App{
		Name:   argoApp.Metadata.Name,
		Sync:   argoApp.Status.Sync.Status,
		Health: argoApp.Status.Health.Status,
	}

	// Set optional fields
	if argoApp.Spec.Project != "" {
		app.Project = &argoApp.Spec.Project
	}

	if argoApp.Metadata.Namespace != "" {
		app.AppNamespace = &argoApp.Metadata.Namespace
	}

	if argoApp.Spec.Destination.Namespace != "" {
		app.Namespace = &argoApp.Spec.Destination.Namespace
	}


	// Extract cluster info preferring destination.name, else from destination.server host
	if argoApp.Spec.Destination.Name != "" || argoApp.Spec.Destination.Server != "" {
		var id string
		var label string
		if argoApp.Spec.Destination.Name != "" {
			id = argoApp.Spec.Destination.Name
			label = id
		} else {
			server := argoApp.Spec.Destination.Server
			if server == "https://kubernetes.default.svc" {
				id = "in-cluster"
				label = id
			} else {
				if u, err := url.Parse(server); err == nil && u.Host != "" {
					id = u.Host
					label = u.Host
				} else {
					id = server
					label = server
				}
			}
		}
		app.ClusterID = &id
		app.ClusterLabel = &label
	}

	// Handle sync timestamp
	if !argoApp.Status.OperationState.FinishedAt.IsZero() {
		app.LastSyncAt = &argoApp.Status.OperationState.FinishedAt
	} else if !argoApp.Status.OperationState.StartedAt.IsZero() {
		app.LastSyncAt = &argoApp.Status.OperationState.StartedAt
	}

	// Normalize status values to match TypeScript app
	if app.Sync == "" {
		app.Sync = "Unknown"
	}
	if app.Health == "" {
		app.Health = "Unknown"
	}

	return app
}

// GetPrimaryRevision returns the primary revision with fallback logic
// Mimics TypeScript logic: revision ?? revisions?.[0] ?? ''
func GetPrimaryRevision(syncStatus struct {
	Revision  string   `json:"revision,omitempty"`
	Revisions []string `json:"revisions,omitempty"`
}) string {
	if syncStatus.Revision != "" {
		return syncStatus.Revision
	}
	if len(syncStatus.Revisions) > 0 {
		return syncStatus.Revisions[0]
	}
	return ""
}

// HasMultipleSources returns true if the application uses multiple sources
func (app *ArgoApplication) HasMultipleSources() bool {
	return len(app.Spec.Sources) > 0
}

// GetPrimarySources returns either the single source or the first source from multiple sources
func (app *ArgoApplication) GetPrimarySource() *struct {
	RepoURL        string `json:"repoURL,omitempty"`
	Path           string `json:"path,omitempty"`
	TargetRevision string `json:"targetRevision,omitempty"`
} {
	if app.Spec.Source != nil {
		return app.Spec.Source
	}
	if len(app.Spec.Sources) > 0 {
		return &app.Spec.Sources[0]
	}
	return nil
}

// ResourceNode represents a Kubernetes resource from ArgoCD API
type ResourceNode struct {
	Kind        string                 `json:"kind"`
	Name        string                 `json:"name"`
	Namespace   *string                `json:"namespace,omitempty"`
	Version     string                 `json:"version"`
	Group       string                 `json:"group"`
	UID         string                 `json:"uid"`
	Health      *ResourceHealth        `json:"health,omitempty"`
	Status      string                 `json:"status"`
	NetworkingInfo *NetworkingInfo     `json:"networkingInfo,omitempty"`
	ResourceRef ResourceRef            `json:"resourceRef"`
	ParentRefs  []ResourceRef          `json:"parentRefs,omitempty"`
	Info        []ResourceInfo         `json:"info,omitempty"`
	CreatedAt   *time.Time            `json:"createdAt,omitempty"`
}

// ResourceHealth represents the health status from ArgoCD API
type ResourceHealth struct {
	Status  *string `json:"status,omitempty"`
	Message *string `json:"message,omitempty"`
}

// NetworkingInfo represents networking information from ArgoCD API
type NetworkingInfo struct {
	TargetLabels map[string]string   `json:"targetLabels,omitempty"`
	TargetRefs   []ResourceRef       `json:"targetRefs,omitempty"`
	Labels       map[string]string   `json:"labels,omitempty"`
	Ingress      []IngressInfo       `json:"ingress,omitempty"`
}

// IngressInfo represents ingress information from ArgoCD API
type IngressInfo struct {
	Hostname string `json:"hostname"`
	IP       string `json:"ip"`
}

// ResourceRef represents a reference to a Kubernetes resource from ArgoCD API
type ResourceRef struct {
	Kind      string  `json:"kind"`
	Name      string  `json:"name"`
	Namespace *string `json:"namespace,omitempty"`
	Group     string  `json:"group"`
	Version   string  `json:"version"`
	UID       string  `json:"uid"`
}

// ResourceInfo represents additional information about a resource from ArgoCD API
type ResourceInfo struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// ResourceTree represents the resource tree response from ArgoCD API
type ResourceTree struct {
    Nodes []ResourceNode `json:"nodes"`
}

// GetResourceTree retrieves the resource tree for an application
func (s *ApplicationService) GetResourceTree(ctx context.Context, appName, appNamespace string) (*ResourceTree, error) {
	path := fmt.Sprintf("/api/v1/applications/%s/resource-tree", url.PathEscape(appName))
	if appNamespace != "" {
		path += "?appNamespace=" + url.QueryEscape(appNamespace)
	}

	resp, err := s.client.Get(ctx, path)
	if err != nil {
		return nil, fmt.Errorf("failed to get resource tree for application %s: %w", appName, err)
	}

	var tree ResourceTree
	if err := json.Unmarshal(resp, &tree); err != nil {
		return nil, fmt.Errorf("failed to decode resource tree response: %w", err)
	}

	return &tree, nil
}

// ResourceTreeStreamResult wraps streaming responses for resource tree
type ResourceTreeStreamResult struct {
    Result ResourceTree `json:"result"`
}

// WatchResourceTree starts a streaming watch for an application's resource tree
func (s *ApplicationService) WatchResourceTree(ctx context.Context, appName, appNamespace string, out chan<- ResourceTree) error {
    if appName == "" {
        return fmt.Errorf("application name is required")
    }
    path := fmt.Sprintf("/api/v1/stream/applications/%s/resource-tree", url.PathEscape(appName))
    if appNamespace != "" {
        path += "?appNamespace=" + url.QueryEscape(appNamespace)
    }
    stream, err := s.client.Stream(ctx, path)
    if err != nil {
        return fmt.Errorf("failed to start resource tree watch: %w", err)
    }
    defer stream.Close()

    scanner := bufio.NewScanner(stream)
    for scanner.Scan() {
        if ctx.Err() != nil {
            return ctx.Err()
        }
        line := strings.TrimSpace(scanner.Text())
        if line == "" { continue }
        var res ResourceTreeStreamResult
        if err := json.Unmarshal([]byte(line), &res); err != nil {
            continue
        }
        select {
        case out <- res.Result:
        case <-ctx.Done():
            return ctx.Err()
        }
    }
    if err := scanner.Err(); err != nil {
        return fmt.Errorf("stream scanning error: %w", err)
    }
    return nil
}

// GetUserInfo validates user authentication by checking session info
func (s *ApplicationService) GetUserInfo(ctx context.Context) error {
	resp, err := s.client.Get(ctx, "/api/v1/session/userinfo")
	if err != nil {
		return fmt.Errorf("failed to get user info: %w", err)
	}

	// We don't need to parse the response, just verify it's successful
	// The existence of a successful response indicates the user is authenticated
	_ = resp // Acknowledge we received the response

	return nil
}

// GetApplication fetches a single application with full details including history
func (s *ApplicationService) GetApplication(ctx context.Context, name string, appNamespace *string) (*ArgoApplication, error) {
	endpoint := fmt.Sprintf("/api/v1/applications/%s", name)
	if appNamespace != nil && *appNamespace != "" {
		endpoint += "?appNamespace=" + url.QueryEscape(*appNamespace)
	}

	resp, err := s.client.Get(ctx, endpoint)
	if err != nil {
		return nil, fmt.Errorf("failed to get application %s: %w", name, err)
	}

	var app ArgoApplication
	if err := json.Unmarshal(resp, &app); err != nil {
		return nil, fmt.Errorf("failed to decode application response: %w", err)
	}

	return &app, nil
}

// GetRevisionMetadata fetches git metadata for a specific revision
func (s *ApplicationService) GetRevisionMetadata(ctx context.Context, name string, revision string, appNamespace *string) (*model.RevisionMetadata, error) {
	endpoint := fmt.Sprintf("/api/v1/applications/%s/revisions/%s/metadata", name, revision)
	if appNamespace != nil && *appNamespace != "" {
		endpoint += "?appNamespace=" + url.QueryEscape(*appNamespace)
	}

	resp, err := s.client.Get(ctx, endpoint)
	if err != nil {
		return nil, fmt.Errorf("failed to get revision metadata for %s@%s: %w", name, revision, err)
	}

	var metadata RevisionMetadataResponse
	if err := json.Unmarshal(resp, &metadata); err != nil {
		return nil, fmt.Errorf("failed to decode revision metadata response: %w", err)
	}

	return &model.RevisionMetadata{
		Author:  metadata.Author,
		Date:    metadata.Date,
		Message: metadata.Message,
		Tags:    metadata.Tags,
	}, nil
}

// RollbackApplication performs a rollback operation
func (s *ApplicationService) RollbackApplication(ctx context.Context, request model.RollbackRequest) error {
	endpoint := fmt.Sprintf("/api/v1/applications/%s/rollback", request.Name)
	if request.AppNamespace != nil && *request.AppNamespace != "" {
		endpoint += "?appNamespace=" + url.QueryEscape(*request.AppNamespace)
	}

	body := map[string]interface{}{
		"id":   request.ID,
		"name": request.Name,
	}
	
	if request.DryRun {
		body["dryRun"] = true
	}
	if request.Prune {
		body["prune"] = true
	}
	if request.AppNamespace != nil {
		body["appNamespace"] = *request.AppNamespace
	}

    // Pass the structured body directly; the client marshals it to JSON.
    _, err := s.client.Post(ctx, endpoint, body)
    if err != nil {
        return fmt.Errorf("failed to rollback application %s to deployment %d: %w", request.Name, request.ID, err)
    }

	return nil
}

// ConvertDeploymentHistoryToRollbackRows converts ArgoCD deployment history to rollback rows
func ConvertDeploymentHistoryToRollbackRows(history []DeploymentHistory) []model.RollbackRow {
	rows := make([]model.RollbackRow, 0, len(history))
	
	for _, deployment := range history {
		row := model.RollbackRow{
			ID:         deployment.ID,
			Revision:   deployment.Revision,
			DeployedAt: &deployment.DeployedAt,
			Author:     nil, // Will be loaded asynchronously
			Date:       nil, // Will be loaded asynchronously
			Message:    nil, // Will be loaded asynchronously
			MetaError:  nil,
		}
		rows = append(rows, row)
	}
	
	return rows
}
</file>

<file path="pkg/context/timeouts.go">
package context

import (
	"context"
	"fmt"
	"time"

	apperrors "github.com/darksworm/argonaut/pkg/errors"
)

// TimeoutConfig holds timeout configuration for different operations
type TimeoutConfig struct {
	Default    time.Duration
	API        time.Duration
	Stream     time.Duration
	Auth       time.Duration
	Sync       time.Duration
	Resource   time.Duration
	UI         time.Duration
}

// DefaultTimeouts provides sensible defaults for different operation types
var DefaultTimeouts = TimeoutConfig{
	Default:  5 * time.Second,   // Most operations should be fast
	API:      3 * time.Second,   // API calls should be quick
	Stream:   0,                 // No timeout for streams (handled by parent context)
	Auth:     5 * time.Second,   // Auth should be reasonably fast
	Sync:     10 * time.Second,  // Sync operations - max 10 seconds
	Resource: 3 * time.Second,   // Resource queries should be fast
	UI:       2 * time.Second,   // UI operations must be very fast
}

// OperationType represents different types of operations that need timeouts
type OperationType string

const (
	OpDefault  OperationType = "default"
	OpAPI      OperationType = "api"
	OpStream   OperationType = "stream"
	OpAuth     OperationType = "auth"
	OpSync     OperationType = "sync"
	OpResource OperationType = "resource"
	OpUI       OperationType = "ui"
)

// WithTimeout creates a context with timeout based on operation type
func WithTimeout(parent context.Context, opType OperationType) (context.Context, context.CancelFunc) {
	timeout := getTimeoutForOperation(opType)
	if timeout == 0 {
		// For operations with no timeout (like streams), return the parent context
		// but still provide a cancel function for cleanup
		ctx, cancel := context.WithCancel(parent)
		return ctx, cancel
	}
	return context.WithTimeout(parent, timeout)
}

// WithDeadline creates a context with a specific deadline
func WithDeadline(parent context.Context, deadline time.Time) (context.Context, context.CancelFunc) {
	return context.WithDeadline(parent, deadline)
}

// WithCancel creates a cancellable context
func WithCancel(parent context.Context) (context.Context, context.CancelFunc) {
	return context.WithCancel(parent)
}

// getTimeoutForOperation returns the appropriate timeout for the given operation type
func getTimeoutForOperation(opType OperationType) time.Duration {
	switch opType {
	case OpAPI:
		return DefaultTimeouts.API
	case OpStream:
		return DefaultTimeouts.Stream
	case OpAuth:
		return DefaultTimeouts.Auth
	case OpSync:
		return DefaultTimeouts.Sync
	case OpResource:
		return DefaultTimeouts.Resource
	case OpUI:
		return DefaultTimeouts.UI
	default:
		return DefaultTimeouts.Default
	}
}

// HandleTimeout converts a context timeout error to a structured error
func HandleTimeout(ctx context.Context, opType OperationType) *apperrors.ArgonautError {
	if ctx.Err() == context.DeadlineExceeded {
		return apperrors.TimeoutError(
			"OPERATION_TIMEOUT",
			fmt.Sprintf("Operation timed out after %v", getTimeoutForOperation(opType)),
		).WithDetails(fmt.Sprintf("Operation type: %s", opType))
	}

	if ctx.Err() == context.Canceled {
		return apperrors.New(
			apperrors.ErrorInternal,
			"OPERATION_CANCELED",
			"Operation was canceled",
		).WithDetails(fmt.Sprintf("Operation type: %s", opType))
	}

	return nil
}

// IsTimeout checks if an error is a timeout error
func IsTimeout(err error) bool {
	if err == context.DeadlineExceeded {
		return true
	}

	if argErr, ok := err.(*apperrors.ArgonautError); ok {
		return argErr.IsCategory(apperrors.ErrorTimeout)
	}

	return false
}

// IsCanceled checks if an error is a cancellation error
func IsCanceled(err error) bool {
	if err == context.Canceled {
		return true
	}

	if argErr, ok := err.(*apperrors.ArgonautError); ok {
		return argErr.IsCode("OPERATION_CANCELED")
	}

	return false
}

// WithTimeoutAndRetry creates a context with timeout and provides retry information
type RetryableContext struct {
	Context   context.Context
	Cancel    context.CancelFunc
	Attempt   int
	MaxRetries int
	OpType    OperationType
}

// NewRetryableContext creates a new retryable context
func NewRetryableContext(parent context.Context, opType OperationType, maxRetries int) *RetryableContext {
	ctx, cancel := WithTimeout(parent, opType)
	return &RetryableContext{
		Context:   ctx,
		Cancel:    cancel,
		Attempt:   1,
		MaxRetries: maxRetries,
		OpType:    opType,
	}
}

// ShouldRetry determines if the operation should be retried based on the error
func (rc *RetryableContext) ShouldRetry(err error) bool {
	if rc.Attempt >= rc.MaxRetries {
		return false
	}

	// Don't retry if the context was explicitly canceled
	if IsCanceled(err) {
		return false
	}

	// Retry on timeout errors
	if IsTimeout(err) {
		return true
	}

	// Let the error handler determine if it should retry
	if argErr, ok := err.(*apperrors.ArgonautError); ok {
		handler := apperrors.GetDefaultHandler()
		return handler.ShouldRetry(argErr)
	}

	return false
}

// NextAttempt prepares the context for the next retry attempt
func (rc *RetryableContext) NextAttempt() {
	// Cancel the current context
	rc.Cancel()

	// Create new context for next attempt
	rc.Attempt++
	ctx, cancel := WithTimeout(context.Background(), rc.OpType)
	rc.Context = ctx
	rc.Cancel = cancel
}

// Close cancels the context and cleans up resources
func (rc *RetryableContext) Close() {
	rc.Cancel()
}

// Convenience functions for common timeout patterns

// WithAPITimeout creates a context specifically for API operations
func WithAPITimeout(parent context.Context) (context.Context, context.CancelFunc) {
	return WithTimeout(parent, OpAPI)
}

// WithAuthTimeout creates a context specifically for authentication operations
func WithAuthTimeout(parent context.Context) (context.Context, context.CancelFunc) {
	return WithTimeout(parent, OpAuth)
}

// WithSyncTimeout creates a context specifically for sync operations
func WithSyncTimeout(parent context.Context) (context.Context, context.CancelFunc) {
	return WithTimeout(parent, OpSync)
}

// WithResourceTimeout creates a context specifically for resource operations
func WithResourceTimeout(parent context.Context) (context.Context, context.CancelFunc) {
	return WithTimeout(parent, OpResource)
}

// WithUITimeout creates a context specifically for UI operations
func WithUITimeout(parent context.Context) (context.Context, context.CancelFunc) {
	return WithTimeout(parent, OpUI)
}
</file>

<file path="pkg/errors/types.go">
package errors

import (
	"fmt"
	"time"
)

// ErrorCategory represents different types of errors that can occur
type ErrorCategory string

const (
	ErrorNetwork     ErrorCategory = "network"
	ErrorAuth        ErrorCategory = "auth"
	ErrorValidation  ErrorCategory = "validation"
	ErrorConfig      ErrorCategory = "config"
	ErrorAPI         ErrorCategory = "api"
	ErrorUI          ErrorCategory = "ui"
	ErrorResource    ErrorCategory = "resource"
	ErrorTimeout     ErrorCategory = "timeout"
	ErrorPermission  ErrorCategory = "permission"
	ErrorUnavailable ErrorCategory = "unavailable"
	ErrorInternal    ErrorCategory = "internal"
)

// ErrorSeverity represents the severity level of an error
type ErrorSeverity string

const (
	SeverityLow      ErrorSeverity = "low"
	SeverityMedium   ErrorSeverity = "medium"
	SeverityHigh     ErrorSeverity = "high"
	SeverityCritical ErrorSeverity = "critical"
)

// ArgonautError represents a structured error with comprehensive metadata
type ArgonautError struct {
	Category    ErrorCategory `json:"category"`
	Severity    ErrorSeverity `json:"severity"`
	Code        string        `json:"code"`
	Message     string        `json:"message"`
	Details     string        `json:"details,omitempty"`
	Cause       error         `json:"cause,omitempty"`
	Recoverable bool          `json:"recoverable"`
	UserAction  string        `json:"userAction,omitempty"`
	Timestamp   time.Time     `json:"timestamp"`
	Context     map[string]interface{} `json:"context,omitempty"`
}

// Error implements the error interface
func (e *ArgonautError) Error() string {
	if e.Details != "" {
		return fmt.Sprintf("[%s:%s] %s: %s", e.Category, e.Code, e.Message, e.Details)
	}
	return fmt.Sprintf("[%s:%s] %s", e.Category, e.Code, e.Message)
}

// Unwrap implements the error unwrapping interface
func (e *ArgonautError) Unwrap() error {
	return e.Cause
}

// Is implements error comparison for error chains
func (e *ArgonautError) Is(target error) bool {
	if t, ok := target.(*ArgonautError); ok {
		return e.Category == t.Category && e.Code == t.Code
	}
	return false
}

// WithContext adds contextual information to the error
func (e *ArgonautError) WithContext(key string, value interface{}) *ArgonautError {
	if e.Context == nil {
		e.Context = make(map[string]interface{})
	}
	e.Context[key] = value
	return e
}

// WithCause sets the underlying cause of this error
func (e *ArgonautError) WithCause(cause error) *ArgonautError {
	e.Cause = cause
	return e
}

// WithUserAction sets a suggested user action for resolving the error
func (e *ArgonautError) WithUserAction(action string) *ArgonautError {
	e.UserAction = action
	return e
}

// New creates a new ArgonautError with the specified parameters
func New(category ErrorCategory, code, message string) *ArgonautError {
	return &ArgonautError{
		Category:    category,
		Severity:    SeverityMedium, // Default severity
		Code:        code,
		Message:     message,
		Recoverable: false, // Default to non-recoverable
		Timestamp:   time.Now(),
	}
}

// Wrap creates a new ArgonautError that wraps an existing error
func Wrap(err error, category ErrorCategory, code, message string) *ArgonautError {
	return &ArgonautError{
		Category:    category,
		Severity:    SeverityMedium,
		Code:        code,
		Message:     message,
		Cause:       err,
		Recoverable: false,
		Timestamp:   time.Now(),
	}
}

// Predefined error constructors for common scenarios

// NetworkError creates a network-related error
func NetworkError(code, message string) *ArgonautError {
	return New(ErrorNetwork, code, message).
		WithSeverity(SeverityHigh).
		AsRecoverable().
		WithUserAction("Check your network connection and try again")
}

// AuthError creates an authentication-related error
func AuthError(code, message string) *ArgonautError {
	return New(ErrorAuth, code, message).
		WithSeverity(SeverityHigh).
		WithUserAction("Please run 'argocd login' to authenticate")
}

// ValidationError creates a validation-related error
func ValidationError(code, message string) *ArgonautError {
	return New(ErrorValidation, code, message).
		WithSeverity(SeverityMedium).
		WithUserAction("Please check your input and try again")
}

// ConfigError creates a configuration-related error
func ConfigError(code, message string) *ArgonautError {
	return New(ErrorConfig, code, message).
		WithSeverity(SeverityHigh).
		WithUserAction("Please check your ArgoCD configuration")
}

// APIError creates an API-related error
func APIError(code, message string) *ArgonautError {
	return New(ErrorAPI, code, message).
		WithSeverity(SeverityMedium).
		AsRecoverable().
		WithUserAction("The operation failed. You may retry or check the ArgoCD server status")
}

// InternalError creates an internal application error
func InternalError(code, message string) *ArgonautError {
	return New(ErrorInternal, code, message).
		WithSeverity(SeverityCritical).
		WithUserAction("This appears to be an internal error. Please report this issue")
}

// TimeoutError creates a timeout-related error
func TimeoutError(code, message string) *ArgonautError {
	return New(ErrorTimeout, code, message).
		WithSeverity(SeverityMedium).
		AsRecoverable().
		WithUserAction("The operation timed out. Please try again")
}

// Helper methods for fluent error construction

// WithSeverity sets the severity level
func (e *ArgonautError) WithSeverity(severity ErrorSeverity) *ArgonautError {
	e.Severity = severity
	return e
}

// WithDetails adds additional details to the error
func (e *ArgonautError) WithDetails(details string) *ArgonautError {
	e.Details = details
	return e
}

// AsRecoverable marks the error as recoverable
func (e *ArgonautError) AsRecoverable() *ArgonautError {
	e.Recoverable = true
	return e
}

// AsNonRecoverable marks the error as non-recoverable
func (e *ArgonautError) AsNonRecoverable() *ArgonautError {
	e.Recoverable = false
	return e
}

// IsRecoverable returns true if the error can be recovered from
func (e *ArgonautError) IsRecoverable() bool {
	return e.Recoverable
}

// IsCritical returns true if the error is critical severity
func (e *ArgonautError) IsCritical() bool {
	return e.Severity == SeverityCritical
}

// IsCategory checks if the error belongs to a specific category
func (e *ArgonautError) IsCategory(category ErrorCategory) bool {
	return e.Category == category
}

// IsCode checks if the error has a specific code
func (e *ArgonautError) IsCode(code string) bool {
	return e.Code == code
}
</file>

<file path="pkg/model/types.go">
package model

import (
	"time"
)

// View represents the current view in the navigation hierarchy
type View string

const (
    ViewClusters   View = "clusters"
    ViewNamespaces View = "namespaces"
    ViewProjects   View = "projects"
    ViewApps       View = "apps"
    ViewTree       View = "tree"
)

// Mode represents the current application mode
type Mode string

const (
	ModeNormal       Mode = "normal"
	ModeLoading      Mode = "loading"
	ModeSearch       Mode = "search"
	ModeCommand      Mode = "command"
	ModeHelp         Mode = "help"
	ModeLicense      Mode = "license"
	ModeConfirmSync  Mode = "confirm-sync"
	ModeRollback     Mode = "rollback"
    ModeExternal     Mode = "external"
    ModeDiff         Mode = "diff"
    ModeResources    Mode = "resources"
	ModeAuthRequired Mode = "auth-required"
	ModeRulerLine    Mode = "rulerline"
	ModeError        Mode = "error"
	ModeConnectionError Mode = "connection-error"
	ModeLogs         Mode = "logs"
)

// App represents an ArgoCD application
type App struct {
	Name         string     `json:"name"`
	Sync         string     `json:"sync"`
	Health       string     `json:"health"`
	LastSyncAt   *time.Time `json:"lastSyncAt,omitempty"`
	Project      *string    `json:"project,omitempty"`
	ClusterID    *string    `json:"clusterId,omitempty"`
	ClusterLabel *string    `json:"clusterLabel,omitempty"`
	Namespace    *string    `json:"namespace,omitempty"`
	AppNamespace *string    `json:"appNamespace,omitempty"`
}

// Server represents an ArgoCD server configuration
type Server struct {
	BaseURL   string `json:"baseUrl"`
	Token     string `json:"token"`
	Username  string `json:"username,omitempty"`
	Password  string `json:"password,omitempty"`
	Insecure  bool   `json:"insecure,omitempty"`
}

// TerminalState represents terminal dimensions
type TerminalState struct {
	Rows int `json:"rows"`
	Cols int `json:"cols"`
}

// Helper methods for set operations using map[string]bool

// NewStringSet creates a new string set
func NewStringSet() map[string]bool {
	return make(map[string]bool)
}

// StringSetFromSlice creates a string set from a slice
func StringSetFromSlice(items []string) map[string]bool {
	set := make(map[string]bool)
	for _, item := range items {
		set[item] = true
	}
	return set
}

// StringSetToSlice converts a string set to a slice
func StringSetToSlice(set map[string]bool) []string {
	var result []string
	for key := range set {
		result = append(result, key)
	}
	return result
}

// AddToStringSet adds an item to a string set
func AddToStringSet(set map[string]bool, item string) map[string]bool {
	if set == nil {
		set = make(map[string]bool)
	}
	set[item] = true
	return set
}

// RemoveFromStringSet removes an item from a string set
func RemoveFromStringSet(set map[string]bool, item string) map[string]bool {
	if set != nil {
		delete(set, item)
	}
	return set
}

// HasInStringSet checks if an item exists in a string set
func HasInStringSet(set map[string]bool, item string) bool {
	return set != nil && set[item]
}

// ResourceNode represents a Kubernetes resource in the ArgoCD application tree
type ResourceNode struct {
	Kind        string                 `json:"kind"`
	Name        string                 `json:"name"`
	Namespace   *string                `json:"namespace,omitempty"`
	Version     string                 `json:"version"`
	Group       string                 `json:"group"`
	UID         string                 `json:"uid"`
	Health      *ResourceHealth        `json:"health,omitempty"`
	Status      string                 `json:"status"`
	NetworkingInfo *NetworkingInfo     `json:"networkingInfo,omitempty"`
	ResourceRef ResourceRef            `json:"resourceRef"`
	ParentRefs  []ResourceRef          `json:"parentRefs,omitempty"`
	Info        []ResourceInfo         `json:"info,omitempty"`
	CreatedAt   *time.Time            `json:"createdAt,omitempty"`
}

// ResourceHealth represents the health status of a resource
type ResourceHealth struct {
	Status  *string `json:"status,omitempty"`
	Message *string `json:"message,omitempty"`
}

// NetworkingInfo represents networking information for a resource
type NetworkingInfo struct {
	TargetLabels map[string]string   `json:"targetLabels,omitempty"`
	TargetRefs   []ResourceRef       `json:"targetRefs,omitempty"`
	Labels       map[string]string   `json:"labels,omitempty"`
	Ingress      []IngressInfo       `json:"ingress,omitempty"`
}

// IngressInfo represents ingress information
type IngressInfo struct {
	Hostname string `json:"hostname"`
	IP       string `json:"ip"`
}

// ResourceRef represents a reference to a Kubernetes resource
type ResourceRef struct {
	Kind      string  `json:"kind"`
	Name      string  `json:"name"`
	Namespace *string `json:"namespace,omitempty"`
	Group     string  `json:"group"`
	Version   string  `json:"version"`
	UID       string  `json:"uid"`
}

// ResourceInfo represents additional information about a resource
type ResourceInfo struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// ResourceState holds the state for resource viewing
type ResourceState struct {
	AppName   string         `json:"appName"`
	Resources []ResourceNode `json:"resources"`
	Loading   bool           `json:"loading"`
	Error     string         `json:"error"`
	Offset    int            `json:"offset"`
}

// RollbackRow represents a deployment history entry for rollback selection
type RollbackRow struct {
	ID          int        `json:"id"`          // Deployment ID
	Revision    string     `json:"revision"`    // Git SHA/revision
	DeployedAt  *time.Time `json:"deployedAt"`  // Deployment timestamp
	Author      *string    `json:"author"`      // Git author (loaded async)
	Date        *time.Time `json:"date"`        // Git commit date
	Message     *string    `json:"message"`     // Git commit message
	MetaError   *string    `json:"metaError"`   // Error loading metadata
}

// RollbackState holds the state for rollback operations
type RollbackState struct {
    AppName       string        `json:"appName"`       // App being rolled back
    AppNamespace  *string       `json:"appNamespace"`  // App namespace
    Rows          []RollbackRow `json:"rows"`          // Deployment history
    SelectedIdx   int           `json:"selectedIdx"`   // Currently selected row
    CurrentRevision string      `json:"currentRevision"` // Current deployment revision
    Loading       bool          `json:"loading"`       // Loading state
    Error         string        `json:"error"`         // Error message
    Mode          string        `json:"mode"`          // "list" or "confirm"
    Prune         bool          `json:"prune"`         // Prune option
    Watch         bool          `json:"watch"`         // Watch option after rollback
    DryRun        bool          `json:"dryRun"`        // Dry run option (not shown in confirm view)
    ConfirmSelected int         `json:"confirmSelected"` // 0 = Yes, 1 = No/Cancel
}

// RevisionMetadata represents git commit metadata for a revision
type RevisionMetadata struct {
	Author    string     `json:"author"`
	Date      time.Time  `json:"date"`
	Message   string     `json:"message"`
	Tags      []string   `json:"tags,omitempty"`
}

// RollbackRequest represents a rollback API request
type RollbackRequest struct {
	ID           int     `json:"id"`
	Name         string  `json:"name"`
	DryRun       bool    `json:"dryRun,omitempty"`
	Prune        bool    `json:"prune,omitempty"`
	AppNamespace *string `json:"appNamespace,omitempty"`
}
</file>

<file path="pkg/retry/retry.go">
package retry

import (
	"context"
	"math"
	"math/rand"
	"time"

	apperrors "github.com/darksworm/argonaut/pkg/errors"
	"github.com/darksworm/argonaut/pkg/logging"
)

// RetryConfig configures retry behavior
type RetryConfig struct {
	MaxAttempts   int                          `json:"maxAttempts"`
	InitialDelay  time.Duration                `json:"initialDelay"`
	MaxDelay      time.Duration                `json:"maxDelay"`
	Multiplier    float64                      `json:"multiplier"`
	Jitter        bool                         `json:"jitter"`
	ShouldRetry   func(*apperrors.ArgonautError) bool `json:"-"`
}

// DefaultConfig provides sensible retry defaults
var DefaultConfig = RetryConfig{
	MaxAttempts:  3,
	InitialDelay: 1 * time.Second,
	MaxDelay:     30 * time.Second,
	Multiplier:   2.0,
	Jitter:       true,
	ShouldRetry:  DefaultShouldRetry,
}

// NetworkConfig is optimized for network operations
var NetworkConfig = RetryConfig{
	MaxAttempts:  5,
	InitialDelay: 500 * time.Millisecond,
	MaxDelay:     10 * time.Second,
	Multiplier:   1.5,
	Jitter:       true,
	ShouldRetry:  NetworkShouldRetry,
}

// APIConfig is optimized for API operations
var APIConfig = RetryConfig{
	MaxAttempts:  3,
	InitialDelay: 1 * time.Second,
	MaxDelay:     15 * time.Second,
	Multiplier:   2.0,
	Jitter:       true,
	ShouldRetry:  APIShouldRetry,
}

// RetryFunc is a function that can be retried
type RetryFunc func(attempt int) error

// RetryWithBackoff executes a function with exponential backoff retry logic
func RetryWithBackoff(ctx context.Context, config RetryConfig, fn RetryFunc) error {
	logger := logging.GetDefaultLogger().WithComponent("retry")

	var lastErr error

	for attempt := 1; attempt <= config.MaxAttempts; attempt++ {
		startTime := time.Now()
		err := fn(attempt)
		duration := time.Since(startTime)

		if err == nil {
			if attempt > 1 {
				logger.Info("Operation succeeded after %d attempts (took %v)", attempt, duration)
			}
			return nil
		}

		lastErr = err

		// Convert to structured error if needed
		var argErr *apperrors.ArgonautError
		if ae, ok := err.(*apperrors.ArgonautError); ok {
			argErr = ae
		} else {
			argErr = apperrors.Wrap(err, apperrors.ErrorInternal, "RETRY_OPERATION_FAILED", "Operation failed during retry")
		}

		// Log the attempt
		logger.Warn("Attempt %d/%d failed (took %v): %s",
			attempt, config.MaxAttempts, duration, argErr.Error())

		// Check if we should retry
		if !config.ShouldRetry(argErr) {
			logger.Info("Not retrying due to error type: %s", argErr.Category)
			return argErr
		}

		// Don't sleep after the last attempt
		if attempt >= config.MaxAttempts {
			break
		}

		// Check if context is cancelled
		if ctx.Err() != nil {
			logger.Info("Context cancelled, stopping retry attempts")
			return apperrors.Wrap(ctx.Err(), apperrors.ErrorTimeout, "RETRY_CANCELLED", "Retry cancelled due to context")
		}

		// Calculate delay for next attempt
		delay := calculateDelay(attempt, config)
		logger.Debug("Waiting %v before attempt %d", delay, attempt+1)

		// Wait with context cancellation support
		select {
		case <-ctx.Done():
			return apperrors.Wrap(ctx.Err(), apperrors.ErrorTimeout, "RETRY_CANCELLED", "Retry cancelled due to context")
		case <-time.After(delay):
			// Continue to next attempt
		}
	}

	// All attempts failed
	if argErr, ok := lastErr.(*apperrors.ArgonautError); ok {
		return argErr.WithContext("retryAttempts", config.MaxAttempts)
	}

	return apperrors.Wrap(lastErr, apperrors.ErrorInternal, "RETRY_EXHAUSTED",
		"All retry attempts failed").
		WithContext("maxAttempts", config.MaxAttempts).
		WithUserAction("The operation failed after multiple attempts. Check your connection and try again")
}

// calculateDelay calculates the delay for the next retry attempt
func calculateDelay(attempt int, config RetryConfig) time.Duration {
	// Calculate exponential backoff
	delay := time.Duration(float64(config.InitialDelay) * math.Pow(config.Multiplier, float64(attempt-1)))

	// Apply maximum delay
	if delay > config.MaxDelay {
		delay = config.MaxDelay
	}

	// Apply jitter to prevent thundering herd
	if config.Jitter {
		jitter := time.Duration(rand.Float64() * float64(delay) * 0.1) // 10% jitter
		delay = delay + jitter
	}

	return delay
}

// DefaultShouldRetry is the default retry predicate
func DefaultShouldRetry(err *apperrors.ArgonautError) bool {
	if err == nil {
		return false
	}

	// Don't retry authentication or validation errors
	switch err.Category {
	case apperrors.ErrorAuth, apperrors.ErrorValidation, apperrors.ErrorPermission:
		return false
	case apperrors.ErrorNetwork, apperrors.ErrorAPI:
		return true
	case apperrors.ErrorTimeout:
		// Don't retry user-initiated timeouts - show immediately
		return err.IsCode("NETWORK_TIMEOUT")
	default:
		// Use the error's recoverable flag
		return err.Recoverable
	}
}

// NetworkShouldRetry determines if network errors should be retried
func NetworkShouldRetry(err *apperrors.ArgonautError) bool {
	if err == nil {
		return false
	}

	// Retry most network and timeout errors
	switch err.Category {
	case apperrors.ErrorNetwork:
		return true
	case apperrors.ErrorTimeout:
		// Don't retry user-initiated timeouts - show immediately
		return err.IsCode("NETWORK_TIMEOUT")
	case apperrors.ErrorAuth, apperrors.ErrorValidation, apperrors.ErrorPermission:
		return false
	case apperrors.ErrorAPI:
		// Only retry certain API errors
		return err.IsCode("CONNECTION_REFUSED") ||
			   err.IsCode("TIMEOUT") ||
			   err.IsCode("SERVICE_UNAVAILABLE") ||
			   err.IsCode("RATE_LIMITED") ||
			   err.IsCode("SERVER_ERROR")
	default:
		return err.Recoverable
	}
}

// APIShouldRetry determines if API errors should be retried
func APIShouldRetry(err *apperrors.ArgonautError) bool {
	if err == nil {
		return false
	}

	// Don't retry client errors (4xx) except for specific cases
	switch err.Category {
	case apperrors.ErrorAuth, apperrors.ErrorValidation, apperrors.ErrorPermission:
		return false
	case apperrors.ErrorNetwork:
		return true
	case apperrors.ErrorTimeout:
		// Don't retry user-initiated timeouts (REQUEST_TIMEOUT) - show immediately
		// Only retry network-level timeouts (NETWORK_TIMEOUT)
		return err.IsCode("NETWORK_TIMEOUT")
	case apperrors.ErrorAPI:
		// Retry server errors and rate limits, but not client errors
		return err.IsCode("SERVER_ERROR") ||
			   err.IsCode("RATE_LIMITED") ||
			   err.IsCode("SERVICE_UNAVAILABLE") ||
			   err.IsCode("TIMEOUT")
	default:
		return err.Recoverable
	}
}

// RetryableOperation wraps an operation with retry logic
type RetryableOperation struct {
	Name     string
	Config   RetryConfig
	Logger   logging.Logger
	Context  context.Context
}

// NewRetryableOperation creates a new retryable operation
func NewRetryableOperation(name string, config RetryConfig) *RetryableOperation {
	return &RetryableOperation{
		Name:    name,
		Config:  config,
		Logger:  logging.GetDefaultLogger().WithOperation(name),
		Context: context.Background(),
	}
}

// WithContext sets the context for the operation
func (ro *RetryableOperation) WithContext(ctx context.Context) *RetryableOperation {
	ro.Context = ctx
	return ro
}

// WithLogger sets a custom logger
func (ro *RetryableOperation) WithLogger(logger logging.Logger) *RetryableOperation {
	ro.Logger = logger
	return ro
}

// Execute executes the operation with retry logic
func (ro *RetryableOperation) Execute(fn RetryFunc) error {
	ro.Logger.Info("Starting retryable operation: %s", ro.Name)

	startTime := time.Now()
	err := RetryWithBackoff(ro.Context, ro.Config, fn)
	duration := time.Since(startTime)

	if err != nil {
		ro.Logger.Error("Operation %s failed after %v: %v", ro.Name, duration, err)
	} else {
		ro.Logger.Info("Operation %s completed successfully in %v", ro.Name, duration)
	}

	return err
}

// Convenience functions for common retry patterns

// RetryNetworkOperation retries a network operation with appropriate config
func RetryNetworkOperation(ctx context.Context, name string, fn RetryFunc) error {
	op := NewRetryableOperation(name, NetworkConfig).WithContext(ctx)
	return op.Execute(fn)
}

// RetryAPIOperation retries an API operation with appropriate config
func RetryAPIOperation(ctx context.Context, name string, fn RetryFunc) error {
	op := NewRetryableOperation(name, APIConfig).WithContext(ctx)
	return op.Execute(fn)
}

// RetryOperation retries an operation with default config
func RetryOperation(ctx context.Context, name string, fn RetryFunc) error {
	op := NewRetryableOperation(name, DefaultConfig).WithContext(ctx)
	return op.Execute(fn)
}

// Quick retry functions for immediate use

// DoWithRetry executes a function with default retry logic
func DoWithRetry(ctx context.Context, fn func() error) error {
	return RetryWithBackoff(ctx, DefaultConfig, func(attempt int) error {
		return fn()
	})
}

// DoNetworkWithRetry executes a network function with network retry logic
func DoNetworkWithRetry(ctx context.Context, fn func() error) error {
	return RetryWithBackoff(ctx, NetworkConfig, func(attempt int) error {
		return fn()
	})
}

// DoAPIWithRetry executes an API function with API retry logic
func DoAPIWithRetry(ctx context.Context, fn func() error) error {
	return RetryWithBackoff(ctx, APIConfig, func(attempt int) error {
		return fn()
	})
}
</file>

<file path="pkg/services/enhanced.go">
package services

import (
	"context"
	"encoding/json"
	"log"
	"sync"

	"github.com/darksworm/argonaut/pkg/api"
	apperrors "github.com/darksworm/argonaut/pkg/errors"
	appcontext "github.com/darksworm/argonaut/pkg/context"
	"github.com/darksworm/argonaut/pkg/model"
	"github.com/darksworm/argonaut/pkg/retry"
)

// EnhancedArgoApiService provides enhanced ArgoApiService with recovery and degradation
type EnhancedArgoApiService struct {
	appService      *api.ApplicationService
	watchCancel     context.CancelFunc
	mu              sync.RWMutex
	recoveryManager *StreamRecoveryManager
	degradationMgr  *GracefulDegradationManager
}

// NewEnhancedArgoApiService creates a new enhanced ArgoApiService implementation
func NewEnhancedArgoApiService(server *model.Server) *EnhancedArgoApiService {
	impl := &EnhancedArgoApiService{
		recoveryManager: NewStreamRecoveryManager(DefaultStreamRecoveryConfig),
		degradationMgr:  NewGracefulDegradationManager(),
	}
	if server != nil {
		impl.appService = api.NewApplicationService(server)
	}

	// Register degradation callback
	impl.degradationMgr.RegisterCallback(func(oldMode, newMode DegradationMode) {
		log.Printf("Service degradation mode changed: %s -> %s", oldMode, newMode)
	})

	return impl
}

// restartWatch is the recovery function for watch streams
func (s *EnhancedArgoApiService) restartWatch(ctx context.Context, server *model.Server, eventChan chan<- ArgoApiEvent) error {
	// This is a simplified restart - in a real implementation, this would
	// re-establish the watch connection
	apps, err := s.ListApplications(ctx, server)
	if err != nil {
		return err
	}

	eventChan <- ArgoApiEvent{
		Type: "apps-loaded",
		Apps: apps,
	}

	return nil
}

// ListApplications implements ArgoApiService.ListApplications with degradation support
func (s *EnhancedArgoApiService) ListApplications(ctx context.Context, server *model.Server) ([]model.App, error) {
	if server == nil {
		return nil, apperrors.ConfigError("SERVER_MISSING",
			"Server configuration is required").
			WithUserAction("Please run 'argocd login' to configure the server")
	}

	// Check if operation is allowed in current degradation mode
	if allowed, err := s.degradationMgr.CanPerformOperation("ListApplications"); !allowed {
		// Try to serve from cache in offline mode
		if s.degradationMgr.GetCurrentMode() == DegradationOffline {
			if cachedApps, found := s.degradationMgr.GetCachedApps(); found {
				return cachedApps, nil
			}
		}
		return nil, err
	}

	// Use the real API service with resource timeout
	if s.appService == nil {
		s.appService = api.NewApplicationService(server)
	}

	ctx, cancel := appcontext.WithResourceTimeout(ctx)
	defer cancel()

	// Use retry mechanism for network operations
	var apps []model.App
	err := retry.RetryAPIOperation(ctx, "ListApplications", func(attempt int) error {
		var opErr error
		apps, opErr = s.appService.ListApplications(ctx)
		return opErr
	})

	if err != nil {
		// Report health status
		s.degradationMgr.ReportAPIHealth(false, err)

		// Convert API errors to structured format if needed
		if argErr, ok := err.(*apperrors.ArgonautError); ok {
			return nil, argErr.WithContext("operation", "ListApplications")
		}

		return nil, apperrors.Wrap(err, apperrors.ErrorAPI, "LIST_APPS_FAILED",
			"Failed to list applications").
			WithContext("server", server.BaseURL).
			AsRecoverable().
			WithUserAction("Check your ArgoCD server connection and try again")
	}

	// Report successful operation and update cache
	s.degradationMgr.ReportAPIHealth(true, nil)
	s.degradationMgr.UpdateCache(apps, server, "")

	return apps, nil
}

// WatchApplications implements ArgoApiService.WatchApplications with stream recovery
func (s *EnhancedArgoApiService) WatchApplications(ctx context.Context, server *model.Server) (<-chan ArgoApiEvent, func(), error) {
	if server == nil {
		return nil, nil, apperrors.ConfigError("SERVER_MISSING",
			"Server configuration is required").
			WithUserAction("Please run 'argocd login' to configure the server")
	}

	// Use the real API service
	if s.appService == nil {
		s.appService = api.NewApplicationService(server)
	}

	eventChan := make(chan ArgoApiEvent, 100)
	watchCtx, cancel := appcontext.WithCancel(ctx) // No timeout for streams
	s.mu.Lock()
	s.watchCancel = cancel
	s.mu.Unlock()

	// Register stream for recovery
	streamID := "watch-applications-" + server.BaseURL
	_ = s.recoveryManager.RegisterStream(streamID, server, func(recoveryCtx context.Context) error {
		// Recovery function - restart the watch
		return s.restartWatch(recoveryCtx, server, eventChan)
	})

	// Start watching in a goroutine
	go func() {
		defer close(eventChan)
		defer s.recoveryManager.UnregisterStream(streamID)

		// Send initial status
		eventChan <- ArgoApiEvent{
			Type:   "status-change",
			Status: "Loading…",
		}

		// Send initial apps loaded event (no retry for initial watch load to avoid delays)
		apps, err := s.ListApplications(watchCtx, server)
		if err != nil {
			if isAuthError(err.Error()) {
				s.degradationMgr.ReportAuthHealth(false, err)
				eventChan <- ArgoApiEvent{
					Type:  "auth-error",
					Error: err,
				}
				eventChan <- ArgoApiEvent{
					Type:   "status-change",
					Status: "Auth required",
				}
				s.recoveryManager.ReportStreamFailure(streamID, err)
				return
			}
			s.degradationMgr.ReportAPIHealth(false, err)
			eventChan <- ArgoApiEvent{
				Type:  "api-error",
				Error: err,
			}
			eventChan <- ArgoApiEvent{
				Type:   "status-change",
				Status: "Error: " + err.Error(),
			}
			s.recoveryManager.ReportStreamFailure(streamID, err)
			return
		}

		// Report healthy stream
		s.recoveryManager.ReportStreamHealthy(streamID)

		eventChan <- ArgoApiEvent{
			Type: "apps-loaded",
			Apps: apps,
		}

		eventChan <- ArgoApiEvent{
			Type:   "status-change",
			Status: "Live",
		}

		// Start real watch stream
		s.startWatchStreamWithRecovery(watchCtx, eventChan, streamID)
	}()

	cleanup := func() {
		s.mu.Lock()
		defer s.mu.Unlock()
		if s.watchCancel != nil {
			s.watchCancel()
			s.watchCancel = nil
		}
		// Unregister stream from recovery
		s.recoveryManager.UnregisterStream(streamID)
	}

	return eventChan, cleanup, nil
}

// SyncApplication implements ArgoApiService.SyncApplication with degradation check
func (s *EnhancedArgoApiService) SyncApplication(ctx context.Context, server *model.Server, appName string, prune bool) error {
	if server == nil {
		return apperrors.ConfigError("SERVER_MISSING",
			"Server configuration is required").
			WithUserAction("Please run 'argocd login' to configure the server")
	}
	if appName == "" {
		return apperrors.ValidationError("APP_NAME_MISSING",
			"Application name is required").
			WithUserAction("Specify an application name for the sync operation")
	}

	// Check if operation is allowed in current degradation mode
	if allowed, err := s.degradationMgr.CanPerformOperation("SyncApplication"); !allowed {
		return err
	}

	// Use the real API service with sync timeout
	if s.appService == nil {
		s.appService = api.NewApplicationService(server)
	}

	ctx, cancel := appcontext.WithSyncTimeout(ctx)
	defer cancel()

	opts := &api.SyncOptions{
		Prune: prune,
	}

	// Use retry mechanism for sync operations
	err := retry.RetryAPIOperation(ctx, "SyncApplication", func(attempt int) error {
		return s.appService.SyncApplication(ctx, appName, opts)
	})

	if err != nil {
		// Report API health status
		s.degradationMgr.ReportAPIHealth(false, err)

		// Convert API errors to structured format if needed
		if argErr, ok := err.(*apperrors.ArgonautError); ok {
			return argErr.WithContext("operation", "SyncApplication").
				WithContext("appName", appName).
				WithContext("prune", prune)
		}

		return apperrors.Wrap(err, apperrors.ErrorAPI, "SYNC_FAILED",
			"Failed to sync application").
			WithContext("server", server.BaseURL).
			WithContext("appName", appName).
			WithContext("prune", prune).
			AsRecoverable().
			WithUserAction("Check the application status and try syncing again")
	}

	// Report successful operation
	s.degradationMgr.ReportAPIHealth(true, nil)
	return nil
}

// GetResourceDiffs implements ArgoApiService.GetResourceDiffs
func (s *EnhancedArgoApiService) GetResourceDiffs(ctx context.Context, server *model.Server, appName string) ([]ResourceDiff, error) {
	if server == nil {
		return nil, apperrors.ConfigError("SERVER_MISSING",
			"Server configuration is required").
			WithUserAction("Please run 'argocd login' to configure the server")
	}
	if appName == "" {
		return nil, apperrors.ValidationError("APP_NAME_MISSING",
			"Application name is required").
			WithUserAction("Specify an application name to get resource diffs")
	}

	// Use the real API service
	if s.appService == nil {
		s.appService = api.NewApplicationService(server)
	}

	// Use retry mechanism for API calls
	var diffs []api.ManagedResourceDiff
	err := retry.RetryAPIOperation(ctx, "GetManagedResourceDiffs", func(attempt int) error {
		var opErr error
		diffs, opErr = s.appService.GetManagedResourceDiffs(ctx, appName)
		return opErr
	})
	if err != nil {
		if argErr, ok := err.(*apperrors.ArgonautError); ok {
			return nil, argErr.WithContext("operation", "GetManagedResourceDiffs").
				WithContext("appName", appName)
		}
		return nil, apperrors.Wrap(err, apperrors.ErrorAPI, "GET_DIFFS_FAILED",
			"Failed to get resource diffs").
			WithContext("appName", appName).
			AsRecoverable().
			WithUserAction("Check the application exists and try again")
	}
	// Map to service layer struct
	out := make([]ResourceDiff, len(diffs))
	for i, d := range diffs {
		out[i] = ResourceDiff{
			Kind: d.Kind, Name: d.Name, Namespace: d.Namespace,
			LiveState: d.LiveState, TargetState: d.TargetState,
		}
	}
	return out, nil
}

// GetAPIVersion fetches /api/version and returns a version string
func (s *EnhancedArgoApiService) GetAPIVersion(ctx context.Context, server *model.Server) (string, error) {
	if server == nil {
		return "", apperrors.ConfigError("SERVER_MISSING",
			"Server configuration is required").
			WithUserAction("Please run 'argocd login' to configure the server")
	}
	client := api.NewClient(server)
	var data []byte
	err := retry.RetryAPIOperation(ctx, "GetAPIVersion", func(attempt int) error {
		var opErr error
		data, opErr = client.Get(ctx, "/api/version")
		return opErr
	})
	if err != nil {
		if argErr, ok := err.(*apperrors.ArgonautError); ok {
			return "", argErr.WithContext("operation", "GetAPIVersion")
		}
		return "", apperrors.Wrap(err, apperrors.ErrorAPI, "GET_VERSION_FAILED",
			"Failed to get API version").
			WithContext("server", server.BaseURL).
			AsRecoverable().
			WithUserAction("Check ArgoCD server connectivity")
	}
	// Accept {Version:"..."} or {version:"..."}
	var anyMap map[string]interface{}
	if err := json.Unmarshal(data, &anyMap); err == nil {
		if v, ok := anyMap["Version"].(string); ok && v != "" {
			return v, nil
		}
		if v, ok := anyMap["version"].(string); ok && v != "" {
			return v, nil
		}
	}
	return string(data), nil
}

// Cleanup implements ArgoApiService.Cleanup
func (s *EnhancedArgoApiService) Cleanup() {
	s.mu.Lock()
	defer s.mu.Unlock()
	if s.watchCancel != nil {
		s.watchCancel()
		s.watchCancel = nil
	}

	// Shutdown recovery and degradation managers
	if s.recoveryManager != nil {
		s.recoveryManager.Shutdown()
	}
	if s.degradationMgr != nil {
		s.degradationMgr.Shutdown()
	}
}

// startWatchStreamWithRecovery starts the application watch stream with recovery support
func (s *EnhancedArgoApiService) startWatchStreamWithRecovery(ctx context.Context, eventChan chan<- ArgoApiEvent, streamID string) {
	watchEventChan := make(chan api.ApplicationWatchEvent, 100)

	go func() {
		defer close(watchEventChan)
		err := s.appService.WatchApplications(ctx, watchEventChan)
		if err != nil && ctx.Err() == nil {
			log.Printf("Watch stream error: %v", err)
			s.recoveryManager.ReportStreamFailure(streamID, err)
			s.degradationMgr.ReportAPIHealth(false, err)
			eventChan <- ArgoApiEvent{
				Type:  "api-error",
				Error: err,
			}
		}
	}()

	for {
		select {
		case <-ctx.Done():
			return
		case event, ok := <-watchEventChan:
			if !ok {
				return
			}
			// Report stream activity
			s.recoveryManager.ReportStreamHealthy(streamID)
			s.handleWatchEvent(event, eventChan)
		}
	}
}

// handleWatchEvent processes watch events from the API stream
func (s *EnhancedArgoApiService) handleWatchEvent(event api.ApplicationWatchEvent, eventChan chan<- ArgoApiEvent) {
	appName := event.Application.Metadata.Name
	if appName == "" {
		return
	}

	switch event.Type {
	case "DELETED":
		eventChan <- ArgoApiEvent{
			Type:    "app-deleted",
			AppName: appName,
		}
	default:
		// Convert to our model
		app := s.appService.ConvertToApp(event.Application)
		eventChan <- ArgoApiEvent{
			Type: "app-updated",
			App:  &app,
		}
	}
}

// GetApplication fetches a single application with full details including history
func (s *EnhancedArgoApiService) GetApplication(ctx context.Context, server *model.Server, appName string, appNamespace *string) (*api.ArgoApplication, error) {
	return s.appService.GetApplication(ctx, appName, appNamespace)
}

// GetRevisionMetadata fetches git metadata for a specific revision
func (s *EnhancedArgoApiService) GetRevisionMetadata(ctx context.Context, server *model.Server, appName string, revision string, appNamespace *string) (*model.RevisionMetadata, error) {
	return s.appService.GetRevisionMetadata(ctx, appName, revision, appNamespace)
}

// RollbackApplication performs a rollback operation
func (s *EnhancedArgoApiService) RollbackApplication(ctx context.Context, server *model.Server, request model.RollbackRequest) error {
	return s.appService.RollbackApplication(ctx, request)
}

// GetRecoveryStats returns recovery statistics
func (s *EnhancedArgoApiService) GetRecoveryStats() StreamRecoveryStats {
	return s.recoveryManager.GetRecoveryStats()
}

// GetServiceHealth returns service health status
func (s *EnhancedArgoApiService) GetServiceHealth() ServiceHealth {
	return s.degradationMgr.GetServiceHealth()
}

// GetDegradationSummary returns a human-readable degradation summary
func (s *EnhancedArgoApiService) GetDegradationSummary() string {
	return s.degradationMgr.GetDegradationSummary()
}

// isAuthError function already exists in argo.go, reusing it
</file>

<file path="pkg/model/messages.go">
package model

import (
    tea "github.com/charmbracelet/bubbletea/v2"
    apperrors "github.com/darksworm/argonaut/pkg/errors"
)

// Navigation Messages - correspond to TypeScript navigation actions

// SetViewMsg sets the current view
type SetViewMsg struct {
	View View
}

// SetSelectedIdxMsg sets the selected index
type SetSelectedIdxMsg struct {
	SelectedIdx int
}

// ResetNavigationMsg resets navigation state
type ResetNavigationMsg struct {
	View *View
}

// UpdateLastGPressedMsg updates the last G press timestamp
type UpdateLastGPressedMsg struct {
	Timestamp int64
}

// UpdateLastEscPressedMsg updates the last Esc press timestamp
type UpdateLastEscPressedMsg struct {
	Timestamp int64
}

// Selection Messages - correspond to TypeScript selection actions

// SetScopeClustersMsg sets the cluster scope
type SetScopeClustersMsg struct {
	Clusters map[string]bool
}

// SetScopeNamespacesMsg sets the namespace scope
type SetScopeNamespacesMsg struct {
	Namespaces map[string]bool
}

// SetScopeProjectsMsg sets the project scope
type SetScopeProjectsMsg struct {
	Projects map[string]bool
}

// SetSelectedAppsMsg sets the selected apps
type SetSelectedAppsMsg struct {
	Apps map[string]bool
}

// ClearAllSelectionsMsg clears all selections
type ClearAllSelectionsMsg struct{}

// ClearLowerLevelSelectionsMsg clears lower level selections based on view
type ClearLowerLevelSelectionsMsg struct {
	View View
}

// UI Messages - correspond to TypeScript UI actions

// SetSearchQueryMsg sets the search query
type SetSearchQueryMsg struct {
	Query string
}

// SetActiveFilterMsg sets the active filter
type SetActiveFilterMsg struct {
	Filter string
}

// SetCommandMsg sets the command
type SetCommandMsg struct {
	Command string
}

// BumpCommandInputKeyMsg bumps the command input key
type BumpCommandInputKeyMsg struct{}

// SetVersionOutdatedMsg sets the version outdated flag
type SetVersionOutdatedMsg struct {
	IsOutdated bool
}

// SetLatestVersionMsg sets the latest version
type SetLatestVersionMsg struct {
	Version *string
}

// ClearFiltersMsg clears all filters
type ClearFiltersMsg struct{}

// Modal Messages - correspond to TypeScript modal actions

// SetConfirmTargetMsg sets the confirm target
type SetConfirmTargetMsg struct {
	Target *string
}

// SetConfirmSyncPruneMsg sets the confirm sync prune flag
type SetConfirmSyncPruneMsg struct {
	SyncPrune bool
}

// SetConfirmSyncWatchMsg sets the confirm sync watch flag
type SetConfirmSyncWatchMsg struct {
	SyncWatch bool
}

// SetRollbackAppNameMsg sets the rollback app name
type SetRollbackAppNameMsg struct {
	AppName *string
}

// SetSyncViewAppMsg sets the sync view app
type SetSyncViewAppMsg struct {
	AppName *string
}

// ClearModalsMsg clears all modal state
type ClearModalsMsg struct{}

// Server/Data Messages - correspond to TypeScript data actions

// SetAppsMsg sets the applications list
type SetAppsMsg struct {
	Apps []App
}

// SetServerMsg sets the server configuration
type SetServerMsg struct {
	Server *Server
}

// SetModeMsg sets the application mode
type SetModeMsg struct {
	Mode Mode
}

// SetTerminalSizeMsg sets the terminal size
type SetTerminalSizeMsg struct {
	Rows int
	Cols int
}

// SetAPIVersionMsg sets the API version
type SetAPIVersionMsg struct {
	Version string
}

// API Event Messages - correspond to ArgoApiService events

// AppsLoadedMsg is sent when apps are loaded
type AppsLoadedMsg struct {
	Apps []App
}

// AppUpdatedMsg is sent when an app is updated
type AppUpdatedMsg struct {
	App App
}

// AppDeletedMsg is sent when an app is deleted
type AppDeletedMsg struct {
	AppName string
}

// AuthErrorMsg is sent when authentication is required
type AuthErrorMsg struct {
	Error error
}

// ApiErrorMsg is sent when there's an API error - DEPRECATED: Use StructuredErrorMsg
type ApiErrorMsg struct {
	Message    string
	StatusCode int    `json:"statusCode,omitempty"` // HTTP status code if available
	ErrorCode  int    `json:"errorCode,omitempty"`  // API error code if available
	Details    string `json:"details,omitempty"`    // Additional error details
}

// StructuredErrorMsg represents a structured error message for the TUI
type StructuredErrorMsg struct {
	Error    *apperrors.ArgonautError   `json:"error"`
	Context  map[string]interface{}     `json:"context,omitempty"`
	Retry    bool                       `json:"retry,omitempty"`
	AutoHide bool                       `json:"autoHide,omitempty"`
}

// ErrorRecoveredMsg indicates that an error has been automatically recovered
type ErrorRecoveredMsg struct {
	OriginalError *apperrors.ArgonautError `json:"originalError"`
	RecoveryInfo  string                   `json:"recoveryInfo"`
}

// RetryOperationMsg triggers a retry of a failed operation
type RetryOperationMsg struct {
	Operation string                 `json:"operation"`
	Context   map[string]interface{} `json:"context"`
	Attempt   int                    `json:"attempt"`
}

// StatusChangeMsg is sent when status changes
type StatusChangeMsg struct {
	Status string
}

// Navigation Event Messages - correspond to navigation service results

// NavigationUpdateMsg is sent when navigation should be updated
type NavigationUpdateMsg struct {
	NewView                         *View
	ScopeClusters                   map[string]bool
	ScopeNamespaces                 map[string]bool
	ScopeProjects                   map[string]bool
	SelectedApps                    map[string]bool
	ShouldResetNavigation           bool
	ShouldClearLowerLevelSelections bool
}

// SelectionUpdateMsg is sent when selections should be updated
type SelectionUpdateMsg struct {
	SelectedApps map[string]bool
}

// Terminal/System Messages

// WindowSizeMsg is sent when the terminal window is resized
type WindowSizeMsg tea.WindowSizeMsg

// KeyMsg wraps Bubbletea's KeyMsg
type KeyMsg tea.KeyMsg

// QuitMsg is sent to quit the application
type QuitMsg struct{}

// SetInitialLoadingMsg controls the initial loading modal display
type SetInitialLoadingMsg struct {
	Loading bool `json:"loading"`
}

// TickMsg is sent on timer ticks
type TickMsg struct{}

// Command Messages - for handling async operations

// LoadAppsCmd represents a command to load applications
type LoadAppsCmd struct {
	Server *Server
}

// SyncAppCmd represents a command to sync an application
type SyncAppCmd struct {
	Server  *Server
	AppName string
	Prune   bool
}

// WatchAppsCmd represents a command to start watching applications
type WatchAppsCmd struct {
	Server *Server
}

// Generic result messages for async operations

// ResultMsg wraps the result of an operation
type ResultMsg struct {
	Success bool
	Error   error
	Data    interface{}
}

// LoadingMsg indicates a loading state change
type LoadingMsg struct {
	IsLoading bool
	Message   string
}

// Sync completion messages

// SyncCompletedMsg indicates a single app sync has completed
type SyncCompletedMsg struct {
	AppName string
	Success bool
}

// MultiSyncCompletedMsg indicates multiple app sync has completed
type MultiSyncCompletedMsg struct {
	AppCount int
	Success  bool
}

// Rollback Messages - for rollback functionality

// RollbackHistoryLoadedMsg is sent when rollback history is loaded
type RollbackHistoryLoadedMsg struct {
	AppName         string
	Rows            []RollbackRow
	CurrentRevision string
}

// RollbackMetadataLoadedMsg is sent when git metadata is loaded for a revision
type RollbackMetadataLoadedMsg struct {
	RowIndex int
	Metadata RevisionMetadata
}

// RollbackMetadataErrorMsg is sent when metadata loading fails
type RollbackMetadataErrorMsg struct {
	RowIndex int
	Error    string
}

// RollbackExecutedMsg is sent when rollback is executed
type RollbackExecutedMsg struct {
	AppName string
	Success bool
	Watch   bool // Whether to start watching after rollback
}

// RollbackNavigationMsg is sent to change rollback navigation
type RollbackNavigationMsg struct {
	Direction string // "up", "down", "top", "bottom"
}

// RollbackToggleOptionMsg is sent to toggle rollback options
type RollbackToggleOptionMsg struct {
	Option string // "prune", "watch", "dryrun"
}

// RollbackConfirmMsg is sent to confirm rollback
type RollbackConfirmMsg struct{}

// RollbackCancelMsg is sent to cancel rollback
type RollbackCancelMsg struct{}

// RollbackShowDiffMsg is sent to show diff for selected revision
type RollbackShowDiffMsg struct {
    Revision string
}

// ResourceTreeLoadedMsg is sent when a resource tree is loaded for an app
type ResourceTreeLoadedMsg struct {
    AppName  string
    Health   string
    Sync     string
    TreeJSON []byte
}

// ResourceTreeStreamMsg represents a streamed resource tree update
type ResourceTreeStreamMsg struct {
    AppName  string
    TreeJSON []byte
}
</file>

<file path="pkg/model/state.go">
package model

import (
	"time"
	apperrors "github.com/darksworm/argonaut/pkg/errors"
)

// NavigationState holds navigation-related state
type NavigationState struct {
	View           View  `json:"view"`
	SelectedIdx    int   `json:"selectedIdx"`
	LastGPressed   int64 `json:"lastGPressed"`
	LastEscPressed int64 `json:"lastEscPressed"`
}

// SelectionState holds selection-related state using map[string]bool for sets
type SelectionState struct {
	ScopeClusters   map[string]bool `json:"scopeClusters"`
	ScopeNamespaces map[string]bool `json:"scopeNamespaces"`
	ScopeProjects   map[string]bool `json:"scopeProjects"`
	SelectedApps    map[string]bool `json:"selectedApps"`
}

// NewSelectionState creates a new SelectionState with empty sets
func NewSelectionState() *SelectionState {
	return &SelectionState{
		ScopeClusters:   NewStringSet(),
		ScopeNamespaces: NewStringSet(),
		ScopeProjects:   NewStringSet(),
		SelectedApps:    NewStringSet(),
	}
}

// Helper methods for SelectionState

// AddCluster adds a cluster to the scope
func (s *SelectionState) AddCluster(cluster string) {
	s.ScopeClusters = AddToStringSet(s.ScopeClusters, cluster)
}

// HasCluster checks if a cluster is in scope
func (s *SelectionState) HasCluster(cluster string) bool {
	return HasInStringSet(s.ScopeClusters, cluster)
}

// AddNamespace adds a namespace to the scope
func (s *SelectionState) AddNamespace(namespace string) {
	s.ScopeNamespaces = AddToStringSet(s.ScopeNamespaces, namespace)
}

// HasNamespace checks if a namespace is in scope
func (s *SelectionState) HasNamespace(namespace string) bool {
	return HasInStringSet(s.ScopeNamespaces, namespace)
}

// AddProject adds a project to the scope
func (s *SelectionState) AddProject(project string) {
	s.ScopeProjects = AddToStringSet(s.ScopeProjects, project)
}

// HasProject checks if a project is in scope
func (s *SelectionState) HasProject(project string) bool {
	return HasInStringSet(s.ScopeProjects, project)
}

// AddSelectedApp adds an app to the selected apps
func (s *SelectionState) AddSelectedApp(app string) {
	s.SelectedApps = AddToStringSet(s.SelectedApps, app)
}

// HasSelectedApp checks if an app is selected
func (s *SelectionState) HasSelectedApp(app string) bool {
	return HasInStringSet(s.SelectedApps, app)
}

// ToggleSelectedApp toggles an app's selection status
func (s *SelectionState) ToggleSelectedApp(app string) {
	if s.HasSelectedApp(app) {
		s.SelectedApps = RemoveFromStringSet(s.SelectedApps, app)
	} else {
		s.AddSelectedApp(app)
	}
}

// UIState holds UI-related state
type UIState struct {
    SearchQuery       string  `json:"searchQuery"`
    ActiveFilter      string  `json:"activeFilter"`
    Command           string  `json:"command"`
    IsVersionOutdated bool    `json:"isVersionOutdated"`
    LatestVersion     *string `json:"latestVersion,omitempty"`
    CommandInputKey   int     `json:"commandInputKey"`
    TreeAppName       *string `json:"treeAppName,omitempty"`
}

// ModalState holds modal-related state
type ModalState struct {
    ConfirmTarget    *string `json:"confirmTarget,omitempty"`
    ConfirmSyncPrune bool    `json:"confirmSyncPrune"`
    ConfirmSyncWatch bool    `json:"confirmSyncWatch"`
    // Which button is selected in confirm modal: 0 = Yes, 1 = Cancel
    ConfirmSyncSelected int `json:"confirmSyncSelected"`
    // When true, show a small syncing overlay instead of the confirm UI
    ConfirmSyncLoading  bool `json:"confirmSyncLoading"`
    // When true, show initial loading modal overlay during app startup
    InitialLoading      bool `json:"initialLoading"`
    RollbackAppName  *string `json:"rollbackAppName,omitempty"`
    SyncViewApp      *string `json:"syncViewApp,omitempty"`
}

// AppState represents the complete application state for Bubbletea
type AppState struct {
    Mode       Mode            `json:"mode"`
	Terminal   TerminalState   `json:"terminal"`
	Navigation NavigationState `json:"navigation"`
	Selections SelectionState  `json:"selections"`
	UI         UIState         `json:"ui"`
	Modals     ModalState      `json:"modals"`
	Server     *Server         `json:"server,omitempty"`
	Apps       []App           `json:"apps"`
    APIVersion string          `json:"apiVersion"`
    // Note: AbortController equivalent will use context.Context in Go services
    Diff       *DiffState      `json:"diff,omitempty"`
    Resources  *ResourceState  `json:"resources,omitempty"`
    Rollback   *RollbackState  `json:"rollback,omitempty"`
    // Store previous navigation state for restoration
    SavedNavigation *NavigationState `json:"savedNavigation,omitempty"`
    SavedSelections *SelectionState  `json:"savedSelections,omitempty"`
    // Store current error information for error screen display
    CurrentError    *ApiError        `json:"currentError,omitempty"`     // DEPRECATED: Use ErrorState
    ErrorState      *ErrorState      `json:"errorState,omitempty"`
}

// ApiError holds structured error information for display - DEPRECATED: Use ErrorState
type ApiError struct {
    Message    string `json:"message"`
    StatusCode int    `json:"statusCode,omitempty"`
    ErrorCode  int    `json:"errorCode,omitempty"`
    Details    string `json:"details,omitempty"`
    Timestamp  int64  `json:"timestamp"`
}

// ErrorState holds comprehensive error state information
type ErrorState struct {
    Current          *apperrors.ArgonautError   `json:"current"`
    History          []apperrors.ArgonautError  `json:"history"`
    RetryCount       int                        `json:"retryCount"`
    LastRetryAt      *time.Time                 `json:"lastRetryAt,omitempty"`
    AutoHideAt       *time.Time                 `json:"autoHideAt,omitempty"`
    RecoveryAttempts int                        `json:"recoveryAttempts"`
}

// DiffState holds state for the diff pager view
type DiffState struct {
    Title       string   `json:"title"`
    Content     []string `json:"content"`
    Filtered    []int    `json:"filtered"`
    Offset      int      `json:"offset"`
    SearchQuery string   `json:"searchQuery"`
    Loading     bool     `json:"loading"`
}

// SaveNavigationState saves current navigation and selection state
func (s *AppState) SaveNavigationState() {
	s.SavedNavigation = &NavigationState{
		View:           s.Navigation.View,
		SelectedIdx:    s.Navigation.SelectedIdx,
		LastGPressed:   s.Navigation.LastGPressed,
		LastEscPressed: s.Navigation.LastEscPressed,
	}
	s.SavedSelections = &SelectionState{
		ScopeClusters:   copyStringSet(s.Selections.ScopeClusters),
		ScopeNamespaces: copyStringSet(s.Selections.ScopeNamespaces),
		ScopeProjects:   copyStringSet(s.Selections.ScopeProjects),
		SelectedApps:    copyStringSet(s.Selections.SelectedApps),
	}
}

// RestoreNavigationState restores previously saved navigation state
func (s *AppState) RestoreNavigationState() {
	if s.SavedNavigation != nil {
		s.Navigation.View = s.SavedNavigation.View
		s.Navigation.SelectedIdx = s.SavedNavigation.SelectedIdx
		s.Navigation.LastGPressed = s.SavedNavigation.LastGPressed
		s.Navigation.LastEscPressed = s.SavedNavigation.LastEscPressed
		// Clear the saved state after restoration
		s.SavedNavigation = nil
	}
}

// ClearSelectionsAfterDetailView clears only app selections when returning from detail views
// Preserves scope filters (clusters, namespaces, projects) to maintain the filtered view
func (s *AppState) ClearSelectionsAfterDetailView() {
	// Only clear selected apps, preserve scope filters
	s.Selections.SelectedApps = NewStringSet()
	// Clear saved selections as well
	s.SavedSelections = nil
}

// Helper function to copy a string set
func copyStringSet(original map[string]bool) map[string]bool {
	copy := make(map[string]bool)
	for k, v := range original {
		copy[k] = v
	}
	return copy
}

// NewAppState creates a new AppState with default values
func NewAppState() *AppState {
    return &AppState{
        Mode: ModeNormal,
        Terminal: TerminalState{
            Rows: 24,
            Cols: 80,
        },
        Navigation: NavigationState{
            View:           ViewClusters,
            SelectedIdx:    0,
            LastGPressed:   0,
            LastEscPressed: 0,
        },
        Selections: *NewSelectionState(),
		UI: UIState{
			SearchQuery:       "",
			ActiveFilter:      "",
			Command:           "",
			IsVersionOutdated: false,
			LatestVersion:     nil,
			CommandInputKey:   0,
		},
		Modals: ModalState{
			ConfirmTarget:    nil,
			ConfirmSyncPrune: false,
			ConfirmSyncWatch: true,
			ConfirmSyncSelected: 0,
			ConfirmSyncLoading:  false,
			InitialLoading:      false,
			RollbackAppName:  nil,
			SyncViewApp:      nil,
		},
		Server:     nil,
		Apps:       []App{},
		APIVersion: "",
		SavedNavigation: nil,
		SavedSelections: nil,
	}
}
</file>

<file path="pkg/services/argo.go">
package services

import (
	"context"
	"encoding/json"
	"log"
	"strings"
	"sync"

	"github.com/darksworm/argonaut/pkg/api"
	apperrors "github.com/darksworm/argonaut/pkg/errors"
	appcontext "github.com/darksworm/argonaut/pkg/context"
	"github.com/darksworm/argonaut/pkg/model"
	"github.com/darksworm/argonaut/pkg/retry"
)

// ArgoApiService interface defines operations for interacting with ArgoCD API
type ArgoApiService interface {
	// ListApplications retrieves all applications from ArgoCD
	ListApplications(ctx context.Context, server *model.Server) ([]model.App, error)

	// WatchApplications starts watching for application changes
	// Returns a channel for events and a cleanup function
	WatchApplications(ctx context.Context, server *model.Server) (<-chan ArgoApiEvent, func(), error)

	// SyncApplication syncs a specific application
	SyncApplication(ctx context.Context, server *model.Server, appName string, prune bool) error

	// GetResourceDiffs gets resource diffs for an application
    GetResourceDiffs(ctx context.Context, server *model.Server, appName string) ([]ResourceDiff, error)

    // GetAPIVersion fetches the ArgoCD API server version string
    GetAPIVersion(ctx context.Context, server *model.Server) (string, error)

    // GetApplication fetches a single application with full details including history
    GetApplication(ctx context.Context, server *model.Server, appName string, appNamespace *string) (*api.ArgoApplication, error)

    // GetRevisionMetadata fetches git metadata for a specific revision
    GetRevisionMetadata(ctx context.Context, server *model.Server, appName string, revision string, appNamespace *string) (*model.RevisionMetadata, error)

    // RollbackApplication performs a rollback operation
    RollbackApplication(ctx context.Context, server *model.Server, request model.RollbackRequest) error

    // GetResourceTree fetches the resource tree for an application
    GetResourceTree(ctx context.Context, server *model.Server, appName string, appNamespace string) (*api.ResourceTree, error)

    // WatchResourceTree streams resource tree updates for an application
    WatchResourceTree(ctx context.Context, server *model.Server, appName string, appNamespace string) (<-chan *api.ResourceTree, func(), error)

    // Cleanup stops all watchers and cleans up resources
    Cleanup()
}

// ArgoApiEvent represents events from the ArgoCD API
type ArgoApiEvent struct {
	Type    string       `json:"type"`
	Apps    []model.App  `json:"apps,omitempty"`
	App     *model.App   `json:"app,omitempty"`
	AppName string       `json:"appName,omitempty"`
	Error   error        `json:"error,omitempty"`
	Status  string       `json:"status,omitempty"`
}

// ResourceDiff represents a resource difference
type ResourceDiff struct {
    Kind       string `json:"kind"`
    Name       string `json:"name"`
    Namespace  string `json:"namespace"`
    LiveState  string `json:"liveState,omitempty"`
    TargetState string `json:"targetState,omitempty"`
}

// ArgoApiServiceImpl provides a concrete implementation of ArgoApiService
type ArgoApiServiceImpl struct {
	appService  *api.ApplicationService
	watchCancel context.CancelFunc
	mu          sync.RWMutex
}

// NewArgoApiService creates a new ArgoApiService implementation
func NewArgoApiService(server *model.Server) ArgoApiService {
	impl := &ArgoApiServiceImpl{}
	if server != nil {
		impl.appService = api.NewApplicationService(server)
	}
	return impl
}

// ListApplications implements ArgoApiService.ListApplications
func (s *ArgoApiServiceImpl) ListApplications(ctx context.Context, server *model.Server) ([]model.App, error) {
	if server == nil {
		return nil, apperrors.ConfigError("SERVER_MISSING",
			"Server configuration is required").
			WithUserAction("Please run 'argocd login' to configure the server")
	}

	// Use the real API service with resource timeout
	if s.appService == nil {
		s.appService = api.NewApplicationService(server)
	}

	ctx, cancel := appcontext.WithResourceTimeout(ctx)
	defer cancel()

	// Use retry mechanism for network operations
	var apps []model.App
	err := retry.RetryAPIOperation(ctx, "ListApplications", func(attempt int) error {
		var opErr error
		apps, opErr = s.appService.ListApplications(ctx)
		return opErr
	})

	if err != nil {
		// Convert API errors to structured format if needed
		if argErr, ok := err.(*apperrors.ArgonautError); ok {
			return nil, argErr.WithContext("operation", "ListApplications")
		}

		return nil, apperrors.Wrap(err, apperrors.ErrorAPI, "LIST_APPS_FAILED",
			"Failed to list applications").
			WithContext("server", server.BaseURL).
			AsRecoverable().
			WithUserAction("Check your ArgoCD server connection and try again")
	}

	return apps, nil
}

// WatchApplications implements ArgoApiService.WatchApplications
func (s *ArgoApiServiceImpl) WatchApplications(ctx context.Context, server *model.Server) (<-chan ArgoApiEvent, func(), error) {
	if server == nil {
		return nil, nil, apperrors.ConfigError("SERVER_MISSING",
			"Server configuration is required").
			WithUserAction("Please run 'argocd login' to configure the server")
	}

	// Use the real API service
	if s.appService == nil {
		s.appService = api.NewApplicationService(server)
	}

	eventChan := make(chan ArgoApiEvent, 100)
	watchCtx, cancel := appcontext.WithCancel(ctx) // No timeout for streams
	s.mu.Lock()
	s.watchCancel = cancel
	s.mu.Unlock()

	// Start watching in a goroutine
	go func() {
		defer close(eventChan)

		// Send initial status
		eventChan <- ArgoApiEvent{
			Type:   "status-change",
			Status: "Loading…",
		}

		// Send initial apps loaded event (no retry for initial watch load to avoid delays)
		apps, err := s.ListApplications(watchCtx, server)
		if err != nil {
			if isAuthError(err.Error()) {
				eventChan <- ArgoApiEvent{
					Type:  "auth-error",
					Error: err,
				}
				eventChan <- ArgoApiEvent{
					Type:   "status-change",
					Status: "Auth required",
				}
				return
			}
			eventChan <- ArgoApiEvent{
				Type:  "api-error",
				Error: err,
			}
			eventChan <- ArgoApiEvent{
				Type:   "status-change",
				Status: "Error: " + err.Error(),
			}
			return
		}

		eventChan <- ArgoApiEvent{
			Type: "apps-loaded",
			Apps: apps,
		}

		eventChan <- ArgoApiEvent{
			Type:   "status-change",
			Status: "Live",
		}

		// Start real watch stream
		s.startWatchStream(watchCtx, eventChan)
	}()

	cleanup := func() {
		s.mu.Lock()
		defer s.mu.Unlock()
		if s.watchCancel != nil {
			s.watchCancel()
			s.watchCancel = nil
		}
	}

	return eventChan, cleanup, nil
}

// SyncApplication implements ArgoApiService.SyncApplication
func (s *ArgoApiServiceImpl) SyncApplication(ctx context.Context, server *model.Server, appName string, prune bool) error {
	if server == nil {
		return apperrors.ConfigError("SERVER_MISSING",
			"Server configuration is required").
			WithUserAction("Please run 'argocd login' to configure the server")
	}
	if appName == "" {
		return apperrors.ValidationError("APP_NAME_MISSING",
			"Application name is required").
			WithUserAction("Specify an application name for the sync operation")
	}

	// Use the real API service with sync timeout
	if s.appService == nil {
		s.appService = api.NewApplicationService(server)
	}

	ctx, cancel := appcontext.WithSyncTimeout(ctx)
	defer cancel()

	opts := &api.SyncOptions{
		Prune: prune,
	}

	// Use retry mechanism for sync operations
	err := retry.RetryAPIOperation(ctx, "SyncApplication", func(attempt int) error {
		return s.appService.SyncApplication(ctx, appName, opts)
	})

	if err != nil {
		// Convert API errors to structured format if needed
		if argErr, ok := err.(*apperrors.ArgonautError); ok {
			return argErr.WithContext("operation", "SyncApplication").
				WithContext("appName", appName).
				WithContext("prune", prune)
		}

		return apperrors.Wrap(err, apperrors.ErrorAPI, "SYNC_FAILED",
			"Failed to sync application").
			WithContext("server", server.BaseURL).
			WithContext("appName", appName).
			WithContext("prune", prune).
			AsRecoverable().
			WithUserAction("Check the application status and try syncing again")
	}

	return nil
}

// GetResourceDiffs implements ArgoApiService.GetResourceDiffs
func (s *ArgoApiServiceImpl) GetResourceDiffs(ctx context.Context, server *model.Server, appName string) ([]ResourceDiff, error) {
	if server == nil {
		return nil, apperrors.ConfigError("SERVER_MISSING",
			"Server configuration is required").
			WithUserAction("Please run 'argocd login' to configure the server")
	}
	if appName == "" {
		return nil, apperrors.ValidationError("APP_NAME_MISSING",
			"Application name is required").
			WithUserAction("Specify an application name to get resource diffs")
	}

    // Use the real API service
    if s.appService == nil {
        s.appService = api.NewApplicationService(server)
    }

    // Use retry mechanism for API calls
    var diffs []api.ManagedResourceDiff
    err := retry.RetryAPIOperation(ctx, "GetManagedResourceDiffs", func(attempt int) error {
        var opErr error
        diffs, opErr = s.appService.GetManagedResourceDiffs(ctx, appName)
        return opErr
    })
    if err != nil {
        if argErr, ok := err.(*apperrors.ArgonautError); ok {
            return nil, argErr.WithContext("operation", "GetManagedResourceDiffs").
                WithContext("appName", appName)
        }
        return nil, apperrors.Wrap(err, apperrors.ErrorAPI, "GET_DIFFS_FAILED",
            "Failed to get resource diffs").
            WithContext("appName", appName).
            AsRecoverable().
            WithUserAction("Check the application exists and try again")
    }
    // Map to service layer struct
    out := make([]ResourceDiff, len(diffs))
    for i, d := range diffs {
        out[i] = ResourceDiff{
            Kind: d.Kind, Name: d.Name, Namespace: d.Namespace,
            LiveState: d.LiveState, TargetState: d.TargetState,
        }
    }
    return out, nil
}

// GetAPIVersion fetches /api/version and returns a version string
func (s *ArgoApiServiceImpl) GetAPIVersion(ctx context.Context, server *model.Server) (string, error) {
    if server == nil {
        return "", apperrors.ConfigError("SERVER_MISSING",
            "Server configuration is required").
            WithUserAction("Please run 'argocd login' to configure the server")
    }
    client := api.NewClient(server)
    var data []byte
    err := retry.RetryAPIOperation(ctx, "GetAPIVersion", func(attempt int) error {
        var opErr error
        data, opErr = client.Get(ctx, "/api/version")
        return opErr
    })
    if err != nil {
        if argErr, ok := err.(*apperrors.ArgonautError); ok {
            return "", argErr.WithContext("operation", "GetAPIVersion")
        }
        return "", apperrors.Wrap(err, apperrors.ErrorAPI, "GET_VERSION_FAILED",
            "Failed to get API version").
            WithContext("server", server.BaseURL).
            AsRecoverable().
            WithUserAction("Check ArgoCD server connectivity")
    }
    // Accept {Version:"..."} or {version:"..."}
    var anyMap map[string]interface{}
    if err := json.Unmarshal(data, &anyMap); err == nil {
        if v, ok := anyMap["Version"].(string); ok && v != "" { return v, nil }
        if v, ok := anyMap["version"].(string); ok && v != "" { return v, nil }
    }
    return string(data), nil
}

// Cleanup implements ArgoApiService.Cleanup
func (s *ArgoApiServiceImpl) Cleanup() {
	s.mu.Lock()
	defer s.mu.Unlock()
	if s.watchCancel != nil {
		s.watchCancel()
		s.watchCancel = nil
	}
}

// startWatchStream starts the application watch stream
func (s *ArgoApiServiceImpl) startWatchStream(ctx context.Context, eventChan chan<- ArgoApiEvent) {
	watchEventChan := make(chan api.ApplicationWatchEvent, 100)
	
	go func() {
		defer close(watchEventChan)
		err := s.appService.WatchApplications(ctx, watchEventChan)
		if err != nil && ctx.Err() == nil {
			log.Printf("Watch stream error: %v", err)
			eventChan <- ArgoApiEvent{
				Type:  "api-error",
				Error: err,
			}
		}
	}()

	for {
		select {
		case <-ctx.Done():
			return
		case event, ok := <-watchEventChan:
			if !ok {
				return
			}
			s.handleWatchEvent(event, eventChan)
		}
	}
}

// handleWatchEvent processes watch events from the API stream
func (s *ArgoApiServiceImpl) handleWatchEvent(event api.ApplicationWatchEvent, eventChan chan<- ArgoApiEvent) {
	appName := event.Application.Metadata.Name
	if appName == "" {
		return
	}

	switch event.Type {
	case "DELETED":
		eventChan <- ArgoApiEvent{
			Type:    "app-deleted",
			AppName: appName,
		}
	default:
		// Convert to our model
		app := s.appService.ConvertToApp(event.Application)
		eventChan <- ArgoApiEvent{
			Type: "app-updated",
			App:  &app,
		}
	}
}

// GetApplication fetches a single application with full details including history
func (s *ArgoApiServiceImpl) GetApplication(ctx context.Context, server *model.Server, appName string, appNamespace *string) (*api.ArgoApplication, error) {
	return s.appService.GetApplication(ctx, appName, appNamespace)
}

// GetRevisionMetadata fetches git metadata for a specific revision
func (s *ArgoApiServiceImpl) GetRevisionMetadata(ctx context.Context, server *model.Server, appName string, revision string, appNamespace *string) (*model.RevisionMetadata, error) {
	return s.appService.GetRevisionMetadata(ctx, appName, revision, appNamespace)
}

// RollbackApplication performs a rollback operation
func (s *ArgoApiServiceImpl) RollbackApplication(ctx context.Context, server *model.Server, request model.RollbackRequest) error {
    return s.appService.RollbackApplication(ctx, request)
}

// GetResourceTree implements ArgoApiService.GetResourceTree
func (s *ArgoApiServiceImpl) GetResourceTree(ctx context.Context, server *model.Server, appName string, appNamespace string) (*api.ResourceTree, error) {
    if server == nil {
        return nil, apperrors.ConfigError("SERVER_MISSING",
            "Server configuration is required").
            WithUserAction("Please run 'argocd login' to configure the server")
    }
    if appName == "" {
        return nil, apperrors.ValidationError("APP_NAME_MISSING",
            "Application name is required").
            WithUserAction("Specify an application name to load the resource tree")
    }

    if s.appService == nil {
        s.appService = api.NewApplicationService(server)
    }

    // Respect resource timeout
    ctx, cancel := appcontext.WithResourceTimeout(ctx)
    defer cancel()

    var tree *api.ResourceTree
    err := retry.RetryAPIOperation(ctx, "GetResourceTree", func(attempt int) error {
        var opErr error
        tree, opErr = s.appService.GetResourceTree(ctx, appName, appNamespace)
        return opErr
    })
    if err != nil {
        if argErr, ok := err.(*apperrors.ArgonautError); ok {
            return nil, argErr.WithContext("operation", "GetResourceTree").
                WithContext("appName", appName).
                WithContext("appNamespace", appNamespace)
        }
        return nil, apperrors.Wrap(err, apperrors.ErrorAPI, "GET_RESOURCE_TREE_FAILED",
            "Failed to load resource tree").
            WithContext("appName", appName).
            WithContext("appNamespace", appNamespace).
            AsRecoverable().
            WithUserAction("Check the application exists and try again")
    }
    return tree, nil
}

// WatchResourceTree implements ArgoApiService.WatchResourceTree
func (s *ArgoApiServiceImpl) WatchResourceTree(ctx context.Context, server *model.Server, appName string, appNamespace string) (<-chan *api.ResourceTree, func(), error) {
    if server == nil {
        return nil, nil, apperrors.ConfigError("SERVER_MISSING",
            "Server configuration is required").
            WithUserAction("Please run 'argocd login' to configure the server")
    }
    if appName == "" {
        return nil, nil, apperrors.ValidationError("APP_NAME_MISSING",
            "Application name is required").
            WithUserAction("Specify an application name to watch the resource tree")
    }
    if s.appService == nil { s.appService = api.NewApplicationService(server) }

    out := make(chan *api.ResourceTree, 32)
    watchCtx, cancel := appcontext.WithCancel(ctx)

    go func() {
        defer close(out)
        // internal channel of plain ResourceTree values from api
        ch := make(chan api.ResourceTree, 32)
        go func() {
            defer close(ch)
            _ = s.appService.WatchResourceTree(watchCtx, appName, appNamespace, ch)
        }()
        for {
            select {
            case <-watchCtx.Done():
                return
            case t, ok := <-ch:
                if !ok { return }
                // copy to heap pointer
                tt := t
                out <- &tt
            }
        }
    }()

    cleanup := func() { cancel() }
    return out, cleanup, nil
}

// isAuthError checks if an error indicates authentication issues
func isAuthError(errMsg string) bool {
	authIndicators := []string{
		"401", "403", "unauthorized", "forbidden", "auth", "login",
	}
	
	errLower := strings.ToLower(errMsg)
	for _, indicator := range authIndicators {
		if strings.Contains(errLower, indicator) {
			return true
		}
	}
	return false
}
</file>

<file path="pkg/api/client.go">
package api

import (
	"bytes"
	"context"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io"
	"net"
	"net/http"
	"strings"
	"time"

	apperrors "github.com/darksworm/argonaut/pkg/errors"
	appcontext "github.com/darksworm/argonaut/pkg/context"
	"github.com/darksworm/argonaut/pkg/model"
	"github.com/darksworm/argonaut/pkg/retry"
)

// Client represents an HTTP client for ArgoCD API
type Client struct {
	baseURL    string
	token      string
	httpClient *http.Client
	insecure   bool
}

// NewClient creates a new ArgoCD API client
func NewClient(server *model.Server) *Client {
	// Create HTTP transport with fast connection timeouts
	transport := &http.Transport{
		// Connection establishment timeout - should be very fast
		DialContext: (&net.Dialer{
			Timeout:   2 * time.Second,
			KeepAlive: 30 * time.Second,
		}).DialContext,
		TLSHandshakeTimeout:   3 * time.Second,
		ResponseHeaderTimeout: 5 * time.Second,
		// Keep connections alive for efficiency
		IdleConnTimeout:     30 * time.Second,
		MaxIdleConns:        10,
		MaxIdleConnsPerHost: 2,
	}

	// If insecure flag is set, skip TLS verification
	if server.Insecure {
		transport.TLSClientConfig = &tls.Config{
			InsecureSkipVerify: true,
		}
	}

	// Create HTTP client without a default timeout (we'll use context timeouts)
	httpClient := &http.Client{
		Transport: transport,
		// No timeout here - we use context timeouts for request-specific timing
	}

	return &Client{
		baseURL:    server.BaseURL,
		token:      server.Token,
		httpClient: httpClient,
		insecure:   server.Insecure,
	}
}

// Get performs a GET request with retry logic
func (c *Client) Get(ctx context.Context, path string) ([]byte, error) {
	ctx, cancel := appcontext.WithAPITimeout(ctx)
	defer cancel()

	var result []byte
	err := retry.RetryNetworkOperation(ctx, fmt.Sprintf("GET %s", path), func(attempt int) error {
		var opErr error
		result, opErr = c.request(ctx, "GET", path, nil)
		return opErr
	})

	return result, err
}

// Post performs a POST request with retry logic
func (c *Client) Post(ctx context.Context, path string, body interface{}) ([]byte, error) {
	ctx, cancel := appcontext.WithAPITimeout(ctx)
	defer cancel()

	var result []byte
	err := retry.RetryNetworkOperation(ctx, fmt.Sprintf("POST %s", path), func(attempt int) error {
		var opErr error
		result, opErr = c.request(ctx, "POST", path, body)
		return opErr
	})

	return result, err
}

// Put performs a PUT request with retry logic
func (c *Client) Put(ctx context.Context, path string, body interface{}) ([]byte, error) {
	ctx, cancel := appcontext.WithAPITimeout(ctx)
	defer cancel()

	var result []byte
	err := retry.RetryNetworkOperation(ctx, fmt.Sprintf("PUT %s", path), func(attempt int) error {
		var opErr error
		result, opErr = c.request(ctx, "PUT", path, body)
		return opErr
	})

	return result, err
}

// Delete performs a DELETE request with retry logic
func (c *Client) Delete(ctx context.Context, path string) ([]byte, error) {
	ctx, cancel := appcontext.WithAPITimeout(ctx)
	defer cancel()

	var result []byte
	err := retry.RetryNetworkOperation(ctx, fmt.Sprintf("DELETE %s", path), func(attempt int) error {
		var opErr error
		result, opErr = c.request(ctx, "DELETE", path, nil)
		return opErr
	})

	return result, err
}

// Stream performs a streaming GET request for Server-Sent Events
func (c *Client) Stream(ctx context.Context, path string) (io.ReadCloser, error) {
	// No timeout for streams - managed by caller context
	url := c.baseURL + path

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, apperrors.Wrap(err, apperrors.ErrorNetwork, "REQUEST_CREATE_FAILED",
			"Failed to create stream request").
			WithContext("url", url).
			WithUserAction("Check the server URL and try again")
	}

	// Set headers
	req.Header.Set("Authorization", "Bearer "+c.token)
	req.Header.Set("Accept", "text/event-stream")
	req.Header.Set("Cache-Control", "no-cache")

	resp, err := c.httpClient.Do(req)
	if err != nil {
		// Check for timeout
		if timeoutErr := appcontext.HandleTimeout(ctx, appcontext.OpStream); timeoutErr != nil {
			return nil, timeoutErr.WithContext("url", url)
		}

		return nil, apperrors.Wrap(err, apperrors.ErrorNetwork, "STREAM_REQUEST_FAILED",
			"Stream request failed").
			WithContext("url", url).
			AsRecoverable().
			WithUserAction("Check your network connection and ArgoCD server status")
	}

	if resp.StatusCode >= 400 {
		defer resp.Body.Close()
		body, _ := io.ReadAll(resp.Body)

		return nil, c.createAPIError(resp.StatusCode, string(body), url).
			WithContext("method", "GET").
			WithContext("path", path)
	}

	return resp.Body, nil
}

// request performs the actual HTTP request
func (c *Client) request(ctx context.Context, method, path string, body interface{}) ([]byte, error) {
	url := c.baseURL + path

	var reqBody io.Reader
	if body != nil {
		jsonData, err := json.Marshal(body)
		if err != nil {
			return nil, apperrors.Wrap(err, apperrors.ErrorValidation, "JSON_MARSHAL_FAILED",
				"Failed to marshal request body").
				WithContext("method", method).
				WithContext("path", path).
				WithUserAction("Check the request data format")
		}
		reqBody = bytes.NewReader(jsonData)
	}

	req, err := http.NewRequestWithContext(ctx, method, url, reqBody)
	if err != nil {
		return nil, apperrors.Wrap(err, apperrors.ErrorNetwork, "REQUEST_CREATE_FAILED",
			"Failed to create HTTP request").
			WithContext("method", method).
			WithContext("url", url).
			WithUserAction("Check the server URL and try again")
	}

	// Set headers
	req.Header.Set("Authorization", "Bearer "+c.token)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")

	resp, err := c.httpClient.Do(req)
	if err != nil {
		// Check for timeout first - context errors have priority
		if ctx.Err() == context.DeadlineExceeded {
			return nil, apperrors.TimeoutError("REQUEST_TIMEOUT",
				"Request timed out - server may be unreachable").
				WithContext("method", method).
				WithContext("url", url).
				WithContext("timeout", "5s").
				WithUserAction("Check your connection to ArgoCD server and try again")
		}

		if ctx.Err() == context.Canceled {
			return nil, apperrors.New(apperrors.ErrorInternal, "REQUEST_CANCELLED",
				"Request was cancelled").
				WithContext("method", method).
				WithContext("url", url)
		}

		// Check if it's a network timeout from the transport layer
		if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
			return nil, apperrors.TimeoutError("NETWORK_TIMEOUT",
				"Network connection timed out").
				WithContext("method", method).
				WithContext("url", url).
				WithUserAction("Server may be unreachable - check your connection")
		}

		return nil, apperrors.Wrap(err, apperrors.ErrorNetwork, "HTTP_REQUEST_FAILED",
			"HTTP request failed").
			WithContext("method", method).
			WithContext("url", url).
			AsRecoverable().
			WithUserAction("Check your network connection and ArgoCD server status")
	}
	defer resp.Body.Close()

	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, apperrors.Wrap(err, apperrors.ErrorNetwork, "RESPONSE_READ_FAILED",
			"Failed to read response body").
			WithContext("method", method).
			WithContext("url", url).
			WithUserAction("Try the request again")
	}

	if resp.StatusCode >= 400 {
		return nil, c.createAPIError(resp.StatusCode, string(respBody), url).
			WithContext("method", method).
			WithContext("path", path)
	}

	return respBody, nil
}

// createAPIError creates a structured API error based on status code and response
func (c *Client) createAPIError(statusCode int, responseBody, url string) *apperrors.ArgonautError {
	var category apperrors.ErrorCategory
	var code string
	var message string
	var userAction string
	var recoverable bool

	switch statusCode {
	case 401:
		category = apperrors.ErrorAuth
		code = "UNAUTHORIZED"
		message = "Authentication required or token expired"
		userAction = "Please run 'argocd login' to authenticate"
		recoverable = false

	case 403:
		category = apperrors.ErrorPermission
		code = "FORBIDDEN"
		message = "Insufficient permissions for this operation"
		userAction = "Check your ArgoCD user permissions"
		recoverable = false

	case 404:
		category = apperrors.ErrorAPI
		code = "NOT_FOUND"
		message = "Requested resource not found"
		userAction = "Verify the resource exists and the path is correct"
		recoverable = false

	case 409:
		category = apperrors.ErrorValidation
		code = "CONFLICT"
		message = "Request conflicts with current state"
		userAction = "Check the current state and adjust your request"
		recoverable = true

	case 429:
		category = apperrors.ErrorAPI
		code = "RATE_LIMITED"
		message = "Too many requests - rate limited"
		userAction = "Wait a moment and try again"
		recoverable = true

	case 500, 502, 503, 504:
		category = apperrors.ErrorAPI
		code = "SERVER_ERROR"
		message = "ArgoCD server error"
		userAction = "Check ArgoCD server status and try again"
		recoverable = true

	default:
		category = apperrors.ErrorAPI
		code = "API_ERROR"
		message = fmt.Sprintf("API request failed with status %d", statusCode)
		userAction = "Check the request and try again"
		recoverable = true
	}

	// Try to extract more specific error from response body
	if responseBody != "" && len(responseBody) < 500 {
		// Check for common error patterns
		if strings.Contains(strings.ToLower(responseBody), "unauthorized") ||
			strings.Contains(strings.ToLower(responseBody), "invalid token") ||
			strings.Contains(strings.ToLower(responseBody), "authentication") {
			category = apperrors.ErrorAuth
			code = "AUTHENTICATION_FAILED"
			userAction = "Please run 'argocd login' to authenticate"
		}
	}

	err := apperrors.New(category, code, message).
		WithSeverity(apperrors.SeverityMedium).
		WithDetails(responseBody).
		WithContext("statusCode", statusCode).
		WithContext("url", url).
		WithUserAction(userAction)

	if recoverable {
		err.AsRecoverable()
	}

	return err
}
</file>

</files>
