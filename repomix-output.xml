This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: */**/*.tsx
- Files matching these patterns are excluded: __tests__
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
components/
  modals/
    ConfirmSyncModal.tsx
    HelpModal.tsx
    RollbackModal.tsx
  views/
    CommandBar.tsx
    ListView.tsx
    LoadingView.tsx
    MainLayout.tsx
    SearchBar.tsx
  App.tsx
  AuthRequiredView.tsx
  Banner.tsx
  ConfirmationBox.tsx
  ErrorBoundary.tsx
  Help.tsx
  OfficeSupplyManager.tsx
  ResourceStream.tsx
  Rollback.tsx
contexts/
  AppStateContext.tsx
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="components/modals/ConfirmSyncModal.tsx">
import { useInput } from "ink";
import type React from "react";
import { syncApp } from "../../api/applications.command";
import { useAppState } from "../../contexts/AppStateContext";
import { useStatus } from "../../hooks/useStatus";
import ConfirmationBox from "../ConfirmationBox";

export const ConfirmSyncModal: React.FC = () => {
  const { state, dispatch } = useAppState();
  const [, statusLog] = useStatus("Ready");

  const { server, apps, modals, selections } = state;
  const { confirmTarget, confirmSyncPrune, confirmSyncWatch } = modals;
  const { selectedApps } = selections;

  // Handle input for the confirm modal
  useInput((input, key) => {
    if (state.mode !== "confirm-sync") return;

    // Esc or 'q' aborts immediately
    if (key.escape || input.toLowerCase() === "q") {
      handleConfirm(false);
      return;
    }

    // Toggle prune
    if (input.toLowerCase() === "p") {
      dispatch({ type: "SET_CONFIRM_SYNC_PRUNE", payload: !confirmSyncPrune });
      return;
    }

    // Toggle watch (only when not multi)
    if (input.toLowerCase() === "w") {
      if (confirmTarget !== "__MULTI__") {
        dispatch({
          type: "SET_CONFIRM_SYNC_WATCH",
          payload: !confirmSyncWatch,
        });
      }
      return;
    }

    // All other handling is done via the ConfirmationBox component
  });

  const handleConfirm = async (yes: boolean) => {
    dispatch({ type: "SET_MODE", payload: "normal" });
    const isMulti = confirmTarget === "__MULTI__";
    const names = isMulti
      ? Array.from(selectedApps)
      : confirmTarget
        ? [confirmTarget]
        : [];

    dispatch({ type: "SET_CONFIRM_TARGET", payload: null });

    if (!yes) {
      statusLog.info("Sync cancelled.", "sync");
      return;
    }

    if (!server) {
      statusLog.error("Not authenticated.", "auth");
      return;
    }

    try {
      statusLog.info(
        `Syncing ${isMulti ? `${names.length} app(s)` : names[0]}â€¦`,
        "sync",
      );

      for (const n of names) {
        const app = apps.find((a) => a.name === n);
        syncApp(server, n, {
          prune: confirmSyncPrune,
          appNamespace: app?.appNamespace,
        });
      }

      statusLog.info(
        `Sync initiated for ${isMulti ? `${names.length} app(s)` : names[0]}.`,
        "sync",
      );

      // Show resource stream only for single-app syncs and when watch is enabled
      if (!isMulti && confirmSyncWatch) {
        dispatch({ type: "SET_SYNC_VIEW_APP", payload: names[0] });
        dispatch({ type: "SET_MODE", payload: "resources" });
      } else {
        // After syncing multiple apps, clear the selection
        if (isMulti) {
          dispatch({ type: "SET_SELECTED_APPS", payload: new Set() });
        }
      }
    } catch (e: any) {
      statusLog.error(`Sync failed: ${e.message}`, "sync");
    }
  };

  if (state.mode !== "confirm-sync" || !confirmTarget) {
    return null;
  }

  return (
    <ConfirmationBox
      title={
        confirmTarget === "__MULTI__"
          ? "Sync applications?"
          : "Sync application?"
      }
      message={
        confirmTarget === "__MULTI__"
          ? "Do you want to sync"
          : "Do you want to sync"
      }
      target={
        confirmTarget === "__MULTI__"
          ? String(selectedApps.size)
          : confirmTarget
      }
      isMulti={confirmTarget === "__MULTI__"}
      options={[
        {
          key: "p",
          label: "Prune",
          value: confirmSyncPrune,
        },
        {
          key: "w",
          label: "Watch",
          value: confirmSyncWatch,
          disabled: confirmTarget === "__MULTI__",
        },
      ]}
      onConfirm={handleConfirm}
    />
  );
};
</file>

<file path="components/modals/HelpModal.tsx">
import { Box, useInput } from "ink";
import type React from "react";
import { useAppState } from "../../contexts/AppStateContext";
import Help from "../Help";

export const HelpModal: React.FC = () => {
  const { state, dispatch } = useAppState();

  // Handle input for help modal
  useInput((input, key) => {
    if (state.mode !== "help") return;

    if (input === "q" || input === "?" || key.escape) {
      dispatch({ type: "SET_MODE", payload: "normal" });
    }
  });

  if (state.mode !== "help") {
    return null;
  }

  return (
    <Box flexDirection="column" marginTop={1} flexGrow={1}>
      <Help />
    </Box>
  );
};
</file>

<file path="components/modals/RollbackModal.tsx">
import { Box } from "ink";
import type React from "react";
import packageJson from "../../../package.json";
import { hostFromUrl } from "../../config/paths";
import { useAppState } from "../../contexts/AppStateContext";
import { fmtScope } from "../../utils";
import ArgoNautBanner from "../Banner";
import Rollback from "../Rollback";

export const RollbackModal: React.FC = () => {
  const { state, dispatch } = useAppState();

  const { mode, terminal, modals, server, apps, apiVersion, selections } =
    state;
  const { rollbackAppName } = modals;
  const { scopeClusters, scopeNamespaces, scopeProjects } = selections;

  if (mode !== "rollback" || !rollbackAppName) {
    return null;
  }

  const availableRows = terminal.rows - 8; // Estimate for header overhead

  const handleClose = () => {
    dispatch({ type: "SET_MODE", payload: "normal" });
    dispatch({ type: "SET_ROLLBACK_APP_NAME", payload: null });
  };

  const handleStartWatching = (appName: string) => {
    dispatch({ type: "SET_SYNC_VIEW_APP", payload: appName });
    dispatch({ type: "SET_MODE", payload: "resources" });
    dispatch({ type: "SET_ROLLBACK_APP_NAME", payload: null });
  };

  return (
    <Box
      flexDirection="column"
      paddingX={1}
      height={terminal.rows - 1}
      flexGrow={1}
    >
      <ArgoNautBanner
        server={server ? hostFromUrl(server.config.baseUrl) : null}
        clusterScope={fmtScope(scopeClusters)}
        namespaceScope={fmtScope(scopeNamespaces)}
        projectScope={fmtScope(scopeProjects)}
        termCols={terminal.cols}
        termRows={availableRows}
        apiVersion={apiVersion}
        argonautVersion={packageJson.version}
      />
      <Rollback
        app={rollbackAppName}
        server={server}
        appNamespace={
          apps.find((a) => a.name === rollbackAppName)?.appNamespace
        }
        onClose={handleClose}
        onStartWatching={handleStartWatching}
      />
    </Box>
  );
};
</file>

<file path="components/views/CommandBar.tsx">
import { Box, Text, useInput } from "ink";
import TextInput from "ink-text-input";
import type React from "react";
import { useState } from "react";
import type { CommandRegistry } from "../../commands";
import { getCommandAutocomplete } from "../../commands/autocomplete";
import { useAppState } from "../../contexts/AppStateContext";

interface CommandBarProps {
  commandRegistry: CommandRegistry;
  onExecuteCommand: (command: string, ...args: string[]) => void;
}

export const CommandBar: React.FC<CommandBarProps> = ({
  commandRegistry,
  onExecuteCommand,
}) => {
  const { state, dispatch } = useAppState();
  const [input, setInput] = useState(state.ui.command);
  const [error, setError] = useState<string | null>(null);
  useInput(
    (_, key) => {
      if (key.escape) {
        dispatch({ type: "SET_MODE", payload: "normal" });
        dispatch({ type: "SET_COMMAND", payload: "" });
        setInput("");
        setError(null);
      }

      if (key.tab) {
        const autoComplete = getCommandAutocomplete(
          `:${input}`,
          state,
          commandRegistry,
        );
        if (autoComplete) {
          setInput(autoComplete.completed.slice(1));
        }
      }
    },
    { isActive: state.mode === "command" },
  );

  if (state.mode !== "command") {
    return null;
  }

  const handleSubmit = (val: string) => {
    const sanitized = val.replace(/^:+/, "");
    const line = `:${sanitized}`;
    const auto = getCommandAutocomplete(line, state, commandRegistry);
    const completed = auto ? auto.completed : line;

    const { command, args } = commandRegistry.parseCommandLine(completed);

    if (!command) {
      dispatch({ type: "SET_MODE", payload: "normal" });
      dispatch({ type: "SET_COMMAND", payload: "" });
      setError(null);
      return;
    }

    if (!commandRegistry.getCommand(command)) {
      setError("Unknown command");
      process.stdout.write("\x07");
      return;
    }

    dispatch({ type: "SET_MODE", payload: "normal" });
    onExecuteCommand(command, ...args);
    dispatch({ type: "SET_COMMAND", payload: "" });
    setInput("");
    setError(null);
  };

  const userCommand = input.replace(/^:+/, "");
  const auto = getCommandAutocomplete(
    `:${userCommand}`,
    state,
    commandRegistry,
  );
  const hint = (() => {
    if (!userCommand) {
      return <Text dimColor>(Enter to run, Esc to cancel)</Text>;
    }
    const completedLine = auto ? auto.completed : `:${userCommand}`;
    const parsed = commandRegistry.parseCommandLine(completedLine);
    const command = parsed?.command ?? "";
    if (!command) {
      return <Text dimColor>(Unknown command)</Text>;
    }
    const cmd = commandRegistry.getCommand(command);

    const scopeMap: Record<string, string | null> = {
      cluster: "namespaces",
      namespace: "projects",
      project: "apps",
      app: null,
    };

    const arg = parsed.args[0];
    const nextScope = scopeMap[command];
    if (arg && nextScope !== undefined) {
      return nextScope ? (
        <Text dimColor>
          (display{" "}
          <Text bold dimColor={false}>
            {nextScope}
          </Text>{" "}
          in{" "}
          <Text color="white" dimColor={false}>
            {arg}
          </Text>{" "}
          {command})
        </Text>
      ) : (
        <Text dimColor>
          (go to app{" "}
          <Text color="white" dimColor={false}>
            {arg}
          </Text>
          )
        </Text>
      );
    }

    return <Text dimColor>({cmd?.description ?? "Unknown command"})</Text>;
  })();

  return (
    <Box
      borderStyle="round"
      borderColor={error ? "red" : "yellow"}
      paddingX={1}
    >
      <Text bold color="cyan">
        CMD
      </Text>
      <Box width={1} />
      <Text color="white">:</Text>
      <TextInput
        value={input}
        onChange={(value) => {
          const sanitized = value.replace(/^:+/, "");
          setInput(sanitized);
          if (error) {
            setError(null);
          }
        }}
        onSubmit={handleSubmit}
        showCursor={false}
      />
      {!error && auto ? <Text dimColor>{auto.suggestion}</Text> : null}
      <Box width={2} />
      {error ? <Text color="red">{error}</Text> : hint}
    </Box>
  );
};
</file>

<file path="components/views/ListView.tsx">
import { Box, Text } from "ink";
import type React from "react";
import stringWidth from "string-width";
import { useAppState } from "../../contexts/AppStateContext";
import type { AppItem } from "../../types/domain";
import { colorFor } from "../../utils";

const COL = {
  mark: 2,
  name: 36,
  sync: 4,
  health: 6,
} as const;

const GUTTER = 1;
const Sep: React.FC = () => <Box width={GUTTER} />;

interface ListViewProps {
  visibleItems: any[];
  availableRows: number;
}

export const ListView: React.FC<ListViewProps> = ({
  visibleItems,
  availableRows,
}) => {
  const { state } = useAppState();
  const { navigation, selections, terminal } = state;
  const { view, selectedIdx } = navigation;
  const { scopeClusters, scopeNamespaces, scopeProjects, selectedApps } =
    selections;

  // Calculate visible slice
  const listRows = Math.max(0, availableRows);
  const start = Math.max(
    0,
    Math.min(
      Math.max(0, selectedIdx - Math.floor(listRows / 2)),
      Math.max(0, visibleItems.length - listRows),
    ),
  );
  const end = Math.min(visibleItems.length, start + listRows);
  const rowsSlice = visibleItems.slice(start, end);

  // Layout calculations for apps view
  const MIN_NAME = 12;
  const ASCII_ICONS = {
    check: "V",
    warn: "!",
    quest: "?",
    delta: "^",
  } as const;

  const SYNC_LABEL: Record<string, string> = {
    Synced: "Synced",
    OutOfSync: "OutOfSync",
    Unknown: "Unknown",
    Degraded: "Degraded",
  };

  const HEALTH_LABEL: Record<string, string> = {
    Healthy: "Healthy",
    Missing: "Missing",
    Degraded: "Degraded",
    Progressing: "Progressing",
    Unknown: "Unknown",
  };

  const rightPadTo = (s: string, width: number) => {
    const w = stringWidth(s);
    return w >= width ? s : " ".repeat(width - w) + s;
  };

  const SYNC_WIDE = 11;
  const HEALTH_WIDE = 14;
  const overhead = 6;
  const fixedNoLastWide = SYNC_WIDE + GUTTER + HEALTH_WIDE;

  const canShowLabels = (cols: number) =>
    cols >= MIN_NAME + fixedNoLastWide + 2 * GUTTER + overhead + 15;

  const SYNC_COL = canShowLabels(terminal.cols) ? SYNC_WIDE : COL.sync;
  const HEALTH_COL = canShowLabels(terminal.cols) ? HEALTH_WIDE : COL.health;

  const SYNC_ICON_ASCII: Record<string, string> = {
    Synced: ASCII_ICONS.check,
    OutOfSync: ASCII_ICONS.delta,
    Unknown: ASCII_ICONS.quest,
    Degraded: ASCII_ICONS.warn,
  };

  const HEALTH_ICON_ASCII: Record<string, string> = {
    Healthy: ASCII_ICONS.check,
    Missing: ASCII_ICONS.quest,
    Degraded: ASCII_ICONS.warn,
    Progressing: ".",
    Unknown: ASCII_ICONS.quest,
  };

  const getSyncIcon = (s: string) => SYNC_ICON_ASCII[s];
  const getHealthIcon = (h: string) =>
    HEALTH_ICON_ASCII[h] ?? ASCII_ICONS.quest;

  return (
    <Box flexDirection="column">
      {/* Header row */}
      <Box width="100%">
        <Box flexGrow={1} flexShrink={1} minWidth={0}>
          <Text bold color="yellowBright" wrap="truncate">
            NAME
          </Text>
        </Box>

        {view === "apps" && (
          <>
            <Sep />
            <Box width={SYNC_COL} justifyContent="flex-end">
              <Text bold color="yellowBright" wrap="truncate">
                SYNC
              </Text>
            </Box>
            <Sep />
            <Box width={HEALTH_COL} justifyContent="flex-end">
              <Text bold color="yellowBright" wrap="truncate">
                HEALTH
              </Text>
            </Box>
          </>
        )}
      </Box>

      {/* Data rows */}
      {rowsSlice.map((it: any, i: number) => {
        const actualIndex = start + i;
        const isCursor = actualIndex === selectedIdx;

        if (view === "apps") {
          const a = it as AppItem;
          const isChecked = selectedApps.has(a.name);
          const active = isCursor || isChecked;

          return (
            <Box
              key={a.name}
              width="100%"
              backgroundColor={active ? "magentaBright" : undefined}
              flexWrap="nowrap"
              justifyContent="flex-start"
            >
              <Box flexGrow={1} flexShrink={1} minWidth={0}>
                <Text wrap="truncate-end">{a.name}</Text>
              </Box>

              <Sep />
              <Box width={SYNC_COL} flexShrink={0} justifyContent="flex-end">
                <Text
                  color={colorFor(a.sync).color as any}
                  dimColor={colorFor(a.sync).dimColor as any}
                >
                  {rightPadTo(
                    canShowLabels(terminal.cols)
                      ? `${getSyncIcon(a.sync)} ${SYNC_LABEL[a.sync] ?? ""}`
                      : `${getSyncIcon(a.sync)}`,
                    SYNC_COL,
                  )}
                </Text>
              </Box>

              <Sep />
              <Box width={HEALTH_COL} flexShrink={0} justifyContent="flex-end">
                <Text
                  color={colorFor(a.health).color as any}
                  dimColor={colorFor(a.health).dimColor as any}
                >
                  {rightPadTo(
                    canShowLabels(terminal.cols)
                      ? `${getHealthIcon(a.health)} ${HEALTH_LABEL[a.health] ?? ""}`
                      : `${getHealthIcon(a.health)}`,
                    HEALTH_COL,
                  )}
                </Text>
              </Box>
            </Box>
          );
        }

        // Non-apps views (clusters/namespaces/projects)
        const label = String(it);
        const isChecked =
          (view === "clusters" && scopeClusters.has(label)) ||
          (view === "namespaces" && scopeNamespaces.has(label)) ||
          (view === "projects" && scopeProjects.has(label));
        const active = isCursor || isChecked;

        return (
          <Box
            key={label}
            width="100%"
            backgroundColor={active ? "magentaBright" : undefined}
          >
            <Box flexGrow={1} flexShrink={1} minWidth={0}>
              <Text wrap="truncate-end">{label}</Text>
            </Box>
          </Box>
        );
      })}

      {visibleItems.length === 0 && (
        <Box paddingY={1} paddingX={2}>
          <Text dimColor>No items.</Text>
        </Box>
      )}
    </Box>
  );
};
</file>

<file path="components/views/LoadingView.tsx">
import chalk from "chalk";
import { Box, Text } from "ink";
import type React from "react";
import { hostFromUrl } from "../../config/paths";
import { useAppState } from "../../contexts/AppStateContext";

export const LoadingView: React.FC = () => {
  const { state } = useAppState();
  const { server, terminal } = state;

  if (state.mode !== "loading") {
    return null;
  }

  const spinChar = "â ‹";
  const loadingHeader = `${chalk.bold("View:")} ${chalk.yellow("LOADING")} â€¢ ${chalk.bold("Context:")} ${chalk.cyan(server ? hostFromUrl(server.config.baseUrl) : "â€”")}`;

  return (
    <Box
      flexDirection="column"
      borderStyle="round"
      borderColor="magenta"
      paddingX={1}
      height={terminal.rows - 1}
    >
      <Box>
        <Text>{loadingHeader}</Text>
      </Box>
      <Box flexGrow={1} alignItems="center" justifyContent="center">
        <Text color="yellow">
          {spinChar} Connecting & fetching applicationsâ€¦
        </Text>
      </Box>
      <Box>
        <Text dimColor>Startingâ€¦</Text>
      </Box>
    </Box>
  );
};
</file>

<file path="components/views/MainLayout.tsx">
import { Box, Text } from "ink";
import type React from "react";
import packageJson from "../../../package.json";
import { hostFromUrl } from "../../config/paths";
import { useAppState } from "../../contexts/AppStateContext";
import { fmtScope } from "../../utils";
import ArgoNautBanner from "../Banner";
import OfficeSupplyManager from "../OfficeSupplyManager";
import { ResourceStream } from "../ResourceStream";
import { CommandBar } from "./CommandBar";
import { ListView } from "./ListView";
import { SearchBar } from "./SearchBar";

interface MainLayoutProps {
  visibleItems: any[];
  onDrillDown: () => void;
  commandRegistry: any;
  onExecuteCommand: (command: string, ...args: string[]) => void;
  status: string;
  modal?: React.ReactNode;
}

export const MainLayout: React.FC<MainLayoutProps> = ({
  visibleItems,
  onDrillDown,
  commandRegistry,
  onExecuteCommand,
  status,
  modal,
}) => {
  const { state, dispatch } = useAppState();
  const { mode, terminal, server, apiVersion, selections, modals, ui } = state;

  const { scopeClusters, scopeNamespaces, scopeProjects } = selections;
  const { syncViewApp } = modals;

  // Height calculations
  const BORDER_LINES = 2;
  const HEADER_CONTEXT = 6;
  const SEARCH_LINES = mode === "search" ? 1 : 0;
  const TABLE_HEADER_LINES = 1;
  const TAG_LINE = 1;
  const STATUS_LINES = 1;
  const COMMAND_LINES = mode === "command" ? 1 : 0;

  const OVERHEAD =
    BORDER_LINES +
    HEADER_CONTEXT +
    SEARCH_LINES +
    TABLE_HEADER_LINES +
    TAG_LINE +
    STATUS_LINES +
    COMMAND_LINES;

  const availableRows = Math.max(0, terminal.rows - OVERHEAD);
  const barOpenExtra = mode === "search" || mode === "command" ? 1 : 0;
  const listRows = Math.max(0, availableRows - barOpenExtra);

  // Special view modes
  if (mode === "external") {
    return null;
  }

  if (mode === "rulerline") {
    return (
      <OfficeSupplyManager
        onExit={() => dispatch({ type: "SET_MODE", payload: "normal" })}
      />
    );
  }

  return (
    <Box flexDirection="column" paddingX={1} height={terminal.rows - 1}>
      <ArgoNautBanner
        server={server ? hostFromUrl(server.config.baseUrl) : null}
        clusterScope={fmtScope(scopeClusters)}
        namespaceScope={fmtScope(scopeNamespaces)}
        projectScope={fmtScope(scopeProjects)}
        termCols={terminal.cols}
        termRows={availableRows}
        apiVersion={apiVersion}
        argonautVersion={packageJson.version}
      />

      {/* Input bars between header and main content */}
      <SearchBar onSubmit={onDrillDown} />
      <CommandBar
        commandRegistry={commandRegistry}
        onExecuteCommand={onExecuteCommand}
      />

      {/* Modal appears here if present */}
      {modal}

      <Box
        flexDirection="column"
        flexGrow={1}
        borderStyle="round"
        borderColor="magenta"
        paddingX={1}
        flexWrap="nowrap"
      >
        {mode === "resources" && server && syncViewApp ? (
          <Box flexDirection="column" flexGrow={1}>
            <ResourceStream
              serverConfig={server.config}
              token={server.token}
              appName={syncViewApp}
              appNamespace={
                state.apps.find((a) => a.name === syncViewApp)?.appNamespace
              }
              onExit={() => {
                dispatch({ type: "SET_MODE", payload: "normal" });
                dispatch({ type: "SET_SYNC_VIEW_APP", payload: null });
              }}
            />
          </Box>
        ) : (
          <ListView visibleItems={visibleItems} availableRows={listRows} />
        )}
      </Box>

      {/* Status line outside the main box */}
      <Box justifyContent="space-between">
        <Box>
          <Text dimColor>
            {ui.activeFilter && state.navigation.view === "apps"
              ? `<${state.navigation.view}:${ui.activeFilter}>`
              : `<${state.navigation.view}>`}
          </Text>
        </Box>
        <Box>
          <Text dimColor>
            {status} â€¢{" "}
            {visibleItems.length
              ? `${state.navigation.selectedIdx + 1}/${visibleItems.length}`
              : "0/0"}
            {state.ui.isVersionOutdated && (
              <Text color="yellow"> â€¢ Update available!</Text>
            )}
          </Text>
        </Box>
      </Box>
    </Box>
  );
};
</file>

<file path="components/views/SearchBar.tsx">
import { Box, Text } from "ink";
import TextInput from "ink-text-input";
import type React from "react";
import { useAppState } from "../../contexts/AppStateContext";

interface SearchBarProps {
  onSubmit: () => void;
}

export const SearchBar: React.FC<SearchBarProps> = ({ onSubmit }) => {
  const { state, dispatch } = useAppState();
  const { navigation, ui } = state;

  if (state.mode !== "search") {
    return null;
  }

  const handleSubmit = () => {
    dispatch({ type: "SET_SELECTED_IDX", payload: 0 });
    dispatch({ type: "SET_MODE", payload: "normal" });

    if (navigation.view === "apps") {
      dispatch({ type: "SET_ACTIVE_FILTER", payload: ui.searchQuery });
    } else {
      onSubmit(); // For drill down in other views
    }
  };

  return (
    <Box borderStyle="round" borderColor="yellow" paddingX={1}>
      <Text bold color="cyan">
        Search
      </Text>
      <Box width={1} />
      <TextInput
        value={ui.searchQuery}
        onChange={(value) =>
          dispatch({ type: "SET_SEARCH_QUERY", payload: value })
        }
        onSubmit={handleSubmit}
      />
      <Box width={2} />
      <Text dimColor>
        (Enter{" "}
        {navigation.view === "apps" ? "keeps filter" : "opens first result"},
        Esc cancels)
      </Text>
    </Box>
  );
};
</file>

<file path="components/App.tsx">
import type React from "react";
import packageJson from "../../package.json";
import { createDefaultCommandRegistry } from "../commands";
import { hostFromUrl } from "../config/paths";
import { AppStateProvider, useAppState } from "../contexts/AppStateContext";
import { useAppLifecycle } from "../hooks/useAppLifecycle";
import { useInputSystem } from "../hooks/useInputSystem";
import { useLiveData } from "../hooks/useLiveData";
import { useNavigationLogic } from "../hooks/useNavigationLogic";
import { useStatus } from "../hooks/useStatus";
import { DefaultAppOrchestrator } from "../services/app-orchestrator";
import { fmtScope } from "../utils";
import AuthRequiredView from "./AuthRequiredView";
import { ConfirmSyncModal, HelpModal, RollbackModal } from "./modals";
import { LoadingView, MainLayout } from "./views";

// Create singleton instances
const orchestrator = new DefaultAppOrchestrator();
const commandRegistry = createDefaultCommandRegistry();

// Main App component using our clean architecture
const AppContent: React.FC = () => {
  const { state } = useAppState();

  // Initialize lifecycle management
  const { cleanupAndExit } = useAppLifecycle(orchestrator);

  // Global status management (like legacy app)
  const [status, statusLog] = useStatus("Startingâ€¦");

  // Handle navigation logic
  const { drillDown, toggleSelection, visibleItems } = useNavigationLogic();

  // Set up input system with command registry
  const { executeCommand } = useInputSystem(
    commandRegistry,
    cleanupAndExit,
    statusLog,
    {
      drillDown,
      toggleSelection,
    },
  );

  // Manage live data synchronization
  useLiveData(orchestrator, statusLog);

  // Render based on current mode
  switch (state.mode) {
    case "loading":
      return <LoadingView />;

    case "auth-required":
      return (
        <AuthRequiredView
          server={
            state.server ? hostFromUrl(state.server.config.baseUrl) : null
          }
          apiVersion={state.apiVersion}
          termCols={state.terminal.cols}
          termRows={state.terminal.rows}
          clusterScope={fmtScope(state.selections.scopeClusters)}
          namespaceScope={fmtScope(state.selections.scopeNamespaces)}
          projectScope={fmtScope(state.selections.scopeProjects)}
          argonautVersion={packageJson.version}
          message="Authentication required"
          status={status}
        />
      );

    case "help":
      return <HelpModal />;

    case "rollback":
      return <RollbackModal />;

    default:
      return (
        <MainLayout
          visibleItems={visibleItems}
          onDrillDown={drillDown}
          commandRegistry={commandRegistry}
          onExecuteCommand={executeCommand}
          status={status}
          modal={
            state.mode === "confirm-sync" ? <ConfirmSyncModal /> : null
          }
        />
      );
  }
};

// Root App component with providers
export const App: React.FC = () => {
  return (
    <AppStateProvider>
      <AppContent />
    </AppStateProvider>
  );
};
</file>

<file path="components/AuthRequiredView.tsx">
// @ts-nocheck

import chalk from "chalk";
import { Box, Text } from "ink";
import type React from "react";
import ArgoNautBanner from "./Banner";

interface Props {
  server: string | null;
  apiVersion: string;
  termCols: number;
  termRows: number;
  clusterScope: string;
  namespaceScope: string;
  projectScope: string;
  argonautVersion: string;
  message?: string;
  status: string;
}

const AuthRequiredView: React.FC<Props> = ({
  server,
  apiVersion,
  termCols,
  termRows,
  clusterScope,
  namespaceScope,
  projectScope,
  argonautVersion,
  message,
  status,
}) => {
  const headerMsg = `${chalk.bold("View:")} ${chalk.red("AUTH REQUIRED")} â€¢ ${chalk.bold("Context:")} ${chalk.cyan(server || "â€”")}`;
  const instructions = [
    "1. Run: argocd login <your-argocd-server>",
    "2. Follow prompts to authenticate",
    "3. Re-run argonaut",
  ];

  return (
    <Box flexDirection="column" paddingX={1} height={termRows - 1}>
      <ArgoNautBanner
        server={server}
        clusterScope={clusterScope}
        namespaceScope={namespaceScope}
        projectScope={projectScope}
        termCols={termCols}
        termRows={termRows}
        apiVersion={apiVersion}
        argonautVersion={argonautVersion}
      />

      <Box
        flexDirection="column"
        flexGrow={1}
        borderStyle="round"
        borderColor="red"
        paddingX={2}
        paddingY={1}
      >
        <Box
          flexGrow={1}
          alignItems="center"
          justifyContent="center"
          flexDirection="column"
        >
          <Text>{chalk.bgRed.white.bold(" AUTHENTICATION REQUIRED ")}</Text>
          <Box height={1} />
          <Text color="redBright" bold>
            {message || "Please login to ArgoCD before running argonaut."}
          </Text>
          <Box height={1} />
          {instructions.map((line) => (
            <Text key={line} dimColor>
              - {line}
            </Text>
          ))}
          <Box height={1} />
          <Text dimColor>
            Current context: {server ? chalk.cyan(server) : "unknown"}
          </Text>
          <Text dimColor>
            Press {chalk.yellow("l")} to view logs, {chalk.yellow("q")} to quit.
          </Text>
        </Box>
      </Box>

      <Box justifyContent="space-between">
        <Box>
          <Text dimColor>{headerMsg}</Text>
        </Box>
        <Box>
          <Text dimColor>{status}</Text>
        </Box>
      </Box>
    </Box>
  );
};

export default AuthRequiredView;
</file>

<file path="components/Banner.tsx">
import chalk from "chalk";
import { Box, Text } from "ink";
import type React from "react";

interface ArgoNautBannerProps {
  server?: string | null;
  clusterScope?: string;
  namespaceScope?: string;
  projectScope?: string;
  termCols?: number;
  termRows?: number;
  apiVersion?: string;
  argonautVersion?: string;
}

interface ContextProps {
  paddingBottom: number;
  paddingTop: number;
  server?: string | null;
  clusterScope?: string;
  namespaceScope?: string;
  projectScope?: string;
  apiVersion?: string;
  isNarrow: boolean;
}

interface LogoProps {
  align: "center" | "flex-end";
  paddingBottom: number;
  argonautVersion?: string;
}

const Context: React.FC<ContextProps> = ({
  paddingBottom,
  paddingTop,
  server,
  clusterScope,
  namespaceScope,
  projectScope,
  apiVersion,
  isNarrow,
}) => (
  <Box
    flexDirection="column"
    paddingRight={2}
    paddingBottom={paddingBottom || 0}
    paddingTop={paddingTop || 0}
    alignSelf={isNarrow ? undefined : "flex-end"}
  >
    {server && (
      <>
        <Text>
          <Text bold>Context:</Text> <Text color="cyan">{server || "â€”"}</Text>
        </Text>
        {clusterScope && clusterScope !== "â€”" && (
          <Text>
            <Text bold>Cluster:</Text> {clusterScope}
          </Text>
        )}
        {namespaceScope && namespaceScope !== "â€”" && (
          <Text>
            <Text bold>Namespace:</Text> {namespaceScope}
          </Text>
        )}
        {projectScope && projectScope !== "â€”" && (
          <Text>
            <Text bold>Project:</Text> {projectScope}
          </Text>
        )}
        {!isNarrow && apiVersion && (
          <Text>
            <Text bold>ArgoCD:</Text> <Text color="green">{apiVersion}</Text>
          </Text>
        )}
      </>
    )}
  </Box>
);

const Logo: React.FC<LogoProps> = ({
  align,
  paddingBottom,
  argonautVersion,
}) => (
  <Box
    flexDirection="column"
    paddingBottom={paddingBottom || 0}
    alignItems={align}
  >
    <Text>
      {chalk.cyan("     _____")}
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      {chalk.whiteBright(" __   ")}
    </Text>
    <Text>
      {chalk.cyan("  /  _  \\_______  ____   ____") +
        chalk.whiteBright("   ____ _____   __ ___/  |_ ")}
    </Text>
    <Text>
      {chalk.cyan(" /  /_\\  \\_  __ \\/ ___\\ /  _ \\ ") +
        chalk.whiteBright("/    \\\\__  \\ |  |  \\   __\\")}
    </Text>
    <Text>
      {chalk.cyan("/    |    \\  | \\/ /_/  >  <_> )  ") +
        chalk.whiteBright(" |  \\/ __ \\|  |  /|  |  ")}
    </Text>
    <Text>
      {chalk.cyan("\\____|__  /__|  \\___  / \\____/") +
        chalk.whiteBright("|___|  (____  /____/ |__|  ")}
    </Text>
    <Text>
      {chalk.cyan("        \\/     /_____/             ") +
        chalk.whiteBright(
          `\\/     \\/${chalk.dim((argonautVersion ?? "").padStart(13))}`,
        )}
    </Text>
  </Box>
);

const ArgoNautBanner: React.FC<ArgoNautBannerProps> = ({
  server,
  clusterScope,
  namespaceScope,
  projectScope,
  termCols = 80,
  apiVersion,
  argonautVersion,
}) => {
  const isNarrow = termCols <= 100; // stack vertically

  // Text-only for tiny terminals
  if (isNarrow) {
    return (
      <Box flexDirection="column" paddingTop={1}>
        <Box>
          <Text backgroundColor="cyan" color="white" bold>
            {" "}
            Argonaut {argonautVersion && `${argonautVersion}`}
          </Text>
        </Box>
        <Context
          paddingBottom={1}
          paddingTop={1}
          server={server}
          clusterScope={clusterScope}
          namespaceScope={namespaceScope}
          projectScope={projectScope}
          apiVersion={apiVersion}
          isNarrow={isNarrow}
        />
      </Box>
    );
  }

  // Wide: side-by-side, bottom-aligned
  return (
    <Box justifyContent="space-between" alignItems="flex-end">
      <Context
        paddingBottom={0}
        paddingTop={0}
        server={server}
        clusterScope={clusterScope}
        namespaceScope={namespaceScope}
        projectScope={projectScope}
        apiVersion={apiVersion}
        isNarrow={isNarrow}
      />
      <Logo
        paddingBottom={0}
        align="flex-end"
        argonautVersion={argonautVersion}
      />
    </Box>
  );
};

export default ArgoNautBanner;
</file>

<file path="components/ConfirmationBox.tsx">
import { Box, Text } from "ink";
import TextInput from "ink-text-input";
import React, { useState } from "react";

export interface ConfirmationOption {
  key: string;
  label: string;
  value: boolean;
  disabled?: boolean;
}

interface ConfirmationBoxProps {
  title: string;
  message: string;
  target?: string;
  isMulti?: boolean;
  options?: ConfirmationOption[];
  onConfirm: (confirmed: boolean) => void;
}

// TODO: handle the input completely in this component
export default function ConfirmationBox(props: ConfirmationBoxProps) {
  const {
    title,
    message,
    target,
    isMulti = false,
    options = [],
    onConfirm,
  } = props;
  const [confirmInput, setConfirmInput] = useState("");

  const handleInputChange = (val: string) => {
    const filtered = (val || "").replace(/[^a-zA-Z]/g, "").toLowerCase();
    // Allow only prefixes of y/yes or n/no
    if (/^(y(es?)?|n(o?)?)?$/.test(filtered)) {
      // Limit to max length of the longest allowed word
      setConfirmInput(filtered.slice(0, 3));
    }
    // else ignore invalid characters (do not update state)
  };

  const handleInputSubmit = (val: string) => {
    const t = (val || "").trim().toLowerCase();
    // reset input each submit
    setConfirmInput("");
    if (t === "y" || t === "yes") {
      onConfirm(true);
      return;
    }
    if (t === "n" || t === "no") {
      onConfirm(false);
      return;
    }
    if (t === "") {
      // Do nothing on empty submit
      return;
    }
    // Ignore any other input, stay in confirm mode
  };

  return (
    <Box
      borderStyle="round"
      borderColor="yellow"
      paddingX={2}
      paddingY={1}
      flexDirection="column"
      width="100%"
    >
      <Text bold>{title}</Text>
      <Box marginTop={1}>
        <Text>
          {message}{" "}
          {target && (
            <Text color="magentaBright" bold>
              {isMulti ? `(${target})` : target}
            </Text>
          )}
          ? (y/n):{" "}
        </Text>
        <TextInput
          value={confirmInput}
          onChange={handleInputChange}
          onSubmit={handleInputSubmit}
        />
      </Box>
      {options.length > 0 && (
        <Box marginTop={1}>
          <Text>
            {options.map((opt, i) => (
              <React.Fragment key={opt.key}>
                {i > 0 && " â€¢ "}
                {opt.disabled ? (
                  <Text dimColor>{opt.label}: disabled</Text>
                ) : (
                  <>
                    {opt.label} [{opt.key}]:{" "}
                    <Text color={(opt.value ? "yellow" : undefined) as any}>
                      {opt.value ? "on" : "off"}
                    </Text>
                  </>
                )}
              </React.Fragment>
            ))}
          </Text>
        </Box>
      )}
    </Box>
  );
}
</file>

<file path="components/ErrorBoundary.tsx">
import { Box, Text, useInput } from "ink";
import React, { useEffect, useState } from "react";
import { logReactError } from "../services/error-handler";
import { runLogViewerSession } from "../services/log-viewer";

interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
  errorInfo?: React.ErrorInfo;
  showLogs: boolean;
}

interface ErrorBoundaryProps {
  children: React.ReactNode;
}

export class ErrorBoundary extends React.Component<
  ErrorBoundaryProps,
  ErrorBoundaryState
> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false, showLogs: false };
  }

  static getDerivedStateFromError(error: Error): Partial<ErrorBoundaryState> {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    // Log side effects only; state is set via getDerivedStateFromError to avoid nested updates
    try {
      logReactError(error, errorInfo);
    } catch {}
    // Do not call setState here to prevent update loops
  }

  render() {
    if (this.state.hasError && this.state.error) {
      return (
        <ErrorDisplay
          error={this.state.error}
          showLogs={this.state.showLogs}
          onToggleLogs={(showLogs: boolean) => this.setState({ showLogs })}
        />
      );
    }

    return this.props.children;
  }
}

function ErrorDisplay({
  error,
  showLogs,
  onToggleLogs,
}: {
  error: Error;
  showLogs: boolean;
  onToggleLogs: (showLogs: boolean) => void;
}) {
  const [termRows, setTermRows] = useState(process.stdout.rows || 24);

  // Sometimes Ink doesn't refresh layout properly when the error boundary first renders.
  // Trigger a brief terminal resize to force a reflow so the content appears at the top.
  useEffect(() => {
    const stdout = process.stdout as any;
    if (stdout && typeof stdout.columns === "number") {
      const oldCols = stdout.columns;
      try {
        stdout.columns = Math.max(1, oldCols - 1);
        stdout.emit("resize");
      } catch {}

      const timer = setTimeout(() => {
        try {
          stdout.columns = oldCols;
          stdout.emit("resize");
        } catch {}
      }, 0);

      return () => {
        clearTimeout(timer);
        try {
          stdout.columns = oldCols;
          stdout.emit("resize");
        } catch {}
      };
    }
  }, []);

  useEffect(() => {
    const onResize = () => {
      setTermRows(process.stdout.rows || 24);
    };

    process.stdout.on("resize", onResize);
    return () => {
      process.stdout.off("resize", onResize);
    };
  }, []);
  // Handle log viewer when showLogs changes
  useEffect(() => {
    const openLogs = async () => {
      if (showLogs) {
        try {
          await runLogViewerSession({
            title: "Error Logs",
          });

          // Small delay and close logs (state change will trigger re-render)
          await new Promise((resolve) => setTimeout(resolve, 50));
          onToggleLogs(false);
        } catch {
          try {
            const stdinAny = process.stdin as any;
            stdinAny.setRawMode?.(true);
            stdinAny.resume?.();
          } catch {}
          onToggleLogs(false);
        }
      }
    };

    openLogs();
  }, [showLogs, onToggleLogs]);

  useInput((input, key) => {
    if (input === "l" || input === "L") {
      if (!showLogs) {
        onToggleLogs(true);
      }
    } else if (key.escape || input === "q") {
      process.exit(1);
    }
  });

  return (
    <Box flexDirection="column" height={termRows - 1}>
      <Box
        flexDirection="column"
        borderStyle="round"
        borderColor="red"
        paddingX={2}
        paddingY={1}
        flexGrow={1}
      >
        <Box justifyContent="center" marginBottom={1}>
          <Text color="red" bold>
            ðŸ’¥ Application Error
          </Text>
        </Box>

        <Box flexDirection="column" marginBottom={1}>
          <Text color="red">
            Something went wrong in the React application:
          </Text>
          <Text wrap="wrap">{error.message}</Text>
        </Box>

        {error.stack && (
          <Box flexDirection="column" marginBottom={1}>
            <Text color="gray" dimColor>
              Stack trace:
            </Text>
            <Text wrap="wrap" dimColor>
              {error.stack}
            </Text>
          </Box>
        )}

        <Box flexDirection="column">
          <Text dimColor>This error has been logged to the session logs.</Text>
        </Box>
      </Box>

      <Box paddingX={1} marginTop={1}>
        <Text>Press </Text>
        <Text color="cyan">L</Text>
        <Text dimColor> to view logs â€¢ </Text>
        <Text color="cyan">Q/Esc</Text>
        <Text dimColor> to exit</Text>
      </Box>
    </Box>
  );
}
</file>

<file path="components/Help.tsx">
import { Box, Text, useStdout } from "ink";
import type React from "react";

const HelpSection: React.FC<{
  title: string;
  children: React.ReactNode;
  isWide: boolean;
}> = ({ title, children, isWide }) => (
  <Box marginTop={1} flexDirection={isWide ? "row" : "column"}>
    <Box width={isWide ? 12 : undefined} marginBottom={isWide ? 0 : 0}>
      <Text color="green" bold>
        {title}
      </Text>
    </Box>
    <Box flexShrink={1} flexWrap="wrap">
      {children}
    </Box>
  </Box>
);

const Help: React.FC = () => {
  const { stdout } = useStdout();
  const terminalWidth = stdout?.columns || 80;
  const isWide = terminalWidth >= 60;

  return (
    <Box flexDirection="column" paddingX={1} paddingY={1}>
      <HelpSection title="GENERAL" isWide={isWide}>
        <Text>
          <Text color="cyan">:</Text> command â€¢ <Text color="cyan">/</Text>{" "}
          search â€¢ <Text color="cyan">?</Text> help
        </Text>
      </HelpSection>

      <HelpSection title="NAV" isWide={isWide}>
        <Text>
          <Text color="cyan">j/k</Text> up/down â€¢{" "}
          <Text color="cyan">Space</Text> select â€¢{" "}
          <Text color="cyan">Enter</Text> drill down â€¢{" "}
          <Text color="cyan">Esc</Text> clear/up
        </Text>
      </HelpSection>

      <HelpSection title="VIEWS" isWide={isWide}>
        <Box flexDirection="column">
          <Text>
            <Text color="cyan">:cls</Text>|<Text color="cyan">:clusters</Text>|
            <Text color="cyan">:cluster</Text> â€¢ <Text color="cyan">:ns</Text>|
            <Text color="cyan">:namespaces</Text>|
            <Text color="cyan">:namespace</Text>
          </Text>
          <Text>
            <Text color="cyan">:proj</Text>|<Text color="cyan">:projects</Text>|
            <Text color="cyan">:project</Text> â€¢ <Text color="cyan">:apps</Text>
          </Text>
        </Box>
      </HelpSection>

      <HelpSection title="ACTIONS" isWide={isWide}>
        <Box flexDirection="column">
          <Text>
            <Text color="cyan">:diff</Text> [app] â€¢{" "}
            <Text color="cyan">:sync</Text> [app] â€¢{" "}
            <Text color="cyan">:rollback</Text> [app]
          </Text>
          <Text>
            <Text color="cyan">:up</Text> go up level
          </Text>
          <Text>
            <Text color="cyan">s</Text> sync modal (apps view)
          </Text>
        </Box>
      </HelpSection>

      <HelpSection title="MISC" isWide={isWide}>
        <Box flexDirection="column">
          <Text>
            <Text color="cyan">:all</Text> â€¢ <Text color="cyan">:licenses</Text>
          </Text>
          <Text>
            <Text color="cyan">:logs</Text> â€¢ <Text color="cyan">:q</Text>
          </Text>
        </Box>
      </HelpSection>

      <Box marginTop={1} justifyContent="center">
        <Text dimColor>Press ?, q or Esc to close</Text>
      </Box>
    </Box>
  );
};

export default Help;
</file>

<file path="components/OfficeSupplyManager.tsx">
import { Box, Text, useInput } from "ink";
import React, { useEffect, useState } from "react";
import {
  DESK_HEIGHT,
  DESK_WIDTH,
  getPaperclipInventory,
  STAPLER_SPEED,
} from "./PaperclipDatabase";

export const rulerLineMode = String.fromCharCode(
  105,
  108,
  105,
  107,
  101,
  97,
  114,
  103,
  111,
  110,
  97,
  117,
  116,
);

interface OfficeSupplyProps {
  onExit: () => void;
}

// Pre-load office supplies at module level for instant access
let cachedSupplies: string[] | null = null;

const loadSupplies = (): string[] => {
  if (cachedSupplies === null) {
    try {
      console.log("Loading office supplies...");
      cachedSupplies = getPaperclipInventory();
      console.log(`Loaded ${cachedSupplies.length} supplies`);
      if (cachedSupplies.length > 0) {
        console.log(
          `First supply dimensions: ${cachedSupplies[0].split("\n").length} lines`,
        );
      }
    } catch (error) {
      console.error("Failed to load office supplies:", error);
      cachedSupplies = [];
    }
  }
  return cachedSupplies;
};

const OfficeSupplyManager: React.FC<OfficeSupplyProps> = ({ onExit }) => {
  const [supplies] = useState<string[]>(() => loadSupplies()); // Load immediately
  const [currentSupply, setCurrentSupply] = useState(0);
  const [termRows, setTermRows] = useState(process.stdout.rows || 24);
  const [termCols, setTermCols] = useState(process.stdout.columns || 80);

  useInput((input) => {
    if (input.toLowerCase() === "q") {
      onExit();
    }
  });

  // Track terminal resize
  React.useEffect(() => {
    const onResize = () => {
      setTermRows(process.stdout.rows || 24);
      setTermCols(process.stdout.columns || 80);
    };
    process.stdout.on("resize", onResize);
    return () => {
      process.stdout.off("resize", onResize);
    };
  }, []);

  useEffect(() => {
    if (supplies.length === 0) return;

    const interval = setInterval(() => {
      setCurrentSupply((prev) => (prev + 1) % supplies.length);
    }, 1000 / STAPLER_SPEED);

    return () => clearInterval(interval);
  }, [supplies.length]);

  if (supplies.length === 0) {
    return (
      <Box
        flexDirection="column"
        alignItems="center"
        justifyContent="center"
        height={termRows}
      >
        <Text color="red">Could not load office supplies</Text>
        <Text color="gray">Press 'q' to return</Text>
      </Box>
    );
  }

  const currentSupplyContent = supplies[currentSupply] || "";

  // Use the normalized desk dimensions (all supplies are now the same size)
  const deskHeight = DESK_HEIGHT;
  const deskWidth = DESK_WIDTH;

  // Add space for "weeeeee" text and "Press 'q'" instruction (3 extra lines)
  const requiredHeight = deskHeight + 5; // desk + spacing + weee + spacing + instruction
  const requiredWidth = Math.max(deskWidth, 30); // desk width or min width for text

  // Check if terminal is too small
  if (termCols < requiredWidth || termRows < requiredHeight) {
    return (
      <Box
        flexDirection="column"
        alignItems="center"
        justifyContent="center"
        height={termRows}
      >
        <Text color="yellow" bold>
          Terminal too small for office supplies!
        </Text>
        <Box marginTop={1}>
          <Text color="cyan">
            Current size: {termCols}x{termRows}
          </Text>
        </Box>
        <Box marginTop={1}>
          <Text color="cyan">
            Required size: {requiredWidth}x{requiredHeight}
          </Text>
        </Box>
        <Box marginTop={2}>
          <Text color="gray">Make your terminal bigger and try again</Text>
        </Box>
        <Box marginTop={1}>
          <Text color="gray">Press 'q' to return</Text>
        </Box>
      </Box>
    );
  }

  return (
    <Box
      flexDirection="column"
      height={termRows}
      alignItems="center"
      justifyContent="center"
    >
      {/* Office supply display */}
      <Box flexDirection="column" alignItems="center">
        <Text>{currentSupplyContent}</Text>
      </Box>
      {/* Fixed spacing below the animation */}
      <Box marginTop={1}>
        <Text color="yellow" bold>
          I like you too!
        </Text>
      </Box>
      <Box marginTop={1}>
        <Text color="gray">Press 'q' to return</Text>
      </Box>
    </Box>
  );
};

export default OfficeSupplyManager;
</file>

<file path="components/ResourceStream.tsx">
import { Box, Text, useInput } from "ink";
import type React from "react";
import { useEffect, useState } from "react";
import { getHttpClient } from "../services/http-client";
import type { ServerConfig } from "../types/server";
import { colorFor } from "../utils";

// Types for streamed resources
export type Health = { status?: string; message?: string };
export type ResourceNode = {
  group?: string;
  kind: string;
  name: string;
  namespace?: string;
  version?: string;
  health?: Health;
};
export type ApplicationTree = {
  nodes?: ResourceNode[];
};

export type ApplicationWatchEvent = {
  application?: {
    status?: {
      resources?: Array<{
        group?: string;
        kind?: string;
        name?: string;
        namespace?: string;
        version?: string;
        status?: string; // Synced | OutOfSync | Unknown
      }>;
    };
  };
};

// Stream NDJSON from ArgoCD streaming API; yields objects at obj.result
export async function* streamJsonResults<T>(
  serverConfig: ServerConfig,
  token: string,
  path: string,
  signal?: AbortSignal,
): AsyncGenerator<T> {
  const client = getHttpClient(serverConfig, token);
  const stream = await client.stream(path, { signal });

  const decoder = new TextDecoder();
  let buffer = "";

  try {
    for await (const chunk of stream) {
      if (signal?.aborted) return;

      // Convert chunk to Uint8Array if it's a Buffer
      const uint8Array =
        chunk instanceof Buffer ? new Uint8Array(chunk) : (chunk as Uint8Array);
      buffer += decoder.decode(uint8Array, { stream: true });

      let nl = buffer.indexOf("\n");
      while (nl >= 0) {
        const line = buffer.slice(0, nl).trim();
        buffer = buffer.slice(nl + 1);
        if (line) {
          try {
            const obj = JSON.parse(line);
            if (obj?.result) yield obj.result as T;
          } catch {
            // tolerate partial/non-NDJSON frames; keep buffering
          }
        }
        nl = buffer.indexOf("\n");
      }
    }

    if (buffer.trim()) {
      try {
        const obj = JSON.parse(buffer.trim());
        if (obj?.result) yield obj.result as T;
      } catch {
        /* ignore */
      }
    }
  } catch (e: any) {
    if (e?.message === "Request aborted" || signal?.aborted) return;
    throw e;
  }
}

const keyFor = (n: {
  group?: string;
  kind?: string;
  namespace?: string;
  name?: string;
  version?: string;
}) =>
  `${n.group || ""}/${n.kind || ""}/${n.namespace || ""}/${n.name || ""}/${n.version || ""}`;

function ResourceRow({
  r,
  syncByKey,
}: {
  r: ResourceNode;
  syncByKey: Record<string, string>;
}) {
  const status = r.health?.status ?? "-";
  const statusColor = colorFor(status);
  const syncVal = syncByKey[keyFor(r)] ?? "-";
  const syncColor = colorFor(syncVal);
  const pad = (val: string) => val.padStart(12).slice(-12);
  return (
    <Box width="100%">
      <Box width={13} flexShrink={0}>
        <Text wrap="truncate">{r.kind}</Text>
      </Box>
      <Box width={1} flexShrink={0} />
      <Box flexGrow={1} flexShrink={1} minWidth={0}>
        <Text wrap="truncate-end">{r.name}</Text>
      </Box>
      <Box width={1} flexShrink={0} />
      <Box width={12} flexShrink={0} justifyContent="flex-end">
        <Text
          color={syncColor.color as any}
          dimColor={syncColor.dimColor as any}
          wrap="truncate"
        >
          {pad(syncVal)}
        </Text>
      </Box>
      <Box width={1} flexShrink={0} />
      <Box width={12} flexShrink={0} justifyContent="flex-end">
        <Text
          color={statusColor.color as any}
          dimColor={statusColor.dimColor as any}
          wrap="truncate"
        >
          {pad(status)}
        </Text>
      </Box>
    </Box>
  );
}

function Table({
  rows,
  syncByKey,
}: {
  rows: ResourceNode[];
  syncByKey: Record<string, string>;
}) {
  return (
    <Box flexDirection="column">
      <Box>
        <Box width={13} flexShrink={0}>
          <Text bold color="yellowBright">
            KIND
          </Text>
        </Box>
        <Box width={1} flexShrink={0} />
        <Box flexGrow={1} flexShrink={1} minWidth={0}>
          <Text bold color="yellowBright">
            NAME
          </Text>
        </Box>
        <Box width={1} flexShrink={0} />
        <Box width={12} flexShrink={0} justifyContent="flex-end">
          <Text bold color="yellowBright">
            SYNC
          </Text>
        </Box>
        <Box width={1} flexShrink={0} />
        <Box width={12} flexShrink={0} justifyContent="flex-end">
          <Text bold color="yellowBright">
            STATUS
          </Text>
        </Box>
      </Box>
      {rows.map((r, i) => (
        <ResourceRow
          key={`${r.kind}//${r.name}/${i}`}
          r={r}
          syncByKey={syncByKey}
        />
      ))}
    </Box>
  );
}

export type ResourceStreamProps = {
  serverConfig: ServerConfig; // Server configuration with baseUrl and insecure flag
  token: string; // Argo CD JWT
  appName: string; // Application name
  appNamespace?: string; // Application control plane namespace
  onExit?: () => void; // called when user quits the view (press 'q')
};

export const ResourceStream: React.FC<ResourceStreamProps> = ({
  serverConfig,
  token,
  appName,
  appNamespace,
  onExit,
}) => {
  const [rows, setRows] = useState<ResourceNode[]>([]);
  const [hint, setHint] = useState("Press q or Esc to return");
  const [syncByKey, setSyncByKey] = useState<Record<string, string>>({});

  // Initial fetch: resource tree (non-streaming) so view has immediate data
  useEffect(() => {
    const controller = new AbortController();
    const client = getHttpClient(serverConfig, token);
    const params = new URLSearchParams();
    if (appNamespace) params.set("appNamespace", appNamespace);
    const path = `/api/v1/applications/${encodeURIComponent(appName)}/resource-tree${params.toString() ? `?${params.toString()}` : ""}`;
    (async () => {
      try {
        const tree: ApplicationTree = await client.get(path, {
          signal: controller.signal,
        });
        const next = (tree.nodes ?? []).map((n) => ({
          group: (n as any).group,
          kind: n.kind,
          name: n.name,
          namespace: n.namespace,
          version: (n as any).version,
          health: n.health,
        }));
        setRows(next);
      } catch (err: any) {
        const msg = String(err?.message ?? err);
        if (!/aborted|Request aborted/i.test(msg)) {
          setHint((h) =>
            h.includes("Stream error") ? h : `Load error: ${msg}`,
          );
        }
      }
    })();
    return () => controller.abort();
  }, [serverConfig, token, appName, appNamespace]);

  // Stream: resource tree updates
  useEffect(() => {
    let cancel = false;
    const controller = new AbortController();
    const params = new URLSearchParams();
    if (appNamespace) params.set("appNamespace", appNamespace);
    const path = `/api/v1/stream/applications/${encodeURIComponent(appName)}/resource-tree${params.toString() ? `?${params.toString()}` : ""}`;
    (async () => {
      try {
        for await (const tree of streamJsonResults<ApplicationTree>(
          serverConfig,
          token,
          path,
          controller.signal,
        )) {
          if (cancel) break;
          const next = (tree.nodes ?? []).map((n) => ({
            group: (n as any).group,
            kind: n.kind,
            name: n.name,
            namespace: n.namespace,
            version: (n as any).version,
            health: n.health,
          }));
          setRows(next);
        }
      } catch (err: any) {
        const msg = String(err?.message ?? err);
        if (!/aborted|Request aborted/i.test(msg)) {
          setHint(`Stream error: ${msg}`);
        }
      }
    })();
    return () => {
      cancel = true;
      controller.abort();
    };
  }, [serverConfig, token, appName, appNamespace]);

  // Initial fetch: application status -> syncByKey
  useEffect(() => {
    const controller = new AbortController();
    const client = getHttpClient(serverConfig, token);
    const params = new URLSearchParams();
    if (appNamespace) params.set("appNamespace", appNamespace);
    const path = `/api/v1/applications/${encodeURIComponent(appName)}${params.toString() ? `?${params.toString()}` : ""}`;
    (async () => {
      try {
        const app = await client.get(path, { signal: controller.signal });
        const resources = app?.status?.resources || [];
        if (Array.isArray(resources)) {
          const m: Record<string, string> = {};
          for (const r of resources) {
            const k = keyFor(r as any);
            if (k) m[k] = (r as any).status || "-";
          }
          setSyncByKey(m);
        }
      } catch (err: any) {
        const msg = String(err?.message ?? err);
        if (!/aborted|Request aborted/i.test(msg)) {
          setHint((h) => (h.includes("Stream error") ? h : `${h}`));
        }
      }
    })();
    return () => controller.abort();
  }, [serverConfig, token, appName, appNamespace]);

  // Stream application watch events to derive per-resource sync status
  useEffect(() => {
    const controller = new AbortController();
    const params = new URLSearchParams();
    params.set("name", appName);
    if (appNamespace) params.set("appNamespace", appNamespace);
    const path = `/api/v1/stream/applications?${params.toString()}`;
    (async () => {
      try {
        for await (const evt of streamJsonResults<ApplicationWatchEvent>(
          serverConfig,
          token,
          path,
          controller.signal,
        )) {
          const resources = evt?.application?.status?.resources || [];
          if (!resources || !Array.isArray(resources)) continue;
          const m: Record<string, string> = {};
          for (const r of resources) {
            const k = keyFor(r as any);
            if (k) m[k] = r.status || "-";
          }
          setSyncByKey(m);
        }
      } catch (err: any) {
        const msg = String(err?.message ?? err);
        if (!/aborted|Request aborted/i.test(msg)) {
          // Don't override main hint if already set; append minimal info
          setHint((h) => (h.includes("Stream error") ? h : `${h}`));
        }
      }
    })();
    return () => controller.abort();
  }, [serverConfig, token, appName, appNamespace]);

  useInput((input, key) => {
    const ch = (input || "").toLowerCase();
    if (ch === "q" || key?.escape) {
      onExit?.();
    }
  });

  return (
    <Box flexDirection="column">
      <Text bold>Resources for: {appName}</Text>
      <Box paddingTop={1} />
      <Table rows={rows} syncByKey={syncByKey} />
      <Box marginTop={1}>
        <Text dimColor>{hint}</Text>
      </Box>
    </Box>
  );
};
</file>

<file path="components/Rollback.tsx">
import { Box, Text, useInput } from "ink";
import { useEffect, useRef, useState } from "react";
import {
  getApplication as getAppApi,
  getRevisionMetadata as getRevisionMetadataApi,
  postRollback as postRollbackApi,
} from "../api/rollback";
import type { Server } from "../types/server";
import { humanizeSince, shortSha, singleLine } from "../utils";
import ConfirmationBox from "./ConfirmationBox";
import { runRollbackDiffSession } from "./DiffView";

export type RollbackRow = {
  id: number;
  revision: string;
  deployedAt?: string;
  author?: string;
  date?: string;
  message?: string;
  metaError?: string;
};

interface RollbackProps {
  app: string;
  server: Server | null;
  appNamespace?: string;
  onClose: () => void;
  onStartWatching: (appName: string) => void;
}

export default function Rollback(props: RollbackProps) {
  const { app, server, appNamespace, onClose, onStartWatching } = props;

  type SubMode = "list" | "confirm";
  const [subMode, setSubMode] = useState<SubMode>("list");
  const [fromRev, setFromRev] = useState<string | undefined>(undefined);
  const [rows, setRows] = useState<RollbackRow[]>([]);
  const [idx, setIdx] = useState(0);
  const [error, setError] = useState("");
  const [filter, setFilter] = useState("");
  const [prune, setPrune] = useState(false);
  const [watch, setWatch] = useState(true);
  const [metaLoadingKey, setMetaLoadingKey] = useState<string | null>(null);
  const metaAbortRef = useRef<AbortController | null>(null);

  // Vim-style navigation state for gg
  const [lastGPressed, setLastGPressed] = useState<number>(0);

  // Initial fetch of app history and current revision
  useEffect(() => {
    (async () => {
      try {
        if (!server) {
          setError("Not authenticated.");
          setRows([]);
          return;
        }
        const appObj = await getAppApi(server, app, appNamespace).catch(
          () => ({}) as any,
        );
        const from =
          appObj?.status?.sync?.revision ??
          appObj?.status?.history?.[0]?.revisions?.[0] ??
          "";
        setFromRev(from || undefined);
        const hist = Array.isArray(appObj?.status?.history)
          ? [...appObj.status.history]
          : [];
        const r: RollbackRow[] = hist
          .map((h: any) => ({
            id: Number(h?.id ?? 0),
            revision: String(h?.revision ?? h?.revisions?.[0] ?? ""),
            deployedAt: h?.deployedAt,
          }))
          .filter((h) => h.id > 0 && h.revision)
          .sort((a, b) => b.id - a.id);
        if (!r.length) {
          setError("No previous syncs found.");
          setRows([]);
        } else {
          setError("");
          setRows(r);
        }
        setIdx(0);
        setFilter("");
        setSubMode("list");
      } catch (e: any) {
        setError(e?.message || String(e));
        setRows([]);
        setIdx(0);
        setFilter("");
        setSubMode("list");
      }
    })();
    return () => {
      try {
        metaAbortRef.current?.abort();
      } catch {}
    };
  }, [app, server, appNamespace]);

  // Fetch revision metadata for highlighted row
  useEffect(() => {
    if (subMode !== "list") return;
    if (!server) return;
    const row = rows[idx];
    if (!row || row.author) return;
    try {
      metaAbortRef.current?.abort();
    } catch {}
    const ac = new AbortController();
    metaAbortRef.current = ac;
    const key = `${app}:${row.id}:${row.revision}`;
    setMetaLoadingKey(key);
    (async () => {
      try {
        const meta = await getRevisionMetadataApi(
          server,
          app,
          row.revision,
          appNamespace,
          ac.signal,
        );
        const upd = [...rows];
        upd[idx] = {
          ...row,
          author: meta?.author,
          date: meta?.date,
          message: meta?.message,
        };
        setRows(upd);
      } catch (e: any) {
        const upd = [...rows];
        upd[idx] = { ...row, metaError: e?.message || String(e) };
        setRows(upd);
      } finally {
        setMetaLoadingKey((prev) => (prev === key ? null : prev));
      }
    })();
    return () => {
      try {
        ac.abort();
      } catch {}
    };
  }, [subMode, idx, rows, app, server, appNamespace]);

  // Key handling inside rollback overlay
  useInput((input, key) => {
    if (subMode === "list") {
      if (key.escape || input === "q") {
        onClose();
        return;
      }
      if (input === "j" || key.downArrow) {
        setIdx((i) =>
          Math.min(
            i + 1,
            Math.max(
              0,
              rows.filter((r) => filterRollbackRow(r, filter)).length - 1,
            ),
          ),
        );
        return;
      }
      if (input === "k" || key.upArrow) {
        setIdx((i) => Math.max(i - 1, 0));
        return;
      }

      // Vim-style navigation: gg to go to top, G to go to bottom
      if (input === "g") {
        const now = Date.now();
        if (now - lastGPressed < 500) {
          // 500ms window for double g
          setIdx(0); // Go to top
        }
        setLastGPressed(now);
        return;
      }
      if (input === "G") {
        const filteredLength = rows.filter((r) =>
          filterRollbackRow(r, filter),
        ).length;
        setIdx(Math.max(0, filteredLength - 1)); // Go to bottom
        return;
      }
      if (input.toLowerCase() === "d") {
        runRollbackDiff();
        return;
      }
      if (key.return) {
        if (idx !== 0) {
          setSubMode("confirm");
        }
        return;
      }
      if (input.toLowerCase() === "p") {
        setPrune((v) => !v);
        return;
      }
      return;
    }
    if (subMode === "confirm") {
      if (key.escape || input === "q") {
        setSubMode("list");
        return;
      }
      if (input.toLowerCase() === "p") {
        setPrune((v) => !v);
        return;
      }
      if (input.toLowerCase() === "w") {
        setWatch((v) => !v);
        return;
      }
      // All other handling is done via the ConfirmationBox component
      return;
    }
  });

  async function runRollbackDiff() {
    if (!server) {
      setError("Not authenticated.");
      return;
    }
    const row = rows[idx];
    if (!row) {
      setError("No selection to diff.");
      return;
    }
    try {
      const opened = await runRollbackDiffSession(
        server,
        app,
        row.revision,
        {
          title: `${app} - Current vs ${row.revision}`,
        },
        appNamespace,
      );
      if (!opened) setError("No differences.");
    } catch (e: any) {
      setError(`Diff failed: ${e?.message || String(e)}`);
    }
  }

  async function executeRollback(confirm: boolean) {
    if (!confirm) {
      setSubMode("list");
      setError("Rollback cancelled.");
      return;
    }
    const row = rows[idx];
    if (!server || !row) {
      setError("Not ready.");
      return;
    }
    try {
      await postRollbackApi(server, app, {
        id: row.id,
        name: app,
        dryRun: false,
      });
      // Start watching via resources view and close rollback
      if (watch) onStartWatching(app);
      else onClose();
    } catch (e: any) {
      setError(e?.message || String(e));
      setSubMode("confirm");
    }
  }

  // Render
  const row = rows[idx];

  return (
    <>
      {/* Rollback confirmation box (rendered outside the bordered container) */}
      {subMode === "confirm" && row && (
        <Box marginTop={1}>
          <ConfirmationBox
            title="Confirm rollback"
            message={`Rollback ${app} from ${shortSha(fromRev)} to`}
            target={shortSha(row.revision)}
            options={[
              { key: "p", label: "Prune", value: prune },
              {
                key: "w",
                label: "Watch",
                value: watch,
              },
            ]}
            onConfirm={(confirmed) => executeRollback(confirmed)}
          />
        </Box>
      )}

      <Box
        flexDirection="column"
        marginTop={1}
        flexGrow={1}
        borderStyle="round"
        borderColor="magenta"
        paddingX={1}
        flexWrap="nowrap"
      >
        <Box flexDirection="column" marginTop={1} flexGrow={1}>
          <Box paddingX={1} flexDirection="column">
            <Text bold>
              Rollback: <Text color="magentaBright">{app}</Text>
            </Text>
            <Box marginTop={1}>
              <Text>
                Current revision: <Text color="cyan">{shortSha(fromRev)}</Text>
              </Text>
            </Box>
            {error && (
              <Box marginTop={1}>
                <Text color="red">{error}</Text>
              </Box>
            )}
            <Box marginTop={1} flexDirection="column">
              <Box>
                <Box width={6}>
                  <Text bold>ID</Text>
                </Box>
                <Box width={10}>
                  <Text bold>Revision</Text>
                </Box>
                <Box width={20}>
                  <Text bold>Deployed</Text>
                </Box>
                <Box flexGrow={1}>
                  <Text bold>Message</Text>
                </Box>
              </Box>
              {(() => {
                const filtered = rows.filter((r) =>
                  filterRollbackRow(r, filter),
                );
                const maxRows = Math.max(1, Math.min(10, filtered.length));
                const start = Math.max(
                  0,
                  Math.min(
                    idx - Math.floor(maxRows / 2),
                    Math.max(0, filtered.length - maxRows),
                  ),
                );
                const slice = filtered.slice(start, start + maxRows);
                return slice.map((r: RollbackRow, i: number) => {
                  const actual = start + i;
                  const active = actual === idx;
                  return (
                    <Box
                      key={`${r.id}-${r.revision}`}
                      backgroundColor={active ? "magentaBright" : undefined}
                    >
                      <Box width={6}>
                        <Text>{String(r.id)}</Text>
                      </Box>
                      <Box width={10}>
                        <Text>{shortSha(r.revision)}</Text>
                      </Box>
                      <Box width={20}>
                        <Text>
                          {r.deployedAt
                            ? `${humanizeSince(r.deployedAt)} ago`
                            : "â€”"}
                        </Text>
                      </Box>
                      <Box flexGrow={1}>
                        <Text wrap="truncate-end">
                          {metaLoadingKey === `${app}:${r.id}:${r.revision}`
                            ? "(loadingâ€¦)"
                            : singleLine(r.message || r.metaError || "")}
                        </Text>
                      </Box>
                    </Box>
                  );
                });
              })()}
            </Box>
            <Box marginTop={1}>
              <Text dimColor>
                j/k to move â€¢ d diff â€¢ p prune â€¢ Enter confirm â€¢ Esc/q cancel
              </Text>
            </Box>
          </Box>
        </Box>
        <Box flexGrow={1} />
      </Box>
    </>
  );
}

function filterRollbackRow(row: RollbackRow, f: string): boolean {
  const q = (f || "").toLowerCase();
  if (!q) return true;
  const fields = [
    String(row.id || ""),
    String(row.revision || ""),
    String(row.author || ""),
    String(row.date || ""),
    String(row.message || ""),
  ];
  return fields.some((s) => s.toLowerCase().includes(q));
}
</file>

<file path="contexts/AppStateContext.tsx">
import React, {
  createContext,
  type ReactNode,
  useContext,
  useReducer,
} from "react";
import type { AppItem, Mode, View } from "../types/domain";
import type { Server } from "../types/server";

// State interfaces
export interface TerminalState {
  rows: number;
  cols: number;
}

export interface NavigationState {
  view: View;
  selectedIdx: number;
  lastGPressed: number;
  lastEscPressed: number;
}

export interface SelectionState {
  scopeClusters: Set<string>;
  scopeNamespaces: Set<string>;
  scopeProjects: Set<string>;
  selectedApps: Set<string>;
}

export interface UIState {
  searchQuery: string;
  activeFilter: string;
  command: string;
  isVersionOutdated: boolean;
  latestVersion?: string;
  commandInputKey: number;
}

export interface ModalState {
  confirmTarget: string | null;
  confirmSyncPrune: boolean;
  confirmSyncWatch: boolean;
  rollbackAppName: string | null;
  syncViewApp: string | null;
}

export interface AppState {
  // Core state
  mode: Mode;
  terminal: TerminalState;
  navigation: NavigationState;
  selections: SelectionState;
  ui: UIState;
  modals: ModalState;

  // Data
  server: Server | null;
  apps: AppItem[];
  apiVersion: string;

  // Cleanup
  loadingAbortController: AbortController | null;
}

// Action types
export type AppAction =
  | { type: "SET_MODE"; payload: Mode }
  | { type: "SET_TERMINAL_SIZE"; payload: { rows: number; cols: number } }
  | { type: "SET_VIEW"; payload: View }
  | { type: "SET_SELECTED_IDX"; payload: number }
  | { type: "SET_SERVER"; payload: Server | null }
  | { type: "SET_APPS"; payload: AppItem[] }
  | { type: "SET_API_VERSION"; payload: string }
  | { type: "SET_SEARCH_QUERY"; payload: string }
  | { type: "SET_ACTIVE_FILTER"; payload: string }
  | { type: "SET_COMMAND"; payload: string }
  | { type: "BUMP_COMMAND_INPUT_KEY" }
  | { type: "SET_SCOPE_CLUSTERS"; payload: Set<string> }
  | { type: "SET_SCOPE_NAMESPACES"; payload: Set<string> }
  | { type: "SET_SCOPE_PROJECTS"; payload: Set<string> }
  | { type: "SET_SELECTED_APPS"; payload: Set<string> }
  | { type: "SET_CONFIRM_TARGET"; payload: string | null }
  | { type: "SET_CONFIRM_SYNC_PRUNE"; payload: boolean }
  | { type: "SET_CONFIRM_SYNC_WATCH"; payload: boolean }
  | { type: "SET_ROLLBACK_APP_NAME"; payload: string | null }
  | { type: "SET_SYNC_VIEW_APP"; payload: string | null }
  | { type: "SET_VERSION_OUTDATED"; payload: boolean }
  | { type: "SET_LATEST_VERSION"; payload: string | undefined }
  | { type: "SET_LAST_G_PRESSED"; payload: number }
  | { type: "SET_LAST_ESC_PRESSED"; payload: number }
  | { type: "SET_LOADING_ABORT_CONTROLLER"; payload: AbortController | null }
  | { type: "CLEAR_LOWER_LEVEL_SELECTIONS"; payload: View }
  | { type: "RESET_NAVIGATION"; payload?: { view?: View } }
  | { type: "CLEAR_ALL_SELECTIONS" }
  | { type: "CLEAR_FILTERS" };

// Initial state
export const initialState: AppState = {
  mode: "loading",
  terminal: {
    rows: process.stdout.rows || 24,
    cols: process.stdout.columns || 80,
  },
  navigation: {
    view: "clusters",
    selectedIdx: 0,
    lastGPressed: 0,
    lastEscPressed: 0,
  },
  selections: {
    scopeClusters: new Set(),
    scopeNamespaces: new Set(),
    scopeProjects: new Set(),
    selectedApps: new Set(),
  },
  ui: {
    searchQuery: "",
    activeFilter: "",
    command: "",
    isVersionOutdated: false,
    latestVersion: undefined,
    commandInputKey: 0,
  },
  modals: {
    confirmTarget: null,
    confirmSyncPrune: false,
    confirmSyncWatch: true,
    rollbackAppName: null,
    syncViewApp: null,
  },
  server: null,
  apps: [],
  apiVersion: "",
  loadingAbortController: null,
};

// Reducer
export function appStateReducer(state: AppState, action: AppAction): AppState {
  switch (action.type) {
    case "SET_MODE":
      return { ...state, mode: action.payload };

    case "SET_TERMINAL_SIZE":
      return {
        ...state,
        terminal: { ...state.terminal, ...action.payload },
      };

    case "SET_VIEW":
      return {
        ...state,
        navigation: { ...state.navigation, view: action.payload },
      };

    case "SET_SELECTED_IDX":
      return {
        ...state,
        navigation: { ...state.navigation, selectedIdx: action.payload },
      };

    case "SET_SERVER":
      return { ...state, server: action.payload };

    case "SET_APPS":
      return { ...state, apps: action.payload };

    case "SET_API_VERSION":
      return { ...state, apiVersion: action.payload };

    case "SET_SEARCH_QUERY":
      return {
        ...state,
        ui: { ...state.ui, searchQuery: action.payload },
      };

    case "SET_ACTIVE_FILTER":
      return {
        ...state,
        ui: { ...state.ui, activeFilter: action.payload },
      };

    case "SET_COMMAND":
      return {
        ...state,
        ui: { ...state.ui, command: action.payload },
      };

    case "BUMP_COMMAND_INPUT_KEY":
      return {
        ...state,
        ui: { ...state.ui, commandInputKey: state.ui.commandInputKey + 1 },
      };

    case "SET_SCOPE_CLUSTERS":
      return {
        ...state,
        selections: { ...state.selections, scopeClusters: action.payload },
      };

    case "SET_SCOPE_NAMESPACES":
      return {
        ...state,
        selections: { ...state.selections, scopeNamespaces: action.payload },
      };

    case "SET_SCOPE_PROJECTS":
      return {
        ...state,
        selections: { ...state.selections, scopeProjects: action.payload },
      };

    case "SET_SELECTED_APPS":
      return {
        ...state,
        selections: { ...state.selections, selectedApps: action.payload },
      };

    case "SET_CONFIRM_TARGET":
      return {
        ...state,
        modals: { ...state.modals, confirmTarget: action.payload },
      };

    case "SET_CONFIRM_SYNC_PRUNE":
      return {
        ...state,
        modals: { ...state.modals, confirmSyncPrune: action.payload },
      };

    case "SET_CONFIRM_SYNC_WATCH":
      return {
        ...state,
        modals: { ...state.modals, confirmSyncWatch: action.payload },
      };

    case "SET_ROLLBACK_APP_NAME":
      return {
        ...state,
        modals: { ...state.modals, rollbackAppName: action.payload },
      };

    case "SET_SYNC_VIEW_APP":
      return {
        ...state,
        modals: { ...state.modals, syncViewApp: action.payload },
      };

    case "SET_VERSION_OUTDATED":
      return {
        ...state,
        ui: { ...state.ui, isVersionOutdated: action.payload },
      };

    case "SET_LATEST_VERSION":
      return {
        ...state,
        ui: { ...state.ui, latestVersion: action.payload },
      };

    case "SET_LAST_G_PRESSED":
      return {
        ...state,
        navigation: { ...state.navigation, lastGPressed: action.payload },
      };

    case "SET_LAST_ESC_PRESSED":
      return {
        ...state,
        navigation: { ...state.navigation, lastEscPressed: action.payload },
      };

    case "SET_LOADING_ABORT_CONTROLLER":
      return { ...state, loadingAbortController: action.payload };

    case "CLEAR_LOWER_LEVEL_SELECTIONS": {
      const view = action.payload;
      const emptySet = new Set<string>();
      const selections = { ...state.selections };

      switch (view) {
        case "clusters":
          selections.scopeNamespaces = emptySet;
          selections.scopeProjects = emptySet;
          selections.selectedApps = emptySet;
          break;
        case "namespaces":
          selections.scopeProjects = emptySet;
          selections.selectedApps = emptySet;
          break;
        case "projects":
          selections.selectedApps = emptySet;
          break;
      }

      return { ...state, selections };
    }

    case "RESET_NAVIGATION":
      return {
        ...state,
        navigation: {
          ...state.navigation,
          selectedIdx: 0,
          view: action.payload?.view ?? state.navigation.view,
        },
        ui: {
          ...state.ui,
          activeFilter: "",
          searchQuery: "",
        },
      };

    case "CLEAR_ALL_SELECTIONS":
      return {
        ...state,
        selections: {
          scopeClusters: new Set(),
          scopeNamespaces: new Set(),
          scopeProjects: new Set(),
          selectedApps: new Set(),
        },
      };

    case "CLEAR_FILTERS":
      return {
        ...state,
        ui: {
          ...state.ui,
          activeFilter: "",
          searchQuery: "",
        },
      };

    default:
      return state;
  }
}

// Context
export const AppStateContext = createContext<{
  state: AppState;
  dispatch: React.Dispatch<AppAction>;
} | null>(null);

// Provider component
export interface AppStateProviderProps {
  children: ReactNode;
  initialState?: Partial<AppState>;
}

export const AppStateProvider: React.FC<AppStateProviderProps> = ({
  children,
  initialState: providedInitialState,
}) => {
  const finalInitialState = providedInitialState
    ? {
        ...initialState,
        ...providedInitialState,
        ui: { ...initialState.ui, ...(providedInitialState.ui ?? {}) },
        navigation: {
          ...initialState.navigation,
          ...(providedInitialState.navigation ?? {}),
        },
        selections: {
          ...initialState.selections,
          ...(providedInitialState.selections ?? {}),
        },
        modals: {
          ...initialState.modals,
          ...(providedInitialState.modals ?? {}),
        },
      }
    : initialState;

  const [state, dispatch] = useReducer(appStateReducer, finalInitialState);

  return (
    <AppStateContext.Provider value={{ state, dispatch }}>
      {children}
    </AppStateContext.Provider>
  );
};

// Hook to use the context
export const useAppState = () => {
  const context = useContext(AppStateContext);
  if (!context) {
    throw new Error("useAppState must be used within an AppStateProvider");
  }
  return context;
};

// Convenience selector hooks
export const useMode = () => {
  const { state } = useAppState();
  return state.mode;
};

export const useNavigation = () => {
  const { state } = useAppState();
  return state.navigation;
};

export const useSelections = () => {
  const { state } = useAppState();
  return state.selections;
};

export const useTerminal = () => {
  const { state } = useAppState();
  return state.terminal;
};

export const useUI = () => {
  const { state } = useAppState();
  return state.ui;
};

export const useModals = () => {
  const { state } = useAppState();
  return state.modals;
};

export const useServer = () => {
  const { state } = useAppState();
  return state.server;
};

export const useAppsData = () => {
  const { state } = useAppState();
  return { apps: state.apps, apiVersion: state.apiVersion };
};
</file>

</files>
